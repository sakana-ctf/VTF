
#ifndef V_COMMIT_HASH
	#define V_COMMIT_HASH "54c10ec475bc3f59bae7b5c84c971e67169f835d"
#endif

#define V_USE_SIGNAL_H

// V comptime_definitions:
// V compile time defines by -d or -define flags:
//     All custom defines      : gcboehm,gcboehm_full,gcboehm_opt,linux
//     Turned ON custom defines: gcboehm,gcboehm_full,gcboehm_opt,linux
#define CUSTOM_DEFINE_gcboehm
#define CUSTOM_DEFINE_gcboehm_full
#define CUSTOM_DEFINE_gcboehm_opt
#define CUSTOM_DEFINE_linux

#define __VTHREADS__ (1)
#define _VGCBOEHM (1)

// V typedefs:
typedef struct IError IError;
typedef struct veb__ControllerInterface veb__ControllerInterface;
typedef struct veb__MiddlewareApp veb__MiddlewareApp;
typedef struct veb__HasBeforeRequest veb__HasBeforeRequest;
typedef struct veb__StaticApp veb__StaticApp;
typedef struct veb__BeforeAcceptApp veb__BeforeAcceptApp;
typedef struct orm__Connection orm__Connection;
typedef struct net__http__Downloader net__http__Downloader;
typedef struct net__http__Handler net__http__Handler;
typedef struct net__Connection net__Connection;
typedef struct net__Dialer net__Dialer;
typedef struct io__Reader io__Reader;
typedef struct io__Writer io__Writer;
typedef struct io__RandomReader io__RandomReader;
typedef struct io__ReaderWriter io__ReaderWriter;
typedef struct io__RandomWriter io__RandomWriter;
typedef struct rand__PRNG rand__PRNG;
typedef struct hash__Hash hash__Hash;
typedef struct hash__Hash32er hash__Hash32er;
typedef struct hash__Hash64er hash__Hash64er;
typedef struct none none;
typedef struct orm__Primitive orm__Primitive;
typedef struct veb__Middleware_T_main__Context veb__Middleware_T_main__Context;
typedef struct _option_int _option_int;
typedef struct _option_anon_fn_mut_net__mbedtls__ssllistener_string__result_net__mbedtls__SSLCerts _option_anon_fn_mut_net__mbedtls__ssllistener_string__result_net__mbedtls__SSLCerts;
typedef struct veb__MiddlewareOptions_T_main__Context veb__MiddlewareOptions_T_main__Context;

// BEGIN_multi_return_typedefs
typedef struct multi_return_u32_u32 multi_return_u32_u32;
typedef struct multi_return_string_string multi_return_string_string;
typedef struct multi_return_int_int multi_return_int_int;
typedef struct multi_return_u32_u32_u32 multi_return_u32_u32_u32;
typedef struct multi_return_strconv__ParserState_strconv__PrepNumber multi_return_strconv__ParserState_strconv__PrepNumber;
typedef struct multi_return_u64_int multi_return_u64_int;
typedef struct multi_return_i64_int multi_return_i64_int;
typedef struct multi_return_strconv__Dec32_bool multi_return_strconv__Dec32_bool;
typedef struct multi_return_strconv__Dec64_bool multi_return_strconv__Dec64_bool;
typedef struct multi_return_ref_C__sqlite3_stmt_int multi_return_ref_C__sqlite3_stmt_int;
typedef struct multi_return_Array_net__http__Method_string_string multi_return_Array_net__http__Method_string_string;
typedef struct multi_return_Map_string_string_Map_string_Array_net__http__FileData multi_return_Map_string_string_Map_string_Array_net__http__FileData;
typedef struct multi_return_u64_u64 multi_return_u64_u64;
typedef struct multi_return_f64_int multi_return_f64_int;
typedef struct multi_return_string_orm__QueryData multi_return_string_orm__QueryData;
typedef struct multi_return_int_int_int_int multi_return_int_int_int_int;
typedef struct multi_return_int_int_int multi_return_int_int_int;
typedef struct multi_return_int_int_int_int_int_i64_bool multi_return_int_int_int_int_int_i64_bool;
typedef struct multi_return_net__http__Method_net__urllib__URL_net__http__Version multi_return_net__http__Method_net__urllib__URL_net__http__Version;
typedef struct multi_return_string_int_string multi_return_string_int_string;
typedef struct multi_return_int_net__Addr multi_return_int_net__Addr;
typedef struct multi_return_string_u16 multi_return_string_u16;
typedef struct multi_return_string_int multi_return_string_int;
typedef struct multi_return_int_bool multi_return_int_bool;
typedef struct multi_return_string_string_string multi_return_string_string_string;
typedef struct multi_return_f64_f64 multi_return_f64_f64;
typedef struct multi_return_os__File_string multi_return_os__File_string;
typedef struct multi_return_u64_u8 multi_return_u64_u8;
typedef struct multi_return_ref_u16_ref_sync__Subscription multi_return_ref_u16_ref_sync__Subscription;
// END_multi_return_typedefs

typedef struct strconv__AtoF64Param strconv__AtoF64Param;
typedef struct strconv__BF_param strconv__BF_param;
typedef struct strconv__PrepNumber strconv__PrepNumber;
typedef struct strconv__Dec32 strconv__Dec32;
typedef struct strconv__Dec64 strconv__Dec64;
typedef struct strconv__Uint128 strconv__Uint128;
typedef union strconv__Uf32 strconv__Uf32;
typedef union strconv__Uf64 strconv__Uf64;
typedef union strconv__Float64u strconv__Float64u;
typedef union strconv__Float32u strconv__Float32u;
typedef struct array array;
typedef struct GCHeapUsage GCHeapUsage;
typedef struct VCastTypeIndexName VCastTypeIndexName;
typedef struct VAssertMetaInfo VAssertMetaInfo;
typedef struct MethodParam MethodParam;
typedef struct FunctionData FunctionData;
typedef struct VariantData VariantData;
typedef struct EnumData EnumData;
typedef struct FieldData FieldData;
typedef struct VAttribute VAttribute;
typedef struct VContext VContext;
typedef struct DenseArray DenseArray;
typedef struct map map;
typedef struct Option Option;
typedef struct _option _option;
typedef struct None__ None__;
typedef struct _result _result;
typedef struct Error Error;
typedef struct MessageError MessageError;
typedef struct SortedMap SortedMap;
typedef struct mapnode mapnode;
typedef struct string string;
typedef struct RepIndex RepIndex;
typedef struct WrapConfig WrapConfig;
typedef union StrIntpMem StrIntpMem;
typedef struct StrIntpCgenData StrIntpCgenData;
typedef struct StrIntpData StrIntpData;
typedef union encoding__base64__B64_64_datablock encoding__base64__B64_64_datablock;
typedef union encoding__base64__B64_32_datablock encoding__base64__B64_32_datablock;
typedef struct time__DateTimeParser time__DateTimeParser;
typedef struct time__TimeParseError time__TimeParseError;
typedef struct time__StopWatchOptions time__StopWatchOptions;
typedef struct time__StopWatch time__StopWatch;
typedef struct time__Time time__Time;
typedef struct net__urllib__URL net__urllib__URL;
typedef struct net__urllib__Userinfo net__urllib__Userinfo;
typedef struct net__urllib__ParseAuthorityRes net__urllib__ParseAuthorityRes;
typedef struct net__urllib__QueryValue net__urllib__QueryValue;
typedef struct net__urllib__Values net__urllib__Values;
typedef struct io__BufferedReader io__BufferedReader;
typedef struct io__BufferedReaderConfig io__BufferedReaderConfig;
typedef struct io__BufferedReadLineConfig io__BufferedReadLineConfig;
typedef struct io__BufferedWriter io__BufferedWriter;
typedef struct io__BufferedWriterConfig io__BufferedWriterConfig;
typedef struct io__CopySettings io__CopySettings;
typedef struct io__MultiWriter io__MultiWriter;
typedef struct io__Eof io__Eof;
typedef struct io__NotExpected io__NotExpected;
typedef struct io__ReadAllConfig io__ReadAllConfig;
typedef struct io__ReaderWriterImpl io__ReaderWriterImpl;
typedef struct arrays__WindowAttribute arrays__WindowAttribute;
typedef struct arrays__Block arrays__Block;
typedef struct arrays__UnalignedBlock arrays__UnalignedBlock;
typedef struct net__http__chunked__ChunkScanner net__http__chunked__ChunkScanner;
typedef union net__conv__ConversionUnion net__conv__ConversionUnion;
typedef struct strings__textscanner__TextScanner strings__textscanner__TextScanner;
typedef struct term__termios__Termios term__termios__Termios;
typedef struct hash__crc32__Crc32 hash__crc32__Crc32;
typedef struct picohttpparser__Header picohttpparser__Header;
typedef struct picohttpparser__Request picohttpparser__Request;
typedef struct picohttpparser__Pret picohttpparser__Pret;
typedef struct picohttpparser__Response picohttpparser__Response;
typedef struct rand__buffer__PRNGBuffer rand__buffer__PRNGBuffer;
typedef struct orm__Null orm__Null;
typedef struct orm__QueryData orm__QueryData;
typedef struct orm__InfixType orm__InfixType;
typedef struct orm__TableField orm__TableField;
typedef struct orm__SelectConfig orm__SelectConfig;
typedef struct os__Eof os__Eof;
typedef struct os__NotExpected os__NotExpected;
typedef struct os__File os__File;
typedef struct os__FileNotOpenedError os__FileNotOpenedError;
typedef struct os__SizeOfTypeIs0Error os__SizeOfTypeIs0Error;
typedef struct os__FileMode os__FileMode;
typedef struct os__FileInfo os__FileInfo;
typedef struct os__FilePermission os__FilePermission;
typedef struct os__PathKind os__PathKind;
typedef struct os__SystemError os__SystemError;
typedef struct os__DiskUsage os__DiskUsage;
typedef struct os__Result os__Result;
typedef struct os__Command os__Command;
typedef struct os__MvParams os__MvParams;
typedef struct os__ExecutableNotFoundError os__ExecutableNotFoundError;
typedef struct os__MkdirParams os__MkdirParams;
typedef struct os__Uname os__Uname;
typedef struct os__Stat os__Stat;
typedef struct os__Process os__Process;
typedef struct encoding__html__EscapeConfig encoding__html__EscapeConfig;
typedef struct encoding__html__UnescapeConfig encoding__html__UnescapeConfig;
typedef struct compress__gzip__CompressParams compress__gzip__CompressParams;
typedef struct compress__gzip__DecompressParams compress__gzip__DecompressParams;
typedef struct compress__gzip__GzipHeader compress__gzip__GzipHeader;
typedef struct crypto__sha256__Digest crypto__sha256__Digest;
typedef struct db__sqlite__Stmt db__sqlite__Stmt;
typedef struct db__sqlite__SQLError db__sqlite__SQLError;
typedef struct db__sqlite__DB db__sqlite__DB;
typedef struct db__sqlite__Row db__sqlite__Row;
typedef struct cmd__CmdOption cmd__CmdOption;
typedef struct cmd__CmdSet cmd__CmdSet;
typedef struct rand__config__PRNGConfigStruct rand__config__PRNGConfigStruct;
typedef struct rand__config__NormalConfigStruct rand__config__NormalConfigStruct;
typedef struct rand__config__ShuffleConfigStruct rand__config__ShuffleConfigStruct;
typedef struct rand__wyrand__WyRandRNG rand__wyrand__WyRandRNG;
typedef struct sql_db__Personal sql_db__Personal;
typedef struct sql_db__PersonalFlag sql_db__PersonalFlag;
typedef struct sql_db__Task sql_db__Task;
typedef struct sql_db__PostFlag sql_db__PostFlag;
typedef struct sql_db__BlackList sql_db__BlackList;
typedef struct sql_db__BlackId sql_db__BlackId;
typedef struct sql_db__StatusReturn sql_db__StatusReturn;
typedef struct sql_db__Type sql_db__Type;
typedef struct sync__Subscription sync__Subscription;
typedef struct sync__Channel sync__Channel;
typedef struct sync__ManyTimes sync__ManyTimes;
typedef struct sync__Once sync__Once;
typedef struct sync__WaitGroup sync__WaitGroup;
typedef struct sync__Mutex sync__Mutex;
typedef struct sync__RwMutex sync__RwMutex;
typedef struct sync__RwMutexAttr sync__RwMutexAttr;
typedef struct sync__Semaphore sync__Semaphore;
typedef struct io__util__TempFileOptions io__util__TempFileOptions;
typedef struct io__util__TempDirOptions io__util__TempDirOptions;
typedef union net__AddrData net__AddrData;
typedef struct net__Ip6 net__Ip6;
typedef struct net__Ip net__Ip;
typedef struct net__Unix net__Unix;
typedef struct net__Addr net__Addr;
typedef struct net__ShutdownConfig net__ShutdownConfig;
typedef struct net__Socket net__Socket;
typedef struct net__TCPDialer net__TCPDialer;
typedef struct net__TcpConn net__TcpConn;
typedef struct net__TcpListener net__TcpListener;
typedef struct net__ListenOptions net__ListenOptions;
typedef struct net__TcpSocket net__TcpSocket;
typedef struct net__UdpSocket net__UdpSocket;
typedef struct net__UdpConn net__UdpConn;
typedef struct picoev__EpollLoop picoev__EpollLoop;
typedef struct picoev__Target picoev__Target;
typedef struct picoev__Config picoev__Config;
typedef struct picoev__Picoev picoev__Picoev;
typedef struct net__mbedtls__SSLCerts net__mbedtls__SSLCerts;
typedef struct net__mbedtls__SSLConn net__mbedtls__SSLConn;
typedef struct net__mbedtls__SSLListener net__mbedtls__SSLListener;
typedef struct net__mbedtls__SSLConnectConfig net__mbedtls__SSLConnectConfig;
typedef struct net__ssl__SSLDialer net__ssl__SSLDialer;
typedef struct net__ssl__SSLConn net__ssl__SSLConn;
typedef struct net__ssl__SSLConnectConfig net__ssl__SSLConnectConfig;
typedef struct net__socks__SOCKS5Dialer net__socks__SOCKS5Dialer;
typedef struct net__http__Cookie net__http__Cookie;
typedef struct net__http__DownloaderParams net__http__DownloaderParams;
typedef struct net__http__SilentStreamingDownloader net__http__SilentStreamingDownloader;
typedef struct net__http__TerminalStreamingDownloader net__http__TerminalStreamingDownloader;
typedef struct net__http__HeaderKV net__http__HeaderKV;
typedef struct net__http__Header net__http__Header;
typedef struct net__http__HeaderConfig net__http__HeaderConfig;
typedef struct net__http__HeaderCoerceConfig net__http__HeaderCoerceConfig;
typedef struct net__http__HeaderQueryConfig net__http__HeaderQueryConfig;
typedef struct net__http__HeaderRenderConfig net__http__HeaderRenderConfig;
typedef struct net__http__HeaderKeyError net__http__HeaderKeyError;
typedef struct net__http__FetchConfig net__http__FetchConfig;
typedef struct net__http__PostMultipartFormConfig net__http__PostMultipartFormConfig;
typedef struct net__http__HttpProxy net__http__HttpProxy;
typedef struct net__http__Request net__http__Request;
typedef struct net__http__FileData net__http__FileData;
typedef struct net__http__UnexpectedExtraAttributeError net__http__UnexpectedExtraAttributeError;
typedef struct net__http__MultiplePathAttributesError net__http__MultiplePathAttributesError;
typedef struct net__http__LineSegmentIndexes net__http__LineSegmentIndexes;
typedef struct net__http__Response net__http__Response;
typedef struct net__http__ResponseConfig net__http__ResponseConfig;
typedef struct net__http__Server net__http__Server;
typedef struct net__http__WaitTillRunningParams net__http__WaitTillRunningParams;
typedef struct net__http__HandlerWorker net__http__HandlerWorker;
typedef struct net__http__DebugHandler net__http__DebugHandler;
typedef struct veb__Context veb__Context;
typedef struct veb__RedirectParams veb__RedirectParams;
typedef struct veb__ControllerPath veb__ControllerPath;
typedef struct veb__Controller veb__Controller;
typedef struct veb__RouteMiddleware veb__RouteMiddleware;
typedef struct veb__Middleware veb__Middleware;
typedef struct veb__MiddlewareOptions veb__MiddlewareOptions;
typedef struct veb__CorsOptions veb__CorsOptions;
typedef struct veb__FileData veb__FileData;
typedef struct veb__StaticHandler veb__StaticHandler;
typedef struct veb__Result veb__Result;
typedef struct veb__Route veb__Route;
typedef struct veb__RunParams veb__RunParams;
typedef struct veb__FileResponse veb__FileResponse;
typedef struct veb__StringResponse veb__StringResponse;
typedef struct veb__RequestParams veb__RequestParams;
typedef struct main__Rank main__Rank;
typedef struct main__Context main__Context;
typedef struct main__App main__App;
typedef struct _result_string _result_string;
typedef struct _result_void _result_void;
typedef struct _result_int _result_int;
typedef struct _result_net__mbedtls__SSLCerts_ptr _result_net__mbedtls__SSLCerts_ptr;
typedef struct _result_u64 _result_u64;
typedef struct _result_i64 _result_i64;
typedef struct _result_rune _result_rune;
typedef struct _result_Array_string _result_Array_string;
typedef struct _result_net__urllib__URL _result_net__urllib__URL;
typedef struct _result_net__urllib__ParseAuthorityRes _result_net__urllib__ParseAuthorityRes;
typedef struct _result_bool _result_bool;
typedef struct _result_Array_Array_orm__Primitive _result_Array_Array_orm__Primitive;
typedef struct _result_os__File _result_os__File;
typedef struct _result_FILE_ptr _result_FILE_ptr;
typedef struct _result_strings__Builder _result_strings__Builder;
typedef struct _result_os__Stat _result_os__Stat;
typedef struct _result_db__sqlite__Stmt _result_db__sqlite__Stmt;
typedef struct _result_orm__Primitive _result_orm__Primitive;
typedef struct _result_db__sqlite__DB _result_db__sqlite__DB;
typedef struct _result_Array_db__sqlite__Row _result_Array_db__sqlite__Row;
typedef struct _result_Array_sql_db__Personal _result_Array_sql_db__Personal;
typedef struct _result_Array_sql_db__PersonalFlag _result_Array_sql_db__PersonalFlag;
typedef struct _result_Array_sql_db__Task _result_Array_sql_db__Task;
typedef struct _result_Array_sql_db__PostFlag _result_Array_sql_db__PostFlag;
typedef struct _result_u32 _result_u32;
typedef struct _result_Array_net__Addr _result_Array_net__Addr;
typedef struct _result_multi_return_string_u16 _result_multi_return_string_u16;
typedef struct _result_net__Addr _result_net__Addr;
typedef struct _result_net__Connection _result_net__Connection;
typedef struct _result_net__TcpConn_ptr _result_net__TcpConn_ptr;
typedef struct _result_net__TcpSocket _result_net__TcpSocket;
typedef struct _result_time__Time _result_time__Time;
typedef struct _result_u16 _result_u16;
typedef struct _result_picoev__EpollLoop_ptr _result_picoev__EpollLoop_ptr;
typedef struct _result_picoev__Picoev_ptr _result_picoev__Picoev_ptr;
typedef struct _result_net__mbedtls__SSLConn_ptr _result_net__mbedtls__SSLConn_ptr;
typedef struct _result_net__ssl__SSLConn_ptr _result_net__ssl__SSLConn_ptr;
typedef struct _result_Array_u8 _result_Array_u8;
typedef struct _result_net__http__Header _result_net__http__Header;
typedef struct _result_net__http__Request _result_net__http__Request;
typedef struct _result_multi_return_net__http__Method_net__urllib__URL_net__http__Version _result_multi_return_net__http__Method_net__urllib__URL_net__http__Version;
typedef struct _result_Array_veb__ControllerPath_ptr _result_Array_veb__ControllerPath_ptr;
typedef struct _result_multi_return_Array_net__http__Method_string_string _result_multi_return_Array_net__http__Method_string_string;
typedef struct _result_multi_return_Map_string_string_Map_string_Array_net__http__FileData _result_multi_return_Map_string_string_Map_string_Array_net__http__FileData;
typedef struct _result_Map_string_veb__Route _result_Map_string_veb__Route;
typedef struct _result_Array_main__Rank _result_Array_main__Rank;
typedef struct _result_main__Rank _result_main__Rank;
typedef struct _result_Array_bool _result_Array_bool;
typedef struct _option_multi_return_string_string _option_multi_return_string_string;
typedef struct _option_u8 _option_u8;
typedef struct _option_bool _option_bool;
typedef struct _option_f32 _option_f32;
typedef struct _option_f64 _option_f64;
typedef struct _option_i8 _option_i8;
typedef struct _option_i16 _option_i16;
typedef struct _option_i64 _option_i64;
typedef struct _option_u16 _option_u16;
typedef struct _option_u32 _option_u32;
typedef struct _option_u64 _option_u64;
typedef struct _option_string _option_string;
typedef struct _option_time__Time _option_time__Time;
typedef struct _option_db__sqlite__DB _option_db__sqlite__DB;
typedef struct _option_net__Addr _option_net__Addr;
typedef struct _option_net__http__Cookie _option_net__http__Cookie;
typedef struct _option_Array_string _option_Array_string;
typedef struct _option_veb__Context_ptr _option_veb__Context_ptr;
typedef struct _option_veb__Route _option_veb__Route;

 // V preincludes:

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

// V cheaders:
// Generated by the V compiler

#if defined __GNUC__ && __GNUC__ >= 14
#pragma GCC diagnostic warning "-Wimplicit-function-declaration"
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#pragma GCC diagnostic warning "-Wint-conversion"
#pragma GCC diagnostic warning "-Wreturn-mismatch"
#endif

#define _GNU_SOURCE

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#if defined(__has_include)

#if __has_include(<inttypes.h>)
#include <inttypes.h>
#else
#error VERROR_MESSAGE The C compiler can not find <inttypes.h>. Please install the package `build-essential`.
#endif

#else
#include <inttypes.h>
#endif


#if defined(__has_include)

#if __has_include(<stddef.h>)
#include <stddef.h>
#else
#error VERROR_MESSAGE The C compiler can not find <stddef.h>. Please install the package `build-essential`.
#endif

#else
#include <stddef.h>
#endif


//================================== builtin types ================================*/
#if defined(__x86_64__) || defined(_M_AMD64) || defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64) || (defined(__riscv_xlen) && __riscv_xlen == 64)
typedef int64_t vint_t;
#else
typedef int32_t vint_t;
#endif
typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint8_t u8;
typedef uint16_t u16;
typedef u8 byte;
typedef int32_t i32;
typedef uint32_t rune;
typedef size_t usize;
typedef ptrdiff_t isize;
#ifndef VNOFLOAT
typedef float f32;
typedef double f64;
#else
typedef int32_t f32;
typedef int64_t f64;
#endif
typedef int64_t int_literal;
#ifndef VNOFLOAT
typedef double float_literal;
#else
typedef int64_t float_literal;
#endif
typedef unsigned char* byteptr;
typedef void* voidptr;
typedef char* charptr;
typedef u8 array_fixed_byte_300 [300];

typedef struct sync__Channel* chan;

#ifndef CUSTOM_DEFINE_no_bool
	#ifndef __cplusplus
		#ifndef bool
			#ifdef CUSTOM_DEFINE_4bytebool
				typedef int bool;
			#else
				typedef u8 bool;
			#endif
			#define true 1
			#define false 0
		#endif
	#endif
#endif

typedef u64 (*MapHashFn)(voidptr);
typedef bool (*MapEqFn)(voidptr, voidptr);
typedef void (*MapCloneFn)(voidptr, voidptr);
typedef void (*MapFreeFn)(voidptr);

//============================== HELPER C MACROS =============================*/
// _SLIT0 is used as NULL string for literal arguments
// `"" s` is used to enforce a string literal argument
#define _SLIT0 (string){.str=(byteptr)(""), .len=0, .is_lit=1}
#define _SLIT(s) ((string){.str=(byteptr)("" s), .len=(sizeof(s)-1), .is_lit=1})
#define _SLEN(s, n) ((string){.str=(byteptr)("" s), .len=n, .is_lit=1})
// optimized way to compare literal strings
#define _SLIT_EQ(sptr, slen, lit) (slen == sizeof("" lit)-1 && !vmemcmp(sptr, "" lit, slen))
#define _SLIT_NE(sptr, slen, lit) (slen != sizeof("" lit)-1 || vmemcmp(sptr, "" lit, slen))

// take the address of an rvalue
#define ADDR(type, expr) (&((type[]){expr}[0]))

// copy something to the heap
#define HEAP(type, expr) ((type*)memdup((void*)&((type[]){expr}[0]), sizeof(type)))
#define HEAP_noscan(type, expr) ((type*)memdup_noscan((void*)&((type[]){expr}[0]), sizeof(type)))

#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}
#define _PUSH_MANY_noscan(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many_noscan(arr, tmp.data, tmp.len);}

// unsigned/signed comparisons
static inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }
static inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }
static inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }
static inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }
static inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }
static inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }
static inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }
static inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }
static inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }
static inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }
static inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }
static inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }

#define EMPTY_VARG_INITIALIZATION 0
#define EMPTY_STRUCT_DECLARATION
#define EMPTY_STRUCT_INITIALIZATION
// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])
#define TCCSKIP(x) x

#define __NOINLINE __attribute__((noinline))
#define __IRQHANDLER __attribute__((interrupt))

#define __V_architecture 0
#if defined(__x86_64__) || defined(_M_AMD64)
	#define __V_amd64  1
	#undef __V_architecture
	#define __V_architecture 1
#endif

#if defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64)
	#define __V_arm64  1
	#undef __V_architecture
	#define __V_architecture 2
#endif

#if defined(__arm__) || defined(_M_ARM)
	#define __V_arm32  1
	#undef __V_architecture
	#define __V_architecture 3
#endif

#if defined(__riscv) && __riscv_xlen == 64
	#define __V_rv64  1
	#undef __V_architecture
	#define __V_architecture 4
#endif

#if defined(__riscv) && __riscv_xlen == 32
	#define __V_rv32  1
	#undef __V_architecture
	#define __V_architecture 5
#endif

#if defined(__i386__) || defined(_M_IX86)
	#define __V_x86    1
	#undef __V_architecture
	#define __V_architecture 6
#endif

// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:
#ifdef __GNUC__
	#define __V_GCC__
#endif
#ifdef __TINYC__
	#undef __V_GCC__
#endif
#ifdef __cplusplus
	#undef __V_GCC__
#endif
#ifdef __clang__
	#undef __V_GCC__
#endif

#ifdef _MSC_VER
	#undef __V_GCC__
	#undef EMPTY_STRUCT_DECLARATION
	#undef EMPTY_STRUCT_INITIALIZATION
	#define EMPTY_STRUCT_DECLARATION unsigned char _dummy_pad
	#define EMPTY_STRUCT_INITIALIZATION 0
#endif

#ifndef _WIN32
	#if defined __has_include
		#if __has_include (<execinfo.h>)
			#include <execinfo.h>
		#else
			// On linux: int backtrace(void **__array, int __size);
			// On BSD: size_t backtrace(void **, size_t);
		#endif
	#endif
#endif

#ifdef __TINYC__
	#define _Atomic volatile
	#undef EMPTY_STRUCT_DECLARATION
	#undef EMPTY_STRUCT_INITIALIZATION
	#define EMPTY_STRUCT_DECLARATION unsigned char _dummy_pad
	#define EMPTY_STRUCT_INITIALIZATION 0
	#undef EMPTY_ARRAY_OF_ELEMS
	#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])
	#undef __NOINLINE
	#undef __IRQHANDLER
	// tcc does not support inlining at all
	#define __NOINLINE
	#define __IRQHANDLER
	#undef TCCSKIP
	#define TCCSKIP(x)
	// #include <byteswap.h>
	#ifndef _WIN32
		int tcc_backtrace(const char *fmt, ...);
	#endif
#endif

// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:
#ifndef __offsetof_ptr
	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))
#endif

// for __offset_of
#ifndef __offsetof
#if defined(__TINYC__) || defined(_MSC_VER)
	#define __offsetof(PTYPE,FIELDNAME) ((size_t)(&((PTYPE *)0)->FIELDNAME))
#else
	#define __offsetof(st, m) __builtin_offsetof(st, m)
#endif
#endif

#define OPTION_CAST(x) (x)

#if defined(_WIN32) || defined(__CYGWIN__)
	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)
	#define VV_LOCAL_SYMBOL static
#else
	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,
	// and does not support __has_attribute(visibility) ...
	#ifndef __has_attribute
		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.
	#endif
	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))
		#ifdef ARM
			#define VV_EXPORTED_SYMBOL  extern __attribute__((externally_visible,visibility("default")))
		#else
			#define VV_EXPORTED_SYMBOL  extern __attribute__((visibility("default")))
		#endif
		#if defined(__clang__) && (defined(_VUSECACHE) || defined(_VBUILDMODULE))
			#define VV_LOCAL_SYMBOL static
		#else
			#define VV_LOCAL_SYMBOL  __attribute__ ((visibility ("hidden")))
		#endif
	#else
		#define VV_EXPORTED_SYMBOL extern
		#define VV_LOCAL_SYMBOL static
	#endif
#endif

#ifdef __cplusplus
	#include <utility>
	#define _MOV std::move
#else
	#define _MOV
#endif

// tcc does not support has_include properly yet, turn it off completely
#if defined(__TINYC__) && defined(__has_include)
#undef __has_include
#endif


#if !defined(VWEAK)
	#define VWEAK __attribute__((weak))
	#ifdef _MSC_VER
		#undef VWEAK
		#define VWEAK
	#endif
	#if defined(__MINGW32__) || defined(__MINGW64__)
		#undef VWEAK
		#define VWEAK
	#endif
#endif

#if !defined(VHIDDEN)
	#define VHIDDEN __attribute__((visibility("hidden")))
	#ifdef _MSC_VER
		#undef VHIDDEN
		#define VHIDDEN
	#endif
	#if defined(__MINGW32__) || defined(__MINGW64__)
		#undef VHIDDEN
		#define VHIDDEN
	#endif
#endif

#if !defined(VNORETURN)
	#if defined(__TINYC__)
		#include <stdnoreturn.h>
		#define VNORETURN noreturn
	#endif
	# if !defined(__TINYC__) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
	#  define VNORETURN _Noreturn
	# elif !defined(VNORETURN) && defined(__GNUC__) && __GNUC__ >= 2
	#  define VNORETURN __attribute__((noreturn))
	# endif
	#ifndef VNORETURN
		#define VNORETURN
	#endif
#endif

#if !defined(VUNREACHABLE)
	#if defined(__GNUC__) && !defined(__clang__)
		#define V_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)
		#if (V_GCC_VERSION >= 40500L) && !defined(__TINYC__)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#if defined(__clang__) && defined(__has_builtin) && !defined(__TINYC__)
		#if __has_builtin(__builtin_unreachable)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#ifndef VUNREACHABLE
		#define VUNREACHABLE() do { } while (0)
	#endif
#endif

//likely and unlikely macros
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
	#define _likely_(x)  __builtin_expect(x,1)
	#define _unlikely_(x)  __builtin_expect(x,0)
#else
	#define _likely_(x) (x)
	#define _unlikely_(x) (x)
#endif


// c_headers
typedef int (*qsort_callback_func)(const void*, const void*);
#include <stdio.h>  // TODO: remove all these includes, define all function signatures and types manually
#include <stdlib.h>
#include <string.h>

#include <stdarg.h> // for va_list

//================================== GLOBALS =================================*/
int load_so(byteptr);
void _vinit(int ___argc, voidptr ___argv);
void _vcleanup(void);
#ifdef _WIN32
	// workaround for windows, export _vinit_caller/_vcleanup_caller, let dl.open()/dl.close() call it
	// NOTE: This is hardcoded in vlib/dl/dl_windows.c.v!
	VV_EXPORTED_SYMBOL void _vinit_caller();
	VV_EXPORTED_SYMBOL void _vcleanup_caller();
#endif
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )

void v_free(voidptr ptr);

#if INTPTR_MAX == INT32_MAX
	#define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
	#define TARGET_IS_64BIT 1
#else
	#error "The environment is not 32 or 64-bit."
#endif

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
	#define TARGET_ORDER_IS_BIG 1
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_ARM64) || defined(_M_X64) || defined(_M_IX86)
	#define TARGET_ORDER_IS_LITTLE 1
#else
	#error "Unknown architecture endianness"
#endif

#ifndef _WIN32
	#include <ctype.h>
	#include <locale.h> // tolower
	#include <sys/time.h>
	#include <unistd.h> // sleep
	extern char **environ;
#endif

#if defined(__CYGWIN__) && !defined(_WIN32)
	#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif

#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__vinix__) || defined(__serenity__) || defined(__sun) || defined(__plan9__)
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __OpenBSD__
	#include <sys/types.h>
	#include <sys/resource.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __FreeBSD__
	#include <signal.h>
	#include <execinfo.h>
#endif

#ifdef __NetBSD__
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef _WIN32
	#define WINVER 0x0600
	#ifdef _WIN32_WINNT
		#undef _WIN32_WINNT
	#endif
	#define _WIN32_WINNT 0x0600
	#ifndef WIN32_FULL
	#define WIN32_LEAN_AND_MEAN
	#endif
	#ifndef _UNICODE
	#define _UNICODE
	#endif
	#ifndef UNICODE
	#define UNICODE
	#endif
	#include <windows.h>

	#include <io.h> // _waccess
	#include <direct.h> // _wgetcwd
	#ifdef V_USE_SIGNAL_H
	#include <signal.h> // signal and SIGSEGV for segmentation fault handler
	#endif

	#ifdef _MSC_VER
		// On MSVC these are the same (as long as /volatile:ms is passed)
		#define _Atomic volatile

		// MSVC cannot parse some things properly
		#undef OPTION_CAST
		#define OPTION_CAST(x)
		#undef __NOINLINE
		#undef __IRQHANDLER
		#define __NOINLINE __declspec(noinline)
		#define __IRQHANDLER __declspec(naked)

		#include <dbghelp.h>
		#pragma comment(lib, "Dbghelp")
	#endif
#else
	#include <pthread.h>
	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
		// musl does not have that
		#define pthread_rwlockattr_setkind_np(a, b)
	#endif
#endif

// g_live_info is used by live.info()
static void* g_live_info = NULL;

#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))
	#undef PRId64
	#undef PRIi64
	#undef PRIo64
	#undef PRIu64
	#undef PRIx64
	#undef PRIX64
	#define PRId64 "lld"
	#define PRIi64 "lli"
	#define PRIo64 "llo"
	#define PRIu64 "llu"
	#define PRIx64 "llx"
	#define PRIX64 "llX"
#endif

#ifdef _VFREESTANDING
#undef _VFREESTANDING
#endif


// ============== wyhash ==============
#ifndef wyhash_final_version_3
#define wyhash_final_version_3

#ifndef WYHASH_CONDOM
// protections that produce different results:
// 1: normal valid behavior
// 2: extra protection against entropy loss (probability=2^-63), aka. "blind multiplication"
#define WYHASH_CONDOM 1
#endif

#ifndef WYHASH_32BIT_MUM
// 0: normal version, slow on 32 bit systems
// 1: faster on 32 bit systems but produces different results, incompatible with wy2u0k function
#define WYHASH_32BIT_MUM 0
#endif

// includes
#include <stdint.h>
#if defined(_MSC_VER) && defined(_M_X64)
	#include <intrin.h>
	#pragma intrinsic(_umul128)
#endif

// 128bit multiply function
static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }
static inline void _wymum(uint64_t *A, uint64_t *B){
#if(WYHASH_32BIT_MUM)
	uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
	#if(WYHASH_CONDOM>1)
	*A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
	#else
	*A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
	#endif
#elif defined(__SIZEOF_INT128__) && !defined(VWASM)
	__uint128_t r=*A; r*=*B;
	#if(WYHASH_CONDOM>1)
	*A^=(uint64_t)r; *B^=(uint64_t)(r>>64);
	#else
	*A=(uint64_t)r; *B=(uint64_t)(r>>64);
	#endif
#elif defined(_MSC_VER) && defined(_M_X64)
	#if(WYHASH_CONDOM>1)
	uint64_t  a,  b;
	a=_umul128(*A,*B,&b);
	*A^=a;  *B^=b;
	#else
	*A=_umul128(*A,*B,B);
	#endif
#else
	uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
	#if(WYHASH_CONDOM>1)
	*A^=lo;  *B^=hi;
	#else
	*A=lo;  *B=hi;
	#endif
#endif
}

// multiply and xor mix function, aka MUM
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }

// endian macros
#ifndef WYHASH_LITTLE_ENDIAN
	#ifdef TARGET_ORDER_IS_LITTLE
		#define WYHASH_LITTLE_ENDIAN 1
	#else
		#define WYHASH_LITTLE_ENDIAN 0
	#endif
#endif

// read functions
#if (WYHASH_LITTLE_ENDIAN)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}
#elif !defined(__TINYC__) && (defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__))
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#else
	static inline uint64_t _wyr8(const uint8_t *p) {
		uint64_t v; memcpy(&v, p, 8);
		return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));
	}
	static inline uint64_t _wyr4(const uint8_t *p) {
		uint32_t v; memcpy(&v, p, 4);
		return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
	}
#endif
static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}
// wyhash main function
static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
	const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t a, b;
	if (_likely_(len<=16)) {
		if (_likely_(len>=4)) { a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }
		else if (_likely_(len>0)) { a=_wyr3(p,len); b=0; }
		else a=b=0;
	} else {
		size_t i=len;
		if (_unlikely_(i>48)) {
			uint64_t see1=seed, see2=seed;
			do {
				seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
				see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
				see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
				p+=48; i-=48;
			} while(_likely_(i>48));
			seed^=see1^see2;
		}
		while(_unlikely_(i>16)) { seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16; }
		a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
	}
	return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
}
// the default secret parameters
static const uint64_t _wyp[4] = {0xa0761d6478bd642f, 0xe7037ed1a0b428db, 0x8ebc6af09c88c6e3, 0x589965cc75374cc3};

// a useful 64bit-64bit mix function to produce deterministic pseudo random numbers that can pass BigCrush and PractRand
static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0xa0761d6478bd642f; B^=0xe7037ed1a0b428db; _wymum(&A,&B); return _wymix(A^0xa0761d6478bd642f,B^0xe7037ed1a0b428db);}

// the wyrand PRNG that pass BigCrush and PractRand
static inline uint64_t wyrand(uint64_t *seed){ *seed+=0xa0761d6478bd642f; return _wymix(*seed,*seed^0xe7037ed1a0b428db);}

#ifndef __vinix__
// convert any 64 bit pseudo random numbers to uniform distribution [0,1). It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull<<52); return (r>>12)*_wynorm;}

// convert any 64 bit pseudo random numbers to APPROXIMATE Gaussian distribution. It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull<<20); return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;}
#endif

#if(!WYHASH_32BIT_MUM)
// fast range integer random number generation on [0,k) credit to Daniel Lemire. May not work when WYHASH_32BIT_MUM=1. It can be combined with wyrand, wyhash64 or wyhash.
static inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&r,&k); return k; }
#endif
#endif

#define _IN_MAP(val, m) map_exists(m, val)


#if __GLIBC__ == 2 && __GLIBC_MINOR__ < 30
#include <sys/syscall.h>
#define gettid() syscall(SYS_gettid)
#endif

// V includes:

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

// added by module `builtin`, file: builtin_d_gcboehm.c.v:129:

#if defined(__has_include)

#if __has_include(<gc.h>)
#include <gc.h>
#else
#error VERROR_MESSAGE Header file <gc.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif

#else
#include <gc.h>
#endif


// added by module `builtin`, file: float.c.v:10:

#if defined(__has_include)

#if __has_include(<float.h>)
#include <float.h>
#else
#error VERROR_MESSAGE Header file <float.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif

#else
#include <float.h>
#endif


// added by module `json`, file: json_primitives.c.v:8:

#if defined(__has_include)

#if __has_include("cJSON.h")
#include "cJSON.h"
#else
#error VERROR_MESSAGE Header file "cJSON.h", needed for module `json` was not found. Please install the corresponding development headers.
#endif

#else
#include "cJSON.h"
#endif

// defined by module `json`
#define js_get(object, key) cJSON_GetObjectItemCaseSensitive((object), (key))

// added by module `time`, file: time.c.v:6:

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif


// added by module `time`, file: time_nix.c.v:7:

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif


// added by module `time`, file: time_nix.c.v:8:
#include <errno.h>

// added by module `term.termios`, file: termios_linux.c.v:10:

#if defined(__has_include)

#if __has_include(<termios.h>)
#include <termios.h>
#else
#error VERROR_MESSAGE Header file <termios.h>, needed for module `term.termios` was not found. Please install the corresponding development headers.
#endif

#else
#include <termios.h>
#endif


// added by module `term.termios`, file: termios_linux.c.v:11:

#if defined(__has_include)

#if __has_include(<sys/ioctl.h>)
#include <sys/ioctl.h>
#else
#error VERROR_MESSAGE Header file <sys/ioctl.h>, needed for module `term.termios` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/ioctl.h>
#endif


// added by module `compress`, file: compress.c.v:4:

#if defined(__has_include)

#if __has_include("miniz.h")
#include "miniz.h"
#else
#error VERROR_MESSAGE Header file "miniz.h", needed for module `compress` was not found. Please install the corresponding development headers.
#endif

#else
#include "miniz.h"
#endif


// added by module `picohttpparser`, file: response.c.v:4:

#if defined(__has_include)

#if __has_include(<sys/socket.h>)
#include <sys/socket.h>
#else
#error VERROR_MESSAGE Header file <sys/socket.h>, needed for module `picohttpparser` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/socket.h>
#endif

// inserted by module `sync.stdatomic`, file: 1.declarations.c.v:11:
/*
    Compatibility header for stdatomic.h that works for all compilers supported by V.
    For TCC, we use libatomic from the OS.
*/
#ifndef __ATOMIC_H
#define __ATOMIC_H

#ifndef __cplusplus
// If C just use stdatomic.h
#ifndef __TINYC__
#include <stdatomic.h>
#endif
#else
// CPP wrapper for atomic operations that are compatible with C
#include "atomic_cpp.h"
#endif

#ifdef __TINYC__

typedef volatile long long atomic_llong;
typedef volatile unsigned long long atomic_ullong;
typedef volatile uintptr_t atomic_uintptr_t;

// use functions for 64, 32 and 8 bit from libatomic directly
// since tcc is not capible to use "generic" C functions
// there is no header file for libatomic so we provide function declarations here

extern unsigned long long __atomic_load_8(unsigned long long* x, int mo);
extern void __atomic_store_8(unsigned long long* x, unsigned long long y, int mo);
extern _Bool __atomic_compare_exchange_8(unsigned long long* x, unsigned long long* expected, unsigned long long y, int mo, int mo2);
extern _Bool __atomic_compare_exchange_8(unsigned long long* x, unsigned long long* expected, unsigned long long y, int mo, int mo2);
extern unsigned long long __atomic_exchange_8(unsigned long long* x, unsigned long long y, int mo);
extern unsigned long long __atomic_fetch_add_8(unsigned long long* x, unsigned long long y, int mo);
extern unsigned long long __atomic_fetch_sub_8(unsigned long long* x, unsigned long long y, int mo);
extern unsigned long long __atomic_fetch_and_8(unsigned long long* x, unsigned long long y, int mo);
extern unsigned long long __atomic_fetch_or_8(unsigned long long* x, unsigned long long y, int mo);
extern unsigned long long __atomic_fetch_xor_8(unsigned long long* x, unsigned long long y, int mo);

extern unsigned int __atomic_load_4(unsigned int* x, int mo);
extern void __atomic_store_4(unsigned int* x, unsigned int y, int mo);
extern _Bool __atomic_compare_exchange_4(unsigned int* x, unsigned int* expected, unsigned int y, int mo, int mo2);
extern _Bool __atomic_compare_exchange_4(unsigned int* x, unsigned int* expected, unsigned int y, int mo, int mo2);
extern unsigned int __atomic_exchange_4(unsigned int* x, unsigned int y, int mo);
extern unsigned int __atomic_fetch_add_4(unsigned int* x, unsigned int y, int mo);
extern unsigned int __atomic_fetch_sub_4(unsigned int* x, unsigned int y, int mo);
extern unsigned int __atomic_fetch_and_4(unsigned int* x, unsigned int y, int mo);
extern unsigned int __atomic_fetch_or_4(unsigned int* x, unsigned int y, int mo);
extern unsigned int __atomic_fetch_xor_4(unsigned int* x, unsigned int y, int mo);

extern unsigned short __atomic_load_2(unsigned short* x, int mo);
extern void __atomic_store_2(unsigned short* x, unsigned short y, int mo);
extern _Bool __atomic_compare_exchange_2(unsigned short* x, unsigned short* expected, unsigned short y, int mo, int mo2);
extern _Bool __atomic_compare_exchange_2(unsigned short* x, unsigned short* expected, unsigned short y, int mo, int mo2);
extern unsigned short __atomic_exchange_2(unsigned short* x, unsigned short y, int mo);
extern unsigned short __atomic_fetch_add_2(unsigned short* x, unsigned short y, int mo);
extern unsigned short __atomic_fetch_sub_2(unsigned short* x, unsigned short y, int mo);
extern unsigned short __atomic_fetch_and_2(unsigned short* x, unsigned short y, int mo);
extern unsigned short __atomic_fetch_or_2(unsigned short* x, unsigned short y, int mo);
extern unsigned short __atomic_fetch_xor_2(unsigned short* x, unsigned short y, int mo);

extern unsigned char __atomic_load_1(unsigned char* x, int mo);
extern void __atomic_store_1(unsigned char* x, unsigned char y, int mo);
extern _Bool __atomic_compare_exchange_1(unsigned char* x, unsigned char* expected, unsigned char y, int mo, int mo2);
extern _Bool __atomic_compare_exchange_1(unsigned char* x, unsigned char* expected, unsigned char y, int mo, int mo2);
extern unsigned char __atomic_exchange_1(unsigned char* x, unsigned char y, int mo);
extern unsigned char __atomic_fetch_add_1(unsigned char* x, unsigned char y, int mo);
extern unsigned char __atomic_fetch_sub_1(unsigned char* x, unsigned char y, int mo);
extern unsigned char __atomic_fetch_and_1(unsigned char* x, unsigned char y, int mo);
extern unsigned char __atomic_fetch_or_1(unsigned char* x, unsigned char y, int mo);
extern unsigned char __atomic_fetch_xor_1(unsigned char* x, unsigned char y, int mo);

// The default functions should work with pointers so we have to decide based on pointer size
#if UINTPTR_MAX == 0xFFFFFFFF

#define atomic_load_explicit __atomic_load_4
#define atomic_store_explicit __atomic_store_4
#define atomic_compare_exchange_weak_explicit __atomic_compare_exchange_4
#define atomic_compare_exchange_strong_explicit __atomic_compare_exchange_4
#define atomic_exchange_explicit __atomic_exchange_4
#define atomic_fetch_add_explicit __atomic_fetch_add_4
#define atomic_fetch_sub_explicit __atomic_sub_fetch_4

#else

#define atomic_load_explicit __atomic_load_8
#define atomic_store_explicit __atomic_store_8
#define atomic_compare_exchange_weak_explicit __atomic_compare_exchange_8
#define atomic_compare_exchange_strong_explicit __atomic_compare_exchange_8
#define atomic_exchange_explicit __atomic_exchange_8
#define atomic_fetch_add_explicit __atomic_fetch_add_8
#define atomic_fetch_sub_explicit __atomic_sub_fetch_8

#endif

// memory order policies - we use "sequentially consistent" by default

#define memory_order_relaxed 0
#define memory_order_consume 1
#define memory_order_acquire 2
#define memory_order_release 3
#define memory_order_acq_rel 4
#define memory_order_seq_cst 5

static inline void** atomic_load(void** x) {
	return (void**)atomic_load_explicit((unsigned long long*)x, memory_order_seq_cst);
}
static inline void atomic_store(void** x, void* y) {
	atomic_store_explicit((unsigned long long*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak(void** x, void** expected, intptr_t y) {
	return (int)atomic_compare_exchange_weak_explicit((unsigned long long*)x, (unsigned long long*)expected, (uintptr_t)y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong(void** x,  void** expected, intptr_t y) {
	return (int)atomic_compare_exchange_strong_explicit((unsigned long long*)x, (unsigned long long*)expected, (uintptr_t)y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline uintptr_t atomic_exchange(void** x, void* y) {
	return atomic_exchange_explicit((unsigned long long*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline uintptr_t atomic_fetch_add(uintptr_t* x, uintptr_t y) {
	return atomic_fetch_add_explicit(x, y, memory_order_seq_cst);
}
static inline uintptr_t atomic_fetch_sub(uintptr_t* x, uintptr_t y) {
	return atomic_fetch_sub_explicit(x, y, memory_order_seq_cst);
}
static inline uintptr_t atomic_fetch_and(uintptr_t* x, uintptr_t y) {
	return atomic_fetch_and_explicit(x, y, memory_order_seq_cst);
}
static inline uintptr_t atomic_fetch_or(uintptr_t* x, uintptr_t y) {
	return atomic_fetch_or_explicit(x, y, memory_order_seq_cst);
}
static inline uintptr_t atomic_fetch_xor(uintptr_t* x, uintptr_t y) {
	return atomic_fetch_xor_explicit(x, y, memory_order_seq_cst);
}

#define atomic_load_ptr atomic_load
#define atomic_store_ptr atomic_store
#define atomic_compare_exchange_weak_ptr atomic_compare_exchange_weak
#define atomic_compare_exchange_strong_ptr atomic_compare_exchange_strong
#define atomic_exchange_ptr atomic_exchange
#define atomic_fetch_add_ptr atomic_fetch_add
#define atomic_fetch_sub_ptr atomic_fetch_sub
#define atomic_fetch_and_ptr atomic_fetch_and
#define atomic_fetch_or_ptr atomic_fetch_or
#define atomic_fetch_xor_ptr atomic_fetch_xor

// specialized versions for 64 bit

static inline unsigned long long atomic_load_u64(unsigned long long* x) {
	return __atomic_load_8(x, memory_order_seq_cst);
}
static inline void atomic_store_u64(unsigned long long* x, unsigned long long y) {
	__atomic_store_8(x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u64(unsigned long long* x, unsigned long long* expected, unsigned long long y) {
	return (int)__atomic_compare_exchange_8(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u64(unsigned long long* x, unsigned long long* expected, unsigned long long y) {
	return (int)__atomic_compare_exchange_8(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned long long atomic_exchange_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_exchange_8(x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_add_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_fetch_add_8(x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_sub_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_fetch_sub_8(x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_and_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_fetch_and_8(x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_or_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_fetch_or_8(x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_xor_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_fetch_xor_8(x, y, memory_order_seq_cst);
}

static inline unsigned atomic_load_u32(unsigned* x) {
	return __atomic_load_4(x, memory_order_seq_cst);
}
static inline void atomic_store_u32(unsigned* x, unsigned y) {
	__atomic_store_4(x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u32(unsigned* x, unsigned* expected, unsigned y) {
	return (int)__atomic_compare_exchange_4(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u32(unsigned* x, unsigned* expected, unsigned y) {
	return (int)__atomic_compare_exchange_4(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned atomic_exchange_u32(unsigned* x, unsigned y) {
	return __atomic_exchange_4(x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_add_u32(unsigned* x, unsigned y) {
	return __atomic_fetch_add_4(x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_sub_u32(unsigned* x, unsigned y) {
	return __atomic_fetch_sub_4(x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_and_u32(unsigned* x, unsigned y) {
	return __atomic_fetch_and_4(x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_or_u32(unsigned* x, unsigned y) {
	return __atomic_fetch_or_4(x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_xor_u32(unsigned* x, unsigned y) {
	return __atomic_fetch_xor_4(x, y, memory_order_seq_cst);
}

static inline unsigned short atomic_load_u16(unsigned short* x) {
	return __atomic_load_2(x, memory_order_seq_cst);
}
static inline void atomic_store_u16(void* x, unsigned short y) {
	__atomic_store_2(x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u16(void* x, unsigned short* expected, unsigned short y) {
	return (int)__atomic_compare_exchange_2(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u16(unsigned short* x, unsigned short* expected, unsigned short y) {
	return (int)__atomic_compare_exchange_2(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned short atomic_exchange_u16(unsigned short* x, unsigned short y) {
	return __atomic_exchange_2(x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_add_u16(unsigned short* x, unsigned short y) {
	return __atomic_fetch_add_2(x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_sub_u16(unsigned short* x, unsigned short y) {
	return __atomic_fetch_sub_2(x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_and_u16(unsigned short* x, unsigned short y) {
	return __atomic_fetch_and_2(x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_or_u16(unsigned short* x, unsigned short y) {
	return __atomic_fetch_or_2(x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_xor_u16(unsigned short* x, unsigned short y) {
	return __atomic_fetch_xor_2(x, y, memory_order_seq_cst);
}

static inline unsigned char atomic_load_byte(unsigned char* x) {
	return __atomic_load_1(x, memory_order_seq_cst);
}
static inline void atomic_store_byte(unsigned char* x, unsigned char y) {
	__atomic_store_1(x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_byte(unsigned char* x, unsigned char* expected, unsigned char y) {
	return __atomic_compare_exchange_1(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_byte(unsigned char* x, unsigned char* expected, unsigned char y) {
	return __atomic_compare_exchange_1(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned char atomic_exchange_byte(unsigned char* x, unsigned char y) {
	return __atomic_exchange_1(x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_add_byte(unsigned char* x, unsigned char y) {
	return __atomic_fetch_add_1(x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_sub_byte(unsigned char* x, unsigned char y) {
	return __atomic_fetch_sub_1(x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_and_byte(unsigned char* x, unsigned char y) {
	return __atomic_fetch_and_1(x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_or_byte(unsigned char* x, unsigned char y) {
	return __atomic_fetch_or_1(x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_xor_byte(unsigned char* x, unsigned char y) {
	return __atomic_fetch_xor_1(x, y, memory_order_seq_cst);
}

#else

// Since V might be confused with "generic" C functions either we provide special versions
// for gcc/clang, too
static inline unsigned long long atomic_load_u64(unsigned long long* x) {
	return atomic_load_explicit((_Atomic (unsigned long long)*)x, memory_order_seq_cst);
}
static inline void atomic_store_u64(unsigned long long* x, unsigned long long y) {
	atomic_store_explicit((_Atomic(unsigned long long)*)x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u64(unsigned long long* x, unsigned long long* expected, unsigned long long y) {
	return (int)atomic_compare_exchange_weak_explicit((_Atomic(unsigned long long)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u64(unsigned long long* x, unsigned long long* expected, unsigned long long y) {
	return (int)atomic_compare_exchange_strong_explicit((_Atomic(unsigned long long)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned long long atomic_exchange_u64(unsigned long long* x, unsigned long long y) {
	return atomic_exchange_explicit((_Atomic(unsigned long long)*)x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_add_u64(unsigned long long* x, unsigned long long y) {
	return atomic_fetch_add_explicit((_Atomic(unsigned long long)*)x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_sub_u64(unsigned long long* x, unsigned long long y) {
	return atomic_fetch_sub_explicit((_Atomic(unsigned long long)*)x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_and_u64(unsigned long long* x, unsigned long long y) {
	return atomic_fetch_and_explicit((_Atomic(unsigned long long)*)x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_or_u64(unsigned long long* x, unsigned long long y) {
	return atomic_fetch_or_explicit((_Atomic(unsigned long long)*)x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_xor_u64(unsigned long long* x, unsigned long long y) {
	return atomic_fetch_xor_explicit((_Atomic(unsigned long long)*)x, y, memory_order_seq_cst);
}


static inline void* atomic_load_ptr(void** x) {
	return (void*)atomic_load_explicit((_Atomic(uintptr_t)*)x, memory_order_seq_cst);
}
static inline void atomic_store_ptr(void** x, void* y) {
	atomic_store_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_ptr(void** x, void** expected, intptr_t y) {
	return (int)atomic_compare_exchange_weak_explicit((_Atomic(uintptr_t)*)x, (unsigned long *)expected, (uintptr_t)y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_ptr(void** x, void** expected, intptr_t y) {
	return (int)atomic_compare_exchange_strong_explicit((_Atomic(uintptr_t)*)x, (unsigned long *)expected, (uintptr_t)y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline void* atomic_exchange_ptr(void** x, void* y) {
	return (void*)atomic_exchange_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline void* atomic_fetch_add_ptr(void** x, void* y) {
	return (void*)atomic_fetch_add_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline void* atomic_fetch_sub_ptr(void** x, void* y) {
	return (void*)atomic_fetch_sub_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline void* atomic_fetch_and_ptr(void** x, void* y) {
	return (void*)atomic_fetch_and_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline void* atomic_fetch_or_ptr(void** x, void* y) {
	return (void*)atomic_fetch_or_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline void* atomic_fetch_xor_ptr(void** x, void* y) {
	return (void*)atomic_fetch_xor_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}


static inline unsigned atomic_load_u32(unsigned* x) {
	return atomic_load_explicit((_Atomic(unsigned)*)x, memory_order_seq_cst);
}
static inline void atomic_store_u32(unsigned* x, unsigned y) {
	atomic_store_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u32(unsigned* x, unsigned* expected, unsigned y) {
	return (int)atomic_compare_exchange_weak_explicit((_Atomic(unsigned)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u32(unsigned* x, unsigned* expected, unsigned y) {
	return (int)atomic_compare_exchange_strong_explicit((_Atomic(unsigned)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned atomic_exchange_u32(unsigned* x, unsigned y) {
	return atomic_exchange_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_add_u32(unsigned* x, unsigned y) {
	return atomic_fetch_add_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_sub_u32(unsigned* x, unsigned y) {
	return atomic_fetch_sub_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_and_u32(unsigned* x, unsigned y) {
	return atomic_fetch_and_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_or_u32(unsigned* x, unsigned y) {
	return atomic_fetch_or_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_xor_u32(unsigned* x, unsigned y) {
	return atomic_fetch_xor_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}

static inline unsigned short atomic_load_u16(unsigned short* x) {
	return atomic_load_explicit((_Atomic(unsigned short)*)x, memory_order_seq_cst);
}
static inline void atomic_store_u16(void* x, unsigned short y) {
	atomic_store_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u16(void* x, unsigned short* expected, unsigned short y) {
	return (int)atomic_compare_exchange_weak_explicit((_Atomic(unsigned short)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u16(unsigned short* x, unsigned short* expected, unsigned short y) {
	return (int)atomic_compare_exchange_strong_explicit((_Atomic(unsigned short)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned short atomic_exchange_u16(unsigned short* x, unsigned short y) {
	return atomic_exchange_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_add_u16(unsigned short* x, unsigned short y) {
	return atomic_fetch_add_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_sub_u16(unsigned short* x, unsigned short y) {
	return atomic_fetch_sub_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_and_u16(unsigned short* x, unsigned short y) {
	return atomic_fetch_and_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_or_u16(unsigned short* x, unsigned short y) {
	return atomic_fetch_or_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_xor_u16(unsigned short* x, unsigned short y) {
	return atomic_fetch_xor_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}

static inline unsigned char atomic_load_byte(unsigned char* x) {
	return atomic_load_explicit((_Atomic(unsigned char)*)x, memory_order_seq_cst);
}
static inline void atomic_store_byte(unsigned char* x, unsigned char y) {
	atomic_store_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_byte(unsigned char* x, unsigned char* expected, unsigned char y) {
	return (int)atomic_compare_exchange_weak_explicit((_Atomic(unsigned char)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_byte(unsigned char* x, unsigned char* expected, unsigned char y) {
	return (int)atomic_compare_exchange_strong_explicit((_Atomic(unsigned char)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned char atomic_exchange_byte(unsigned char* x, unsigned char y) {
	return atomic_exchange_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_add_byte(unsigned char* x, unsigned char y) {
	return atomic_fetch_add_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_sub_byte(unsigned char* x, unsigned char y) {
	return atomic_fetch_sub_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_and_byte(unsigned char* x, unsigned char y) {
	return atomic_fetch_and_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_or_byte(unsigned char* x, unsigned char y) {
	return atomic_fetch_or_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_xor_byte(unsigned char* x, unsigned char y) {
	return atomic_fetch_xor_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}

#endif
#endif


// added by module `os`, file: debugger_linux.c.v:3:

#if defined(__has_include)

#if __has_include(<sys/ptrace.h>)
#include <sys/ptrace.h>
#else
#error VERROR_MESSAGE Header file <sys/ptrace.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/ptrace.h>
#endif


// added by module `os`, file: fd.c.v:6:

#if defined(__has_include)

#if __has_include(<sys/select.h>)
#include <sys/select.h>
#else
#error VERROR_MESSAGE Header file <sys/select.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/select.h>
#endif


// added by module `os`, file: os.c.v:5:

#if defined(__has_include)

#if __has_include(<sys/stat.h>)
#include <sys/stat.h>
#else
#error VERROR_MESSAGE Header file <sys/stat.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/stat.h>
#endif


// added by module `os`, file: os.c.v:6:
#include <errno.h>

// added by module `os`, file: os_nix.c.v:5:

#if defined(__has_include)

#if __has_include(<dirent.h>)
#include <dirent.h>
#else
#error VERROR_MESSAGE Header file <dirent.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <dirent.h>
#endif


// added by module `os`, file: os_nix.c.v:6:

#if defined(__has_include)

#if __has_include(<unistd.h>)
#include <unistd.h>
#else
#error VERROR_MESSAGE Header file <unistd.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <unistd.h>
#endif


// added by module `os`, file: os_nix.c.v:7:

#if defined(__has_include)

#if __has_include(<fcntl.h>)
#include <fcntl.h>
#else
#error VERROR_MESSAGE Header file <fcntl.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <fcntl.h>
#endif


// added by module `os`, file: os_nix.c.v:8:

#if defined(__has_include)

#if __has_include(<sys/utsname.h>)
#include <sys/utsname.h>
#else
#error VERROR_MESSAGE Header file <sys/utsname.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/utsname.h>
#endif


// added by module `os`, file: os_nix.c.v:9:

#if defined(__has_include)

#if __has_include(<sys/types.h>)
#include <sys/types.h>
#else
#error VERROR_MESSAGE Header file <sys/types.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/types.h>
#endif


// added by module `os`, file: os_nix.c.v:10:

#if defined(__has_include)

#if __has_include(<sys/statvfs.h>)
#include <sys/statvfs.h>
#else
#error VERROR_MESSAGE Header file <sys/statvfs.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/statvfs.h>
#endif


// added by module `os`, file: os_nix.c.v:11:

#if defined(__has_include)

#if __has_include(<utime.h>)
#include <utime.h>
#else
#error VERROR_MESSAGE Header file <utime.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <utime.h>
#endif


// added by module `os`, file: signal.c.v:3:

#if defined(__has_include)

#if __has_include(<signal.h>)
#include <signal.h>
#else
#error VERROR_MESSAGE Header file <signal.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <signal.h>
#endif


// added by module `os`, file: signal_linux.c.v:5:

#if defined(__has_include)

#if __has_include(<signal.h>)
#include <signal.h>
#else
#error VERROR_MESSAGE Header file <signal.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <signal.h>
#endif


// added by module `db.sqlite`, file: sqlite.c.v:14:

#if defined(__has_include)

#if __has_include("sqlite3.h")
#include "sqlite3.h"
#else
#error VERROR_MESSAGE Header file "sqlite3.h", needed for module `db.sqlite` was not found. The SQLite header file is missing. Please install its development package first..
#endif

#else
#include "sqlite3.h"
#endif


// added by module `sync`, file: sync_default.c.v:14:

#if defined(__has_include)

#if __has_include(<semaphore.h>)
#include <semaphore.h>
#else
#error VERROR_MESSAGE Header file <semaphore.h>, needed for module `sync` was not found. Please install the corresponding development headers.
#endif

#else
#include <semaphore.h>
#endif


// added by module `net`, file: aasocket.c.v:19:

#if defined(__has_include)

#if __has_include(<sys/un.h>)
#include <sys/un.h>
#else
#error VERROR_MESSAGE Header file <sys/un.h>, needed for module `net` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/un.h>
#endif


// added by module `net`, file: net_nix.c.v:3:

#if defined(__has_include)

#if __has_include(<unistd.h>)
#include <unistd.h>
#else
#error VERROR_MESSAGE Header file <unistd.h>, needed for module `net` was not found. Please install the corresponding development headers.
#endif

#else
#include <unistd.h>
#endif


// added by module `net`, file: net_nix.c.v:4:

#if defined(__has_include)

#if __has_include(<sys/select.h>)
#include <sys/select.h>
#else
#error VERROR_MESSAGE Header file <sys/select.h>, needed for module `net` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/select.h>
#endif


// added by module `net`, file: net_nix.c.v:6:

#if defined(__has_include)

#if __has_include(<arpa/inet.h>)
#include <arpa/inet.h>
#else
#error VERROR_MESSAGE Header file <arpa/inet.h>, needed for module `net` was not found. Please install the corresponding development headers.
#endif

#else
#include <arpa/inet.h>
#endif


// added by module `net`, file: net_nix.c.v:7:

#if defined(__has_include)

#if __has_include(<netdb.h>)
#include <netdb.h>
#else
#error VERROR_MESSAGE Header file <netdb.h>, needed for module `net` was not found. Please install the corresponding development headers.
#endif

#else
#include <netdb.h>
#endif


// added by module `net`, file: net_nix.c.v:8:
#include <errno.h>

// added by module `net`, file: net_nix.c.v:9:

#if defined(__has_include)

#if __has_include(<fcntl.h>)
#include <fcntl.h>
#else
#error VERROR_MESSAGE Header file <fcntl.h>, needed for module `net` was not found. Please install the corresponding development headers.
#endif

#else
#include <fcntl.h>
#endif


// added by module `net`, file: net_nix.c.v:10:

#if defined(__has_include)

#if __has_include(<netinet/tcp.h>)
#include <netinet/tcp.h>
#else
#error VERROR_MESSAGE Header file <netinet/tcp.h>, needed for module `net` was not found. Please install the corresponding development headers.
#endif

#else
#include <netinet/tcp.h>
#endif


// added by module `picoev`, file: loop_linux.c.v:3:

#if defined(__has_include)

#if __has_include(<sys/epoll.h>)
#include <sys/epoll.h>
#else
#error VERROR_MESSAGE Header file <sys/epoll.h>, needed for module `picoev` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/epoll.h>
#endif


// added by module `picoev`, file: loop_linux.c.v:6:

#if defined(__has_include)

#if __has_include(<sys/cdefs.h>)
#include <sys/cdefs.h>
#else
#error VERROR_MESSAGE Header file <sys/cdefs.h>, needed for module `picoev` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/cdefs.h>
#endif


// added by module `picoev`, file: socket_util.c.v:6:
#include <errno.h>

// added by module `picoev`, file: socket_util.c.v:16:

#if defined(__has_include)

#if __has_include(<netinet/tcp.h>)
#include <netinet/tcp.h>
#else
#error VERROR_MESSAGE Header file <netinet/tcp.h>, needed for module `picoev` was not found. Please install the corresponding development headers.
#endif

#else
#include <netinet/tcp.h>
#endif


// added by module `picoev`, file: socket_util.c.v:17:

#if defined(__has_include)

#if __has_include(<sys/resource.h>)
#include <sys/resource.h>
#else
#error VERROR_MESSAGE Header file <sys/resource.h>, needed for module `picoev` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/resource.h>
#endif


// added by module `net.mbedtls`, file: mbedtls.c.v:120:

#if defined(__has_include)

#if __has_include(<mbedtls/net_sockets.h>)
#include <mbedtls/net_sockets.h>
#else
#error VERROR_MESSAGE Header file <mbedtls/net_sockets.h>, needed for module `net.mbedtls` was not found. Please install the corresponding development headers.
#endif

#else
#include <mbedtls/net_sockets.h>
#endif


// added by module `net.mbedtls`, file: mbedtls.c.v:121:

#if defined(__has_include)

#if __has_include(<mbedtls/ssl.h>)
#include <mbedtls/ssl.h>
#else
#error VERROR_MESSAGE Header file <mbedtls/ssl.h>, needed for module `net.mbedtls` was not found. Please install the corresponding development headers.
#endif

#else
#include <mbedtls/ssl.h>
#endif


// added by module `net.mbedtls`, file: mbedtls.c.v:122:

#if defined(__has_include)

#if __has_include(<mbedtls/entropy.h>)
#include <mbedtls/entropy.h>
#else
#error VERROR_MESSAGE Header file <mbedtls/entropy.h>, needed for module `net.mbedtls` was not found. Please install the corresponding development headers.
#endif

#else
#include <mbedtls/entropy.h>
#endif


// added by module `net.mbedtls`, file: mbedtls.c.v:123:

#if defined(__has_include)

#if __has_include(<mbedtls/ctr_drbg.h>)
#include <mbedtls/ctr_drbg.h>
#else
#error VERROR_MESSAGE Header file <mbedtls/ctr_drbg.h>, needed for module `net.mbedtls` was not found. Please install the corresponding development headers.
#endif

#else
#include <mbedtls/ctr_drbg.h>
#endif


// added by module `net.mbedtls`, file: mbedtls.c.v:124:

#if defined(__has_include)

#if __has_include(<mbedtls/error.h>)
#include <mbedtls/error.h>
#else
#error VERROR_MESSAGE Header file <mbedtls/error.h>, needed for module `net.mbedtls` was not found. Please install the corresponding development headers.
#endif

#else
#include <mbedtls/error.h>
#endif


// added by module `veb`, file: sendfile_linux.c.v:3:

#if defined(__has_include)

#if __has_include(<sys/sendfile.h>)
#include <sys/sendfile.h>
#else
#error VERROR_MESSAGE Header file <sys/sendfile.h>, needed for module `veb` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/sendfile.h>
#endif


// V global/const #define ... :
#define _const_strconv__int_size 32
#define _const_strconv__max_size_f64_char 512
#define _const_max_int 2147483647
#define _const_hashbits 24
#define _const_max_cached_hashbits 16
#define _const_init_log_capicity 5
#define _const_init_capicity 32
#define _const_init_even_index 30
#define _const_extra_metas_inc 4
#define _const_rune_maps_columns_in_row 4
#define _const_rune_maps_ul -3
#define _const_rune_maps_utl -2
#define _const_replace_stack_buffer_size 10
#define _const_kmp_stack_buffer_size 20
#define _const_time__seconds_per_minute 60
#define _const_time__seconds_per_hour 3600
#define _const_time__seconds_per_day 86400
#define _const_orm__serial -1
#define _const_orm__time_ -2
#define _const_orm__enum_ -3
#define _const_os__max_path_buffer_size 4096
#define _const_os__buf_size 4096
#define _const_os__error_code_not_set 2130640638
#define _const_os__max_path_len 4096
#define _const_os__f_ok 0
#define _const_crypto__sha256__size 32
#define _const_crypto__sha256__size224 28
#define _const_crypto__sha256__block_size 64
#define _const_crypto__sha256__chunk 64
#define _const_db__sqlite__sqlite_ok 0
#define _const_db__sqlite__sqlite_row 100
#define _const_db__sqlite__sqlite_done 101
#define _const_sync__spinloops 750
#define _const_sync__spinloops_sem 4000
#define _const_net__max_ip_len 24
#define _const_net__max_ip6_len 46
#define _const_net__max_unix_path 108
#define _const_net__msg_nosignal 16384
#define _const_picoev__max_queue 4096
#define _const_picoev__picoev_read 1
#define _const_picoev__picoev_write 2
#define _const_picoev__picoev_timeout 4
#define _const_picoev__picoev_del 536870912
#define _const_picoev__max_fds 1024
#define _const_net__http__default_server_port 9009
#define _const_veb__max_read 8096
#define _const_veb__max_write 16192

// Enum definitions:

typedef enum {
	strconv__ParserState__ok, // 
	strconv__ParserState__pzero, // +1
	strconv__ParserState__mzero, // +2
	strconv__ParserState__pinf, // +3
	strconv__ParserState__minf, // +4
	strconv__ParserState__invalid_number, // +5
	strconv__ParserState__extra_char, // +6
}  strconv__ParserState;

typedef enum {
	strconv__Align_text__right = 0, // 0
	strconv__Align_text__left, // 0+1
	strconv__Align_text__center, // 0+2
}  strconv__Align_text;

typedef enum {
	strconv__Char_parse_state__start, // 
	strconv__Char_parse_state__norm_char, // +1
	strconv__Char_parse_state__field_char, // +2
	strconv__Char_parse_state__pad_ch, // +3
	strconv__Char_parse_state__len_set_start, // +4
	strconv__Char_parse_state__len_set_in, // +5
	strconv__Char_parse_state__check_type, // +6
	strconv__Char_parse_state__check_float, // +7
	strconv__Char_parse_state__check_float_in, // +8
	strconv__Char_parse_state__reset_params, // +9
}  strconv__Char_parse_state;

typedef enum {
	ArrayFlags__noslices = 1U, // u64(1) << 0
	ArrayFlags__noshrink = 2U, // u64(1) << 1
	ArrayFlags__nogrow = 4U, // u64(1) << 2
	ArrayFlags__nofree = 8U, // u64(1) << 3
}  ArrayFlags;

typedef enum {
	AttributeKind__plain, // 
	AttributeKind__string, // +1
	AttributeKind__number, // +2
	AttributeKind__bool, // +3
	AttributeKind__comptime_define, // +4
}  AttributeKind;

typedef enum {
	ChanState__success, // 
	ChanState__not_ready, // +1
	ChanState__closed, // +2
}  ChanState;

typedef enum {
	MapMode__to_upper, // 
	MapMode__to_lower, // +1
	MapMode__to_title, // +2
}  MapMode;

typedef enum {
	TrimMode__trim_left, // 
	TrimMode__trim_right, // +1
	TrimMode__trim_both, // +2
}  TrimMode;

typedef enum {
	StrIntpType__si_no_str = 0, // 0
	StrIntpType__si_c, // 0+1
	StrIntpType__si_u8, // 0+2
	StrIntpType__si_i8, // 0+3
	StrIntpType__si_u16, // 0+4
	StrIntpType__si_i16, // 0+5
	StrIntpType__si_u32, // 0+6
	StrIntpType__si_i32, // 0+7
	StrIntpType__si_u64, // 0+8
	StrIntpType__si_i64, // 0+9
	StrIntpType__si_e32, // 0+10
	StrIntpType__si_e64, // 0+11
	StrIntpType__si_f32, // 0+12
	StrIntpType__si_f64, // 0+13
	StrIntpType__si_g32, // 0+14
	StrIntpType__si_g64, // 0+15
	StrIntpType__si_s, // 0+16
	StrIntpType__si_p, // 0+17
	StrIntpType__si_r, // 0+18
	StrIntpType__si_vp, // 0+19
}  StrIntpType;

typedef enum {
	time__FormatTime__hhmm12, // 
	time__FormatTime__hhmm24, // +1
	time__FormatTime__hhmmss12, // +2
	time__FormatTime__hhmmss24, // +3
	time__FormatTime__hhmmss24_milli, // +4
	time__FormatTime__hhmmss24_micro, // +5
	time__FormatTime__hhmmss24_nano, // +6
	time__FormatTime__no_time, // +7
}  time__FormatTime;

typedef enum {
	time__FormatDate__ddmmyy, // 
	time__FormatDate__ddmmyyyy, // +1
	time__FormatDate__mmddyy, // +2
	time__FormatDate__mmddyyyy, // +3
	time__FormatDate__mmmd, // +4
	time__FormatDate__mmmdd, // +5
	time__FormatDate__mmmddyy, // +6
	time__FormatDate__mmmddyyyy, // +7
	time__FormatDate__no_date, // +8
	time__FormatDate__yyyymmdd, // +9
	time__FormatDate__yymmdd, // +10
}  time__FormatDate;

typedef enum {
	time__FormatDelimiter__dot, // 
	time__FormatDelimiter__hyphen, // +1
	time__FormatDelimiter__slash, // +2
	time__FormatDelimiter__space, // +3
	time__FormatDelimiter__no_delimiter, // +4
}  time__FormatDelimiter;

typedef enum {
	net__urllib__EncodingMode__encode_path, // 
	net__urllib__EncodingMode__encode_path_segment, // +1
	net__urllib__EncodingMode__encode_host, // +2
	net__urllib__EncodingMode__encode_zone, // +3
	net__urllib__EncodingMode__encode_user_password, // +4
	net__urllib__EncodingMode__encode_query_component, // +5
	net__urllib__EncodingMode__encode_fragment, // +6
}  net__urllib__EncodingMode;

typedef enum {
	orm__OperationKind__neq, // 
	orm__OperationKind__eq, // +1
	orm__OperationKind__gt, // +2
	orm__OperationKind__lt, // +3
	orm__OperationKind__ge, // +4
	orm__OperationKind__le, // +5
	orm__OperationKind__orm_like, // +6
	orm__OperationKind__orm_ilike, // +7
	orm__OperationKind__is_null, // +8
	orm__OperationKind__is_not_null, // +9
}  orm__OperationKind;

typedef enum {
	orm__MathOperationKind__add, // 
	orm__MathOperationKind__sub, // +1
	orm__MathOperationKind__mul, // +2
	orm__MathOperationKind__div, // +3
}  orm__MathOperationKind;

typedef enum {
	orm__StmtKind__insert, // 
	orm__StmtKind__update, // +1
	orm__StmtKind__delete, // +2
}  orm__StmtKind;

typedef enum {
	orm__OrderType__asc, // 
	orm__OrderType__desc, // +1
}  orm__OrderType;

typedef enum {
	orm__SQLDialect__default, // 
	orm__SQLDialect__sqlite, // +1
}  orm__SQLDialect;

typedef enum {
	os__SeekMode__start, // 
	os__SeekMode__current, // +1
	os__SeekMode__end, // +2
}  os__SeekMode;

typedef enum {
	os__FileBufferMode__fully_buffered = _IOFBF, // _IOFBF
	os__FileBufferMode__line_buffered = _IOLBF, // _IOLBF
	os__FileBufferMode__not_buffered = _IONBF, // _IONBF
}  os__FileBufferMode;

typedef enum {
	os__FileType__unknown, // 
	os__FileType__regular, // +1
	os__FileType__directory, // +2
	os__FileType__character_device, // +3
	os__FileType__block_device, // +4
	os__FileType__fifo, // +5
	os__FileType__symbolic_link, // +6
	os__FileType__socket, // +7
}  os__FileType;

typedef enum {
	os__GlobMatch__exact, // 
	os__GlobMatch__ends_with, // +1
	os__GlobMatch__starts_with, // +2
	os__GlobMatch__start_and_ends_with, // +3
	os__GlobMatch__contains, // +4
	os__GlobMatch__any, // +5
}  os__GlobMatch;

typedef enum {
	os__ChildProcessPipeKind__stdin, // 
	os__ChildProcessPipeKind__stdout, // +1
	os__ChildProcessPipeKind__stderr, // +2
}  os__ChildProcessPipeKind;

typedef enum {
	os__ProcessState__not_started, // 
	os__ProcessState__running, // +1
	os__ProcessState__stopped, // +2
	os__ProcessState__exited, // +3
	os__ProcessState__aborted, // +4
	os__ProcessState__closed, // +5
}  os__ProcessState;

typedef enum {
	os__Signal__hup = 1, // 1
	os__Signal__int = 2, // 2
	os__Signal__quit = 3, // 3
	os__Signal__ill = 4, // 4
	os__Signal__trap = 5, // 5
	os__Signal__abrt = 6, // 6
	os__Signal__bus = 7, // 7
	os__Signal__fpe = 8, // 8
	os__Signal__kill = 9, // 9
	os__Signal__usr1 = 10, // 10
	os__Signal__segv = 11, // 11
	os__Signal__usr2 = 12, // 12
	os__Signal__pipe = 13, // 13
	os__Signal__alrm = 14, // 14
	os__Signal__term = 15, // 15
	os__Signal__stkflt = 16, // 16
	os__Signal__chld = 17, // 17
	os__Signal__cont = 18, // 18
	os__Signal__stop = 19, // 19
	os__Signal__tstp = 20, // 20
	os__Signal__ttin = 21, // 21
	os__Signal__ttou = 22, // 22
	os__Signal__urg = 23, // 23
	os__Signal__xcpu = 24, // 24
	os__Signal__xfsz = 25, // 25
	os__Signal__vtalrm = 26, // 26
	os__Signal__prof = 27, // 27
	os__Signal__winch = 28, // 28
	os__Signal__poll = 29, // 29
	os__Signal__pwr = 30, // 30
	os__Signal__sys = 31, // 31
}  os__Signal;

typedef enum {
	compress__gzip__CompressFlags__compression_level_overwrite_flag01 = 1U, // u64(1) << 0
	compress__gzip__CompressFlags__compression_level_overwrite_flag02 = 2U, // u64(1) << 1
	compress__gzip__CompressFlags__compression_level_overwrite_flag03 = 4U, // u64(1) << 2
	compress__gzip__CompressFlags__compression_level_overwrite_flag04 = 8U, // u64(1) << 3
	compress__gzip__CompressFlags__compression_level_overwrite_flag05 = 16U, // u64(1) << 4
	compress__gzip__CompressFlags__compression_level_overwrite_flag06 = 32U, // u64(1) << 5
	compress__gzip__CompressFlags__compression_level_overwrite_flag07 = 64U, // u64(1) << 6
	compress__gzip__CompressFlags__compression_level_overwrite_flag08 = 128U, // u64(1) << 7
	compress__gzip__CompressFlags__compression_level_overwrite_flag09 = 256U, // u64(1) << 8
	compress__gzip__CompressFlags__compression_level_overwrite_flag10 = 512U, // u64(1) << 9
	compress__gzip__CompressFlags__compression_level_overwrite_flag11 = 1024U, // u64(1) << 10
	compress__gzip__CompressFlags__compression_level_overwrite_flag12 = 2048U, // u64(1) << 11
	compress__gzip__CompressFlags__write_zlib_header = 4096U, // u64(1) << 12
	compress__gzip__CompressFlags__compute_adler32 = 8192U, // u64(1) << 13
	compress__gzip__CompressFlags__greedy_parsing_flag = 16384U, // u64(1) << 14
	compress__gzip__CompressFlags__nondeterministic_parsing_flag = 32768U, // u64(1) << 15
	compress__gzip__CompressFlags__rle_matches = 65536U, // u64(1) << 16
	compress__gzip__CompressFlags__filter_matches = 131072U, // u64(1) << 17
	compress__gzip__CompressFlags__force_all_static_blocks = 262144U, // u64(1) << 18
	compress__gzip__CompressFlags__force_all_raw_blocks = 524288U, // u64(1) << 19
}  compress__gzip__CompressFlags;

typedef enum {
	compress__gzip__DecompressFlags__parse_zlib_header = 1U, // u64(1) << 0
	compress__gzip__DecompressFlags__has_more_input = 2U, // u64(1) << 1
	compress__gzip__DecompressFlags__using_non_wrapping_output_buf = 4U, // u64(1) << 2
	compress__gzip__DecompressFlags__compute_adler32 = 8U, // u64(1) << 3
}  compress__gzip__DecompressFlags;

typedef enum {
	db__sqlite__Result__ok = 0, // 0
	db__sqlite__Result__error = 1, // 1
	db__sqlite__Result__internal = 2, // 2
	db__sqlite__Result__perm = 3, // 3
	db__sqlite__Result__abort = 4, // 4
	db__sqlite__Result__busy = 5, // 5
	db__sqlite__Result__locked = 6, // 6
	db__sqlite__Result__nomem = 7, // 7
	db__sqlite__Result__readonly = 8, // 8
	db__sqlite__Result__interrupt = 9, // 9
	db__sqlite__Result__ioerr = 10, // 10
	db__sqlite__Result__corrupt = 11, // 11
	db__sqlite__Result__notfound = 12, // 12
	db__sqlite__Result__full = 13, // 13
	db__sqlite__Result__cantopen = 14, // 14
	db__sqlite__Result__protocol = 15, // 15
	db__sqlite__Result__empty = 16, // 16
	db__sqlite__Result__schema = 17, // 17
	db__sqlite__Result__toobig = 18, // 18
	db__sqlite__Result__constraint = 19, // 19
	db__sqlite__Result__mismatch = 20, // 20
	db__sqlite__Result__misuse = 21, // 21
	db__sqlite__Result__nolfs = 22, // 22
	db__sqlite__Result__auth = 23, // 23
	db__sqlite__Result__format = 24, // 24
	db__sqlite__Result__range = 25, // 25
	db__sqlite__Result__notadb = 26, // 26
	db__sqlite__Result__notice = 27, // 27
	db__sqlite__Result__warning = 28, // 28
	db__sqlite__Result__row = 100, // 100
	db__sqlite__Result__done = 101, // 101
	db__sqlite__Result__ok_load_permanently = 256, // 256
	db__sqlite__Result__error_missing_collseq = 257, // 257
	db__sqlite__Result__busy_recovery = 261, // 261
	db__sqlite__Result__locked_sharedcache = 262, // 262
	db__sqlite__Result__readonly_recovery = 264, // 264
	db__sqlite__Result__ioerr_read = 266, // 266
	db__sqlite__Result__corrupt_vtab = 267, // 267
	db__sqlite__Result__cantopen_notempdir = 270, // 270
	db__sqlite__Result__constraint_check = 275, // 275
	db__sqlite__Result__notice_recover_wal = 283, // 283
	db__sqlite__Result__warning_autoindex = 284, // 284
	db__sqlite__Result__error_retry = 513, // 513
	db__sqlite__Result__abort_rollback = 516, // 516
	db__sqlite__Result__busy_snapshot = 517, // 517
	db__sqlite__Result__locked_vtab = 518, // 518
	db__sqlite__Result__readonly_cantlock = 520, // 520
	db__sqlite__Result__ioerr_short_read = 522, // 522
	db__sqlite__Result__corrupt_sequence = 523, // 523
	db__sqlite__Result__cantopen_isdir = 526, // 526
	db__sqlite__Result__constraint_commithook = 531, // 531
	db__sqlite__Result__notice_recover_rollback = 539, // 539
	db__sqlite__Result__error_snapshot = 769, // 769
	db__sqlite__Result__busy_timeout = 773, // 773
	db__sqlite__Result__readonly_rollback = 776, // 776
	db__sqlite__Result__ioerr_write = 778, // 778
	db__sqlite__Result__corrupt_index = 779, // 779
	db__sqlite__Result__cantopen_fullpath = 782, // 782
	db__sqlite__Result__constraint_foreignkey = 787, // 787
	db__sqlite__Result__readonly_dbmoved = 1032, // 1032
	db__sqlite__Result__ioerr_fsync = 1034, // 1034
	db__sqlite__Result__cantopen_convpath = 1038, // 1038
	db__sqlite__Result__constraint_function = 1043, // 1043
	db__sqlite__Result__readonly_cantinit = 1288, // 1288
	db__sqlite__Result__ioerr_dir_fsync = 1290, // 1290
	db__sqlite__Result__cantopen_dirtywal = 1294, // 1294
	db__sqlite__Result__constraint_notnull = 1299, // 1299
	db__sqlite__Result__readonly_directory = 1544, // 1544
	db__sqlite__Result__ioerr_truncate = 1546, // 1546
	db__sqlite__Result__cantopen_symlink = 1550, // 1550
	db__sqlite__Result__constraint_primarykey = 1555, // 1555
	db__sqlite__Result__ioerr_fstat = 1802, // 1802
	db__sqlite__Result__constraint_trigger = 1811, // 1811
	db__sqlite__Result__ioerr_unlock = 2058, // 2058
	db__sqlite__Result__constraint_unique = 2067, // 2067
	db__sqlite__Result__ioerr_rdlock = 2314, // 2314
	db__sqlite__Result__constraint_vtab = 2323, // 2323
	db__sqlite__Result__ioerr_delete = 2570, // 2570
	db__sqlite__Result__constraint_rowid = 2579, // 2579
	db__sqlite__Result__ioerr_blocked = 2826, // 2826
	db__sqlite__Result__constraint_pinned = 2835, // 2835
	db__sqlite__Result__ioerr_nomem = 3082, // 3082
	db__sqlite__Result__ioerr_access = 3338, // 3338
	db__sqlite__Result__ioerr_checkreservedlock = 3594, // 3594
	db__sqlite__Result__ioerr_lock = 3850, // 3850
	db__sqlite__Result__ioerr_close = 4106, // 4106
	db__sqlite__Result__ioerr_dir_close = 4362, // 4362
	db__sqlite__Result__ioerr_shmopen = 4618, // 4618
	db__sqlite__Result__ioerr_shmsize = 4874, // 4874
	db__sqlite__Result__ioerr_shmlock = 5130, // 5130
	db__sqlite__Result__ioerr_shmmap = 5386, // 5386
	db__sqlite__Result__ioerr_seek = 5642, // 5642
	db__sqlite__Result__ioerr_delete_noent = 5898, // 5898
	db__sqlite__Result__ioerr_mmap = 6154, // 6154
	db__sqlite__Result__ioerr_gettemppath = 6410, // 6410
	db__sqlite__Result__ioerr_convpath = 6666, // 6666
	db__sqlite__Result__ioerr_vnode = 6922, // 6922
	db__sqlite__Result__ioerr_auth = 7178, // 7178
	db__sqlite__Result__ioerr_begin_atomic = 7434, // 7434
	db__sqlite__Result__ioerr_commit_atomic = 7690, // 7690
	db__sqlite__Result__ioerr_rollback_atomic = 7946, // 7946
	db__sqlite__Result__ioerr_data = 8202, // 8202
}  db__sqlite__Result;

typedef enum {
	db__sqlite__SyncMode__off, // 
	db__sqlite__SyncMode__normal, // +1
	db__sqlite__SyncMode__full, // +2
}  db__sqlite__SyncMode;

typedef enum {
	db__sqlite__JournalMode__off, // 
	db__sqlite__JournalMode__delete, // +1
	db__sqlite__JournalMode__truncate, // +2
	db__sqlite__JournalMode__persist, // +3
	db__sqlite__JournalMode__memory, // +4
}  db__sqlite__JournalMode;

typedef enum {
	db__sqlite__OpenModeFlag__readonly = 0x00000001, // 0x00000001
	db__sqlite__OpenModeFlag__readwrite = 0x00000002, // 0x00000002
	db__sqlite__OpenModeFlag__create = 0x00000004, // 0x00000004
	db__sqlite__OpenModeFlag__uri = 0x00000040, // 0x00000040
	db__sqlite__OpenModeFlag__memory = 0x00000080, // 0x00000080
	db__sqlite__OpenModeFlag__nomutex = 0x00008000, // 0x00008000
	db__sqlite__OpenModeFlag__fullmutex = 0x00010000, // 0x00010000
	db__sqlite__OpenModeFlag__sharedcache = 0x00020000, // 0x00020000
	db__sqlite__OpenModeFlag__privatecache = 0x00040000, // 0x00040000
	db__sqlite__OpenModeFlag__exrescode = 0x02000000, // 0x02000000
	db__sqlite__OpenModeFlag__nofollow = 0x01000000, // 0x01000000
}  db__sqlite__OpenModeFlag;

typedef enum {
	sync__BufferElemStat__unused = 0, // 0
	sync__BufferElemStat__writing, // 0+1
	sync__BufferElemStat__written, // 0+2
	sync__BufferElemStat__reading, // 0+3
}  sync__BufferElemStat;

typedef enum {
	sync__Direction__pop, // 
	sync__Direction__push, // +1
}  sync__Direction;

typedef enum {
	net__Select__read, // 
	net__Select__write, // +1
	net__Select__except, // +2
}  net__Select;

typedef enum {
	net__SocketType__udp = SOCK_DGRAM, // SOCK_DGRAM
	net__SocketType__tcp = SOCK_STREAM, // SOCK_STREAM
	net__SocketType__seqpacket = SOCK_SEQPACKET, // SOCK_SEQPACKET
}  net__SocketType;

typedef enum {
	net__AddrFamily__unix = AF_UNIX, // AF_UNIX
	net__AddrFamily__ip = AF_INET, // AF_INET
	net__AddrFamily__ip6 = AF_INET6, // AF_INET6
	net__AddrFamily__unspec = AF_UNSPEC, // AF_UNSPEC
}  net__AddrFamily;

typedef enum {
	net__ShutdownDirection__read, // 
	net__ShutdownDirection__write, // +1
	net__ShutdownDirection__read_and_write, // +2
}  net__ShutdownDirection;

typedef enum {
	net__SocketOption__broadcast = SO_BROADCAST, // SO_BROADCAST
	net__SocketOption__debug = SO_DEBUG, // SO_DEBUG
	net__SocketOption__dont_route = SO_DONTROUTE, // SO_DONTROUTE
	net__SocketOption__error = SO_ERROR, // SO_ERROR
	net__SocketOption__keep_alive = SO_KEEPALIVE, // SO_KEEPALIVE
	net__SocketOption__linger = SO_LINGER, // SO_LINGER
	net__SocketOption__oob_inline = SO_OOBINLINE, // SO_OOBINLINE
	net__SocketOption__reuse_addr = SO_REUSEADDR, // SO_REUSEADDR
	net__SocketOption__receive_buf_size = SO_RCVBUF, // SO_RCVBUF
	net__SocketOption__receive_low_size = SO_RCVLOWAT, // SO_RCVLOWAT
	net__SocketOption__receive_timeout = SO_RCVTIMEO, // SO_RCVTIMEO
	net__SocketOption__send_buf_size = SO_SNDBUF, // SO_SNDBUF
	net__SocketOption__send_low_size = SO_SNDLOWAT, // SO_SNDLOWAT
	net__SocketOption__send_timeout = SO_SNDTIMEO, // SO_SNDTIMEO
	net__SocketOption__socket_type = SO_TYPE, // SO_TYPE
	net__SocketOption__ipv6_only = IPV6_V6ONLY, // IPV6_V6ONLY
	net__SocketOption__ip_proto_ipv6 = IPPROTO_IPV6, // IPPROTO_IPV6
}  net__SocketOption;

typedef enum {
	net__mbedtls__Select__read, // 
	net__mbedtls__Select__write, // +1
	net__mbedtls__Select__except, // +2
}  net__mbedtls__Select;

typedef enum {
	net__http__SameSite__same_site_not_set, // 
	net__http__SameSite__same_site_default_mode = 1, // 1
	net__http__SameSite__same_site_lax_mode, // 1+1
	net__http__SameSite__same_site_strict_mode, // 1+2
	net__http__SameSite__same_site_none_mode, // 1+3
}  net__http__SameSite;

typedef enum {
	net__http__CommonHeader__accept, // 
	net__http__CommonHeader__accept_ch, // +1
	net__http__CommonHeader__accept_charset, // +2
	net__http__CommonHeader__accept_ch_lifetime, // +3
	net__http__CommonHeader__accept_encoding, // +4
	net__http__CommonHeader__accept_language, // +5
	net__http__CommonHeader__accept_patch, // +6
	net__http__CommonHeader__accept_post, // +7
	net__http__CommonHeader__accept_ranges, // +8
	net__http__CommonHeader__access_control_allow_credentials, // +9
	net__http__CommonHeader__access_control_allow_headers, // +10
	net__http__CommonHeader__access_control_allow_methods, // +11
	net__http__CommonHeader__access_control_allow_origin, // +12
	net__http__CommonHeader__access_control_expose_headers, // +13
	net__http__CommonHeader__access_control_max_age, // +14
	net__http__CommonHeader__access_control_request_headers, // +15
	net__http__CommonHeader__access_control_request_method, // +16
	net__http__CommonHeader__age, // +17
	net__http__CommonHeader__allow, // +18
	net__http__CommonHeader__alt_svc, // +19
	net__http__CommonHeader__authorization, // +20
	net__http__CommonHeader__authority, // +21
	net__http__CommonHeader__cache_control, // +22
	net__http__CommonHeader__clear_site_data, // +23
	net__http__CommonHeader__connection, // +24
	net__http__CommonHeader__content_disposition, // +25
	net__http__CommonHeader__content_encoding, // +26
	net__http__CommonHeader__content_language, // +27
	net__http__CommonHeader__content_length, // +28
	net__http__CommonHeader__content_location, // +29
	net__http__CommonHeader__content_range, // +30
	net__http__CommonHeader__content_security_policy, // +31
	net__http__CommonHeader__content_security_policy_report_only, // +32
	net__http__CommonHeader__content_type, // +33
	net__http__CommonHeader__cookie, // +34
	net__http__CommonHeader__cross_origin_embedder_policy, // +35
	net__http__CommonHeader__cross_origin_opener_policy, // +36
	net__http__CommonHeader__cross_origin_resource_policy, // +37
	net__http__CommonHeader__date, // +38
	net__http__CommonHeader__device_memory, // +39
	net__http__CommonHeader__digest, // +40
	net__http__CommonHeader__dnt, // +41
	net__http__CommonHeader__early_data, // +42
	net__http__CommonHeader__etag, // +43
	net__http__CommonHeader__expect, // +44
	net__http__CommonHeader__expect_ct, // +45
	net__http__CommonHeader__expires, // +46
	net__http__CommonHeader__feature_policy, // +47
	net__http__CommonHeader__forwarded, // +48
	net__http__CommonHeader__from, // +49
	net__http__CommonHeader__host, // +50
	net__http__CommonHeader__if_match, // +51
	net__http__CommonHeader__if_modified_since, // +52
	net__http__CommonHeader__if_none_match, // +53
	net__http__CommonHeader__if_range, // +54
	net__http__CommonHeader__if_unmodified_since, // +55
	net__http__CommonHeader__index, // +56
	net__http__CommonHeader__keep_alive, // +57
	net__http__CommonHeader__large_allocation, // +58
	net__http__CommonHeader__last_modified, // +59
	net__http__CommonHeader__link, // +60
	net__http__CommonHeader__location, // +61
	net__http__CommonHeader__nel, // +62
	net__http__CommonHeader__origin, // +63
	net__http__CommonHeader__pragma, // +64
	net__http__CommonHeader__proxy_authenticate, // +65
	net__http__CommonHeader__proxy_authorization, // +66
	net__http__CommonHeader__range, // +67
	net__http__CommonHeader__referer, // +68
	net__http__CommonHeader__referrer_policy, // +69
	net__http__CommonHeader__retry_after, // +70
	net__http__CommonHeader__save_data, // +71
	net__http__CommonHeader__sec_fetch_dest, // +72
	net__http__CommonHeader__sec_fetch_mode, // +73
	net__http__CommonHeader__sec_fetch_site, // +74
	net__http__CommonHeader__sec_fetch_user, // +75
	net__http__CommonHeader__sec_websocket_accept, // +76
	net__http__CommonHeader__sec_websocket_key, // +77
	net__http__CommonHeader__server, // +78
	net__http__CommonHeader__server_timing, // +79
	net__http__CommonHeader__set_cookie, // +80
	net__http__CommonHeader__sourcemap, // +81
	net__http__CommonHeader__strict_transport_security, // +82
	net__http__CommonHeader__te, // +83
	net__http__CommonHeader__timing_allow_origin, // +84
	net__http__CommonHeader__tk, // +85
	net__http__CommonHeader__trailer, // +86
	net__http__CommonHeader__transfer_encoding, // +87
	net__http__CommonHeader__upgrade, // +88
	net__http__CommonHeader__upgrade_insecure_requests, // +89
	net__http__CommonHeader__user_agent, // +90
	net__http__CommonHeader__vary, // +91
	net__http__CommonHeader__via, // +92
	net__http__CommonHeader__want_digest, // +93
	net__http__CommonHeader__warning, // +94
	net__http__CommonHeader__www_authenticate, // +95
	net__http__CommonHeader__x_content_type_options, // +96
	net__http__CommonHeader__x_dns_prefetch_control, // +97
	net__http__CommonHeader__x_forwarded_for, // +98
	net__http__CommonHeader__x_forwarded_host, // +99
	net__http__CommonHeader__x_forwarded_proto, // +100
	net__http__CommonHeader__x_frame_options, // +101
	net__http__CommonHeader__x_xss_protection, // +102
}  net__http__CommonHeader;

typedef enum {
	net__http__Method__get, // 
	net__http__Method__head, // +1
	net__http__Method__post, // +2
	net__http__Method__put, // +3
	net__http__Method__acl, // +4
	net__http__Method__baseline_control, // +5
	net__http__Method__bind, // +6
	net__http__Method__checkin, // +7
	net__http__Method__checkout, // +8
	net__http__Method__connect, // +9
	net__http__Method__copy, // +10
	net__http__Method__delete, // +11
	net__http__Method__label, // +12
	net__http__Method__link, // +13
	net__http__Method__lock, // +14
	net__http__Method__merge, // +15
	net__http__Method__mkactivity, // +16
	net__http__Method__mkcalendar, // +17
	net__http__Method__mkcol, // +18
	net__http__Method__mkredirectref, // +19
	net__http__Method__mkworkspace, // +20
	net__http__Method__move, // +21
	net__http__Method__options, // +22
	net__http__Method__orderpatch, // +23
	net__http__Method__patch, // +24
	net__http__Method__pri, // +25
	net__http__Method__propfind, // +26
	net__http__Method__proppatch, // +27
	net__http__Method__rebind, // +28
	net__http__Method__report, // +29
	net__http__Method__search, // +30
	net__http__Method__trace, // +31
	net__http__Method__unbind, // +32
	net__http__Method__uncheckout, // +33
	net__http__Method__unlink, // +34
	net__http__Method__unlock, // +35
	net__http__Method__update, // +36
	net__http__Method__updateredirectref, // +37
	net__http__Method__version_control, // +38
}  net__http__Method;

typedef enum {
	net__http__ServerStatus__closed, // 
	net__http__ServerStatus__running, // +1
	net__http__ServerStatus__stopped, // +2
}  net__http__ServerStatus;

typedef enum {
	net__http__Status__unknown = -1, // -1
	net__http__Status__unassigned = 0, // 0
	net__http__Status__cont = 100, // 100
	net__http__Status__switching_protocols = 101, // 101
	net__http__Status__processing = 102, // 102
	net__http__Status__checkpoint_draft = 103, // 103
	net__http__Status__ok = 200, // 200
	net__http__Status__created = 201, // 201
	net__http__Status__accepted = 202, // 202
	net__http__Status__non_authoritative_information = 203, // 203
	net__http__Status__no_content = 204, // 204
	net__http__Status__reset_content = 205, // 205
	net__http__Status__partial_content = 206, // 206
	net__http__Status__multi_status = 207, // 207
	net__http__Status__already_reported = 208, // 208
	net__http__Status__im_used = 226, // 226
	net__http__Status__multiple_choices = 300, // 300
	net__http__Status__moved_permanently = 301, // 301
	net__http__Status__found = 302, // 302
	net__http__Status__see_other = 303, // 303
	net__http__Status__not_modified = 304, // 304
	net__http__Status__use_proxy = 305, // 305
	net__http__Status__switch_proxy = 306, // 306
	net__http__Status__temporary_redirect = 307, // 307
	net__http__Status__permanent_redirect = 308, // 308
	net__http__Status__bad_request = 400, // 400
	net__http__Status__unauthorized = 401, // 401
	net__http__Status__payment_required = 402, // 402
	net__http__Status__forbidden = 403, // 403
	net__http__Status__not_found = 404, // 404
	net__http__Status__method_not_allowed = 405, // 405
	net__http__Status__not_acceptable = 406, // 406
	net__http__Status__proxy_authentication_required = 407, // 407
	net__http__Status__request_timeout = 408, // 408
	net__http__Status__conflict = 409, // 409
	net__http__Status__gone = 410, // 410
	net__http__Status__length_required = 411, // 411
	net__http__Status__precondition_failed = 412, // 412
	net__http__Status__request_entity_too_large = 413, // 413
	net__http__Status__request_uri_too_long = 414, // 414
	net__http__Status__unsupported_media_type = 415, // 415
	net__http__Status__requested_range_not_satisfiable = 416, // 416
	net__http__Status__expectation_failed = 417, // 417
	net__http__Status__im_a_teapot = 418, // 418
	net__http__Status__misdirected_request = 421, // 421
	net__http__Status__unprocessable_entity = 422, // 422
	net__http__Status__locked = 423, // 423
	net__http__Status__failed_dependency = 424, // 424
	net__http__Status__unordered_collection = 425, // 425
	net__http__Status__upgrade_required = 426, // 426
	net__http__Status__precondition_required = 428, // 428
	net__http__Status__too_many_requests = 429, // 429
	net__http__Status__request_header_fields_too_large = 431, // 431
	net__http__Status__unavailable_for_legal_reasons = 451, // 451
	net__http__Status__client_closed_request = 499, // 499
	net__http__Status__internal_server_error = 500, // 500
	net__http__Status__not_implemented = 501, // 501
	net__http__Status__bad_gateway = 502, // 502
	net__http__Status__service_unavailable = 503, // 503
	net__http__Status__gateway_timeout = 504, // 504
	net__http__Status__http_version_not_supported = 505, // 505
	net__http__Status__variant_also_negotiates = 506, // 506
	net__http__Status__insufficient_storage = 507, // 507
	net__http__Status__loop_detected = 508, // 508
	net__http__Status__bandwidth_limit_exceeded = 509, // 509
	net__http__Status__not_extended = 510, // 510
	net__http__Status__network_authentication_required = 511, // 511
}  net__http__Status;

typedef enum {
	net__http__Version__unknown, // 
	net__http__Version__v1_1, // +1
	net__http__Version__v2_0, // +2
	net__http__Version__v1_0, // +3
}  net__http__Version;

typedef enum {
	veb__ContextReturnType__normal, // 
	veb__ContextReturnType__file, // +1
}  veb__ContextReturnType;

typedef enum {
	veb__RedirectType__found = ((int)(net__http__Status__found)), // ((int)(net__http__Status__found))
	veb__RedirectType__moved_permanently = ((int)(net__http__Status__moved_permanently)), // ((int)(net__http__Status__moved_permanently))
	veb__RedirectType__see_other = ((int)(net__http__Status__see_other)), // ((int)(net__http__Status__see_other))
	veb__RedirectType__temporary_redirect = ((int)(net__http__Status__temporary_redirect)), // ((int)(net__http__Status__temporary_redirect))
	veb__RedirectType__permanent_redirect = ((int)(net__http__Status__permanent_redirect)), // ((int)(net__http__Status__permanent_redirect))
}  veb__RedirectType;

// Thread definitions:
typedef pthread_t __v_thread;

// V type definitions:
struct IError {
	union {
		void* _object;
		None__* _None__;
		voidptr* _voidptr;
		Error* _Error;
		MessageError* _MessageError;
		time__TimeParseError* _time__TimeParseError;
		io__Eof* _io__Eof;
		io__NotExpected* _io__NotExpected;
		os__Eof* _os__Eof;
		os__NotExpected* _os__NotExpected;
		os__FileNotOpenedError* _os__FileNotOpenedError;
		os__SizeOfTypeIs0Error* _os__SizeOfTypeIs0Error;
		os__ExecutableNotFoundError* _os__ExecutableNotFoundError;
		db__sqlite__SQLError* _db__sqlite__SQLError;
		net__http__HeaderKeyError* _net__http__HeaderKeyError;
		net__http__MultiplePathAttributesError* _net__http__MultiplePathAttributesError;
		net__http__UnexpectedExtraAttributeError* _net__http__UnexpectedExtraAttributeError;
	};
	int _typ;
};

struct string {
	u8* str;
	int len;
	int is_lit;
};

struct array {
	voidptr data;
	int offset;
	int len;
	int cap;
	ArrayFlags flags;
	int element_size;
};

struct DenseArray {
	int key_bytes;
	int value_bytes;
	int cap;
	int len;
	u32 deletes;
	u8* all_deleted;
	u8* keys;
	u8* values;
};

struct map {
	int key_bytes;
	int value_bytes;
	u32 even_index;
	u8 cached_hashbits;
	u8 shift;
	DenseArray key_values;
	u32* metas;
	u32 extra_metas;
	bool has_string_keys;
	MapHashFn hash_fn;
	MapEqFn key_eq_fn;
	MapCloneFn clone_fn;
	MapFreeFn free_fn;
	int len;
};

struct Error {
	EMPTY_STRUCT_DECLARATION;
};

struct _option {
	u8 state;
	IError err;
};

struct _result {
	bool is_error;
	IError err;
};
typedef array Array_string;
typedef array Array_u8;
typedef array Array_voidptr;
typedef array Array_VCastTypeIndexName;
typedef array Array_MethodParam;
typedef array Array_int;
typedef array Array_rune;
typedef string Array_fixed_string_11 [11];
typedef voidptr Array_fixed_voidptr_11 [11];
typedef array Array_RepIndex;
typedef array Array_bool;
typedef array Array_main__Rank;
typedef map Map_string_int;
typedef array Array_orm__Primitive;
typedef array Array_Array_orm__Primitive;
typedef array Array_orm__TableField;
typedef map Map_string_string;
typedef array Array_Map_string_string;
typedef array Array_db__sqlite__Row;
typedef array Array_db__sqlite__OpenModeFlag;
typedef array Array_net__http__FileData;
typedef map Map_string_Array_net__http__FileData;
typedef array Array_veb__ControllerPath_ptr;
typedef map Map_string_veb__Route;
typedef array Array_veb__RouteMiddleware;
typedef array Array_net__http__Method;
typedef map Map_string_Map_string_string;
typedef array Array_net__http__Request;
typedef array Array_veb__FileResponse;
typedef array Array_veb__StringResponse;
typedef array Array_cmd__CmdOption;
typedef array Array_sql_db__PersonalFlag;
typedef array Array_sql_db__Personal;
typedef array Array_sql_db__Task;
typedef array Array_sql_db__PostFlag;
typedef array Array_sql_db__BlackId;
typedef array Array_sql_db__Type;
typedef u8 Array_fixed_u8_8 [8];
typedef u8 Array_fixed_u8_4 [4];
typedef array Array_Array_int;
typedef array Array_orm__OperationKind;
typedef array Array_VAttribute;
typedef map Map_string_Array_string;
typedef array Array_net__http__Cookie_ptr;
typedef array Array_net__http__HeaderConfig;
typedef map Map_net__http__CommonHeader_string;
typedef array Array_net__http__LineSegmentIndexes;
typedef array Array_net__http__Cookie;
typedef chan chan_net__TcpConn_ptr;
typedef array Array___v_thread;
typedef u8 Array_fixed_u8_16 [16];
typedef array Array_net__Addr;
typedef u32 Array_fixed_u32_4 [4];
typedef char Array_fixed_char_108 [108];
typedef u8 Array_fixed_u8_108 [108];
typedef array Array_IError;
typedef array Array_char_ptr;
typedef int Array_fixed_int_3 [3];
typedef array Array_os__Signal;
typedef char Array_fixed_char_256 [256];
typedef array Array_net__urllib__QueryValue;
typedef array Array_io__Writer;
typedef map Map_int_i64;
typedef map Map_K_Array_V;
typedef map Map_T_Array_int;
typedef map Map_T_int;
typedef array Array_u32;
typedef array Array_sync__Channel_ptr;
typedef array Array_sync__Direction;
typedef array Array_sync__Subscription;
typedef u8 Array_fixed_u8_2 [2];
typedef u8 Array_fixed_u8_5 [5];
typedef u8 Array_fixed_u8_25 [25];
typedef u8 Array_fixed_u8_32 [32];
typedef u8 Array_fixed_u8_64 [64];
typedef u8 Array_fixed_u8_256 [256];
typedef u64 Array_fixed_u64_309 [309];
typedef u64 Array_fixed_u64_324 [324];
typedef u32 Array_fixed_u32_10 [10];
typedef u64 Array_fixed_u64_20 [20];
typedef u64 Array_fixed_u64_584 [584];
typedef u64 Array_fixed_u64_652 [652];
typedef f64 Array_fixed_f64_36 [36];
typedef u8 Array_fixed_u8_26 [26];
typedef u8 Array_fixed_u8_512 [512];
typedef u64 Array_fixed_u64_18 [18];
typedef u64 Array_fixed_u64_47 [47];
typedef u64 Array_fixed_u64_31 [31];
typedef u8 Array_fixed_u8_17 [17];
typedef i32 Array_fixed_i32_1264 [1264];
typedef array Array_MapMode;
typedef int Array_fixed_int_10 [10];
typedef int Array_fixed_int_20 [20];
typedef array Array_TrimMode;
typedef array Array_StrIntpType;
typedef int Array_fixed_int_123 [123];
typedef string Array_fixed_string_7 [7];
typedef map Map_string_i64;
typedef u8 Array_fixed_u8_10 [10];
typedef char Array_fixed_char_1024 [1024];
typedef int Array_fixed_int_12 [12];
typedef int Array_fixed_int_13 [13];
typedef rune Array_fixed_rune_200 [200];
typedef u8 Array_fixed_u8_4096 [4096];
typedef u8 Array_fixed_u8_1024 [1024];
typedef array Array_os__ProcessState;
typedef int Array_fixed_int_6 [6];
typedef map Map_string_rune;
typedef array Array_db__sqlite__Result;
typedef rune Array_fixed_rune_4 [4];
typedef char Array_fixed_char_24 [24];
typedef char Array_fixed_char_46 [46];
typedef array Array_net__SocketOption;
typedef array Array_net__AddrFamily;
typedef u8 Array_fixed_u8_400 [400];
typedef int Array_fixed_int_1024 [1024];
typedef map Map_string_net__http__CommonHeader;
typedef array Array_net__http__Status;
typedef u8 Array_fixed_u8_65536 [65536];
typedef array Array_net__http__CommonHeader;
#define C__intptr_t intptr_t
typedef Array_u8 strings__Builder;
typedef struct sqlite3_file db__sqlite__Sqlite3_file;
typedef struct sqlite3_io_methods db__sqlite__Sqlite3_io_methods;
typedef struct sqlite3_vfs db__sqlite__Sqlite3_vfs;
typedef string veb__RawHtml;
typedef i64 time__Duration;
#define C__time_t time_t
typedef picoev__EpollLoop picoev__LoopType;
typedef int term__termios__TcFlag;
typedef int term__termios__Speed;
typedef u8 term__termios__Cc;
typedef bool (*anon_fn_voidptr__bool)(voidptr);
typedef voidptr (*anon_fn_voidptr__voidptr)(voidptr);
typedef int (*anon_fn_voidptr_voidptr__int)(voidptr,voidptr);
typedef void (*FnExitCb)();
typedef void (*anon_fn_voidptr_voidptr)(voidptr,voidptr);
typedef void (*FnGC_WarnCB)(char*,usize);
typedef int (*FnSortCB)(voidptr,voidptr);
typedef int (*db__sqlite__Sig1)(struct sqlite3_file*,i64*);
typedef int (*db__sqlite__Sig2)(db__sqlite__Sqlite3_file*,int*);
typedef int (*anon_fn_db__sqlite__sqlite3_file__int)(db__sqlite__Sqlite3_file*);
typedef int (*anon_fn_db__sqlite__sqlite3_file_voidptr_int_i64__int)(db__sqlite__Sqlite3_file*,voidptr,int,i64);
typedef int (*anon_fn_db__sqlite__sqlite3_file_i64__int)(db__sqlite__Sqlite3_file*,i64);
typedef int (*anon_fn_db__sqlite__sqlite3_file_int__int)(db__sqlite__Sqlite3_file*,int);
typedef int (*anon_fn_db__sqlite__sqlite3_file_int_voidptr__int)(db__sqlite__Sqlite3_file*,int,voidptr);
typedef int (*anon_fn_db__sqlite__sqlite3_file_int_int_int_voidptr__int)(db__sqlite__Sqlite3_file*,int,int,int,voidptr*);
typedef int (*anon_fn_db__sqlite__sqlite3_file_int_int_int__int)(db__sqlite__Sqlite3_file*,int,int,int);
typedef void (*anon_fn_db__sqlite__sqlite3_file)(db__sqlite__Sqlite3_file*);
typedef int (*anon_fn_db__sqlite__sqlite3_file_i64_int_voidptr__int)(db__sqlite__Sqlite3_file*,i64,int,voidptr*);
typedef int (*anon_fn_db__sqlite__sqlite3_file_i64_voidptr__int)(db__sqlite__Sqlite3_file*,i64,voidptr);
typedef void (*db__sqlite__Fn_sqlite3_syscall_ptr)();
typedef int (*anon_fn_db__sqlite__sqlite3_vfs_char_db__sqlite__sqlite3_file_int_int__int)(db__sqlite__Sqlite3_vfs*,char*,db__sqlite__Sqlite3_file*,int,int*);
typedef int (*anon_fn_db__sqlite__sqlite3_vfs_char_int__int)(db__sqlite__Sqlite3_vfs*,char*,int);
typedef int (*anon_fn_db__sqlite__sqlite3_vfs_char_int_int__int)(db__sqlite__Sqlite3_vfs*,char*,int,int*);
typedef int (*anon_fn_db__sqlite__sqlite3_vfs_char_int_char__int)(db__sqlite__Sqlite3_vfs*,char*,int,char*);
typedef voidptr (*anon_fn_db__sqlite__sqlite3_vfs_char__voidptr)(db__sqlite__Sqlite3_vfs*,char*);
typedef void (*anon_fn_db__sqlite__sqlite3_vfs_int_char)(db__sqlite__Sqlite3_vfs*,int,char*);
typedef voidptr (*anon_fn_db__sqlite__sqlite3_vfs_voidptr_char__voidptr)(db__sqlite__Sqlite3_vfs*,voidptr,char*);
typedef void (*anon_fn_db__sqlite__sqlite3_vfs_voidptr)(db__sqlite__Sqlite3_vfs*,voidptr);
typedef int (*anon_fn_db__sqlite__sqlite3_vfs_int_char__int)(db__sqlite__Sqlite3_vfs*,int,char*);
typedef int (*anon_fn_db__sqlite__sqlite3_vfs_int__int)(db__sqlite__Sqlite3_vfs*,int);
typedef int (*anon_fn_db__sqlite__sqlite3_vfs_f64__int)(db__sqlite__Sqlite3_vfs*,f64*);
typedef int (*anon_fn_db__sqlite__sqlite3_vfs_i64__int)(db__sqlite__Sqlite3_vfs*,i64*);
typedef char* (*anon_fn_db__sqlite__sqlite3_vfs_char__char)(db__sqlite__Sqlite3_vfs*,char*);
typedef veb__Context* (*veb__ControllerHandler)(veb__Context*,net__urllib__URL*,string);
typedef _result_string (*anon_fn_int__result_string)(int);
typedef bool (*anon_fn_u8__bool)(u8);
typedef _result_void (*net__http__RequestRedirectFn)(net__http__Request*,int,string);
typedef _result_void (*net__http__RequestProgressFn)(net__http__Request*,Array_u8,u64);
typedef _result_void (*net__http__RequestProgressBodyFn)(net__http__Request*,Array_u8,u64,u64,int);
typedef _result_void (*net__http__RequestFinishFn)(net__http__Request*,u64);
typedef _result_int (*net__http__FnReceiveChunk)(voidptr,u8*,int);
typedef void (*anon_fn_mut_net__http__server)(net__http__Server*);
typedef void (*anon_fn_string)(string);
typedef void (*os__FnWalkContextCB)(voidptr,string);
typedef void (*os__SignalHandler)(os__Signal);
typedef void (*os__FN_SA_Handler)(int);
typedef void (*anon_fn_int_int_voidptr)(int,int,voidptr);
typedef void (*anon_fn_voidptr_picohttpparser__request_mut_picohttpparser__response)(voidptr,picohttpparser__Request,picohttpparser__Response*);
typedef void (*anon_fn_voidptr_picohttpparser__request_mut_picohttpparser__response_ierror)(voidptr,picohttpparser__Request,picohttpparser__Response*,IError);
typedef void (*anon_fn_mut_picoev__picoev_int_int)(picoev__Picoev*,int,int);
typedef void (*anon_fn_)();
typedef void (*anon_fn_voidptr)(voidptr);
typedef int (*anon_fn_voidptr_u8_usize__int)(voidptr,u8*,usize);
typedef int (*anon_fn_voidptr_c__mbedtls_ssl_context_char_int__int)(voidptr,mbedtls_ssl_context*,char*,int);
typedef void (*anon_fn_voidptr_u8_usize)(voidptr,u8*,usize);
typedef _result_net__mbedtls__SSLCerts_ptr (*anon_fn_mut_net__mbedtls__ssllistener_string__result_net__mbedtls__SSLCerts)(net__mbedtls__SSLListener*,string);
typedef bool (*anon_fn_mut_main__context__bool)(main__Context*);
typedef int (*anon_fn_db__sqlite__sqlite3_vfs_char_db__sqlite__fn_sqlite3_syscall_ptr__int)(db__sqlite__Sqlite3_vfs*,char*,db__sqlite__Fn_sqlite3_syscall_ptr);
typedef db__sqlite__Fn_sqlite3_syscall_ptr (*anon_fn_db__sqlite__sqlite3_vfs_char__db__sqlite__Fn_sqlite3_syscall_ptr)(db__sqlite__Sqlite3_vfs*,char*);
struct veb__ControllerInterface {
	union {
		void* _object;
		veb__Controller* _veb__Controller;
		voidptr* _voidptr;
		veb__RequestParams* _veb__RequestParams;
	};
	int _typ;
	Array_veb__ControllerPath_ptr* controllers;
};
struct veb__MiddlewareApp {
	union {
		void* _object;
		main__App* _main__App;
		voidptr* _voidptr;
		veb__Middleware_T_main__Context* _veb__Middleware_T_main__Context;
	};
	int _typ;
	Array_voidptr* global_handlers;
	Array_voidptr* global_handlers_after;
	Array_veb__RouteMiddleware* route_handlers;
	Array_veb__RouteMiddleware* route_handlers_after;
};
struct veb__HasBeforeRequest {
	union {
		void* _object;
	};
	int _typ;
};
struct veb__StaticApp {
	union {
		void* _object;
		main__App* _main__App;
		voidptr* _voidptr;
		veb__StaticHandler* _veb__StaticHandler;
	};
	int _typ;
	Map_string_string* static_files;
	Map_string_string* static_mime_types;
	Map_string_string* static_hosts;
};
struct veb__BeforeAcceptApp {
	union {
		void* _object;
	};
	int _typ;
};
struct orm__Connection {
	union {
		void* _object;
		db__sqlite__DB* _db__sqlite__DB;
		voidptr* _voidptr;
	};
	int _typ;
};
struct net__http__Downloader {
	union {
		void* _object;
		voidptr* _voidptr;
		net__http__TerminalStreamingDownloader* _net__http__TerminalStreamingDownloader;
		net__http__SilentStreamingDownloader* _net__http__SilentStreamingDownloader;
	};
	int _typ;
};
struct net__http__Handler {
	union {
		void* _object;
		net__http__DebugHandler* _net__http__DebugHandler;
		voidptr* _voidptr;
	};
	int _typ;
};
struct net__Connection {
	union {
		void* _object;
		net__TcpConn* _net__TcpConn;
		voidptr* _voidptr;
		net__ssl__SSLConn* _net__ssl__SSLConn;
		net__mbedtls__SSLConn* _net__mbedtls__SSLConn;
	};
	int _typ;
};
struct net__Dialer {
	union {
		void* _object;
		net__TCPDialer* _net__TCPDialer;
		voidptr* _voidptr;
		net__ssl__SSLDialer* _net__ssl__SSLDialer;
		net__socks__SOCKS5Dialer* _net__socks__SOCKS5Dialer;
	};
	int _typ;
};
struct io__Reader {
	union {
		void* _object;
		net__TcpConn* _net__TcpConn;
		voidptr* _voidptr;
		os__File* _os__File;
		net__ssl__SSLConn* _net__ssl__SSLConn;
		io__BufferedReader* _io__BufferedReader;
		io__ReaderWriterImpl* _io__ReaderWriterImpl;
		net__mbedtls__SSLConn* _net__mbedtls__SSLConn;
	};
	int _typ;
};
struct io__Writer {
	union {
		void* _object;
		io__MultiWriter* _io__MultiWriter;
		voidptr* _voidptr;
		net__TcpConn* _net__TcpConn;
		os__File* _os__File;
		net__ssl__SSLConn* _net__ssl__SSLConn;
		net__UdpConn* _net__UdpConn;
		io__BufferedWriter* _io__BufferedWriter;
		io__ReaderWriterImpl* _io__ReaderWriterImpl;
		net__mbedtls__SSLConn* _net__mbedtls__SSLConn;
		crypto__sha256__Digest* _crypto__sha256__Digest;
	};
	int _typ;
};
struct io__RandomReader {
	union {
		void* _object;
		os__File* _os__File;
		voidptr* _voidptr;
	};
	int _typ;
};
struct io__ReaderWriter {
	union {
		void* _object;
		io__ReaderWriterImpl* _io__ReaderWriterImpl;
		voidptr* _voidptr;
	};
	int _typ;
};
struct io__RandomWriter {
	union {
		void* _object;
	};
	int _typ;
};
struct rand__PRNG {
	union {
		void* _object;
		rand__wyrand__WyRandRNG* _rand__wyrand__WyRandRNG;
		voidptr* _voidptr;
	};
	int _typ;
};
struct hash__Hash {
	union {
		void* _object;
		crypto__sha256__Digest* _crypto__sha256__Digest;
		voidptr* _voidptr;
	};
	int _typ;
};
struct hash__Hash32er {
	union {
		void* _object;
	};
	int _typ;
};
struct hash__Hash64er {
	union {
		void* _object;
	};
	int _typ;
};
// #start sorted_symbols
struct none {
	EMPTY_STRUCT_DECLARATION;
};

struct None__ {
	Error Error;
};

struct StrIntpCgenData {
	string str;
	string fmt;
	string d;
};

struct veb__Result {
	EMPTY_STRUCT_DECLARATION;
};

// Union sum type orm__Primitive = 
//          |  143 = orm__InfixType
//          |  144 = orm__Null
//          |   19 = bool
//          |   16 = f32
//          |   17 = f64
//          |    6 = i16
//          |    9 = i64
//          |    5 = i8
//          |    8 = int
//          |   21 = string
//          |  142 = time__Time
//          |   12 = u16
//          |   13 = u32
//          |   14 = u64
//          |   11 = u8
struct orm__Primitive {
	union {
		orm__InfixType* _orm__InfixType;
		orm__Null* _orm__Null;
		bool* _bool;
		f32* _f32;
		f64* _f64;
		i16* _i16;
		i64* _i64;
		i8* _i8;
		int* _int;
		string* _string;
		time__Time* _time__Time;
		u16* _u16;
		u32* _u32;
		u64* _u64;
		u8* _u8;
	};
	int _typ;
};

struct db__sqlite__Stmt {
	struct sqlite3_stmt* stmt;
	db__sqlite__DB* db;
};

struct orm__Null {
	EMPTY_STRUCT_DECLARATION;
};

struct net__http__FileData {
	string filename;
	string content_type;
	string data;
};

struct net__http__MultiplePathAttributesError {
	Error Error;
};

struct veb__FileData {
	string filename;
	string content_type;
	string data;
};

struct io__Eof {
	Error Error;
};

struct cmd__CmdOption {
	string abbr;
	string full;
	string vari;
	string defa;
	string desc;
};

struct net__http__HeaderKV {
	string key;
	string value;
};

struct net__http__DebugHandler {
	EMPTY_STRUCT_DECLARATION;
};

struct net__TCPDialer {
	EMPTY_STRUCT_DECLARATION;
};

struct os__Eof {
	Error Error;
};

struct os__FileNotOpenedError {
	Error Error;
};

struct os__SizeOfTypeIs0Error {
	Error Error;
};

struct os__ExecutableNotFoundError {
	Error Error;
};

struct os__Uname {
	string sysname;
	string nodename;
	string release;
	string version;
	string machine;
};

struct net__urllib__ParseAuthorityRes {
	net__urllib__Userinfo* user;
	string host;
};

struct net__urllib__QueryValue {
	string key;
	string value;
};

struct sync__Subscription {
	sync__Semaphore* sem;
	sync__Subscription** prev;
	sync__Subscription* nxt;
};

struct io__util__TempFileOptions {
	string path;
	string pattern;
};

struct io__util__TempDirOptions {
	string path;
	string pattern;
};

struct picohttpparser__Header {
	string name;
	string value;
};

struct GCHeapUsage {
	usize heap_size;
	usize free_bytes;
	usize total_bytes;
	usize unmapped_bytes;
	usize bytes_since_gc;
};

struct VCastTypeIndexName {
	int tindex;
	string tname;
};

struct VAssertMetaInfo {
	string fpath;
	int line_nr;
	string fn_name;
	string src;
	string op;
	string llabel;
	string rlabel;
	string lvalue;
	string rvalue;
	string message;
	bool has_msg;
};

struct MethodParam {
	int typ;
	string name;
};

struct FunctionData {
	string name;
	Array_string attrs;
	Array_MethodParam args;
	int return_type;
	int typ;
};

struct VariantData {
	int typ;
};

struct EnumData {
	string name;
	i64 value;
	Array_string attrs;
};

struct FieldData {
	string name;
	int typ;
	int unaliased_typ;
	Array_string attrs;
	bool is_pub;
	bool is_mut;
	bool is_shared;
	bool is_atomic;
	bool is_option;
	bool is_array;
	bool is_map;
	bool is_chan;
	bool is_enum;
	bool is_struct;
	bool is_alias;
	u8 indirections;
};

struct VAttribute {
	string name;
	bool has_arg;
	string arg;
	AttributeKind kind;
};

union strconv__Float64u {
	f64 f;
	u64 u;
};

union strconv__Float32u {
	f32 f;
	u32 u;
};

struct VContext {
	int allocator;
};

struct Option {
	u8 state;
	IError err;
};

struct MessageError {
	string msg;
	int code;
};

struct SortedMap {
	int value_bytes;
	mapnode* root;
	int len;
};

struct RepIndex {
	int idx;
	int val_idx;
};

struct WrapConfig {
	int width;
	string end;
};

union StrIntpMem {
	u32 d_c;
	u8 d_u8;
	i8 d_i8;
	u16 d_u16;
	i16 d_i16;
	u32 d_u32;
	int d_i32;
	u64 d_u64;
	i64 d_i64;
	f32 d_f32;
	f64 d_f64;
	string d_s;
	string d_r;
	voidptr d_p;
	voidptr d_vp;
};

struct strconv__BF_param {
	u8 pad_ch;
	int len0;
	int len1;
	bool positive;
	bool sign_flag;
	strconv__Align_text align;
	bool rm_tail_zero;
};

struct main__Rank {
	string team_id;
	int score;
	Array_bool challenge;
};

struct veb__StaticHandler {
	Map_string_string static_files;
	Map_string_string static_mime_types;
	Map_string_string static_hosts;
};

struct veb__Middleware_T_main__Context {
	Array_voidptr global_handlers;
	Array_voidptr global_handlers_after;
	Array_veb__RouteMiddleware route_handlers;
	Array_veb__RouteMiddleware route_handlers_after;
};

struct db__sqlite__DB {
	bool is_open;
	struct sqlite3* conn;
};

struct veb__RunParams {
	net__AddrFamily family;
	string host;
	int port;
	bool show_startup_message;
	int timeout_in_seconds;
};
struct _option_int {
	byte state;
	IError err;
	byte data[sizeof(int) > 1 ? sizeof(int) : 1];
};

struct veb__CorsOptions {
	Array_string origins;
	bool allow_credentials;
	Array_string allowed_headers;
	Array_net__http__Method allowed_methods;
	Array_string expose_headers;
	_option_int max_age;
};

struct strconv__PrepNumber {
	bool negative;
	int exponent;
	u64 mantissa;
};

struct strconv__AtoF64Param {
	bool allow_extra_chars;
};

struct strconv__Dec32 {
	u32 m;
	int e;
};

union strconv__Uf32 {
	f32 f;
	u32 u;
};

struct strconv__Dec64 {
	u64 m;
	int e;
};

struct strconv__Uint128 {
	u64 lo;
	u64 hi;
};

union strconv__Uf64 {
	f64 f;
	u64 u;
};

struct orm__SelectConfig {
	string table;
	bool is_count;
	bool has_where;
	bool has_order;
	string order;
	orm__OrderType order_type;
	bool has_limit;
	string primary;
	bool has_offset;
	Array_string fields;
	Array_int types;
};

struct orm__QueryData {
	Array_string fields;
	Array_orm__Primitive data;
	Array_int types;
	Array_Array_int parentheses;
	Array_orm__OperationKind kinds;
	Array_int auto_fields;
	Array_bool is_and;
};

struct orm__TableField {
	string name;
	int typ;
	bool nullable;
	string default_val;
	Array_VAttribute attrs;
	bool is_arr;
};

struct time__Time {
	i64 __v_unix;
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
	int nanosecond;
	bool is_local;
};

struct orm__InfixType {
	string name;
	orm__MathOperationKind operator;
	orm__Primitive right;
};

struct db__sqlite__Row {
	Array_string vals;
};

struct veb__RedirectParams {
	veb__RedirectType typ;
};

struct net__urllib__URL {
	string scheme;
	string opaque;
	net__urllib__Userinfo* user;
	string host;
	string path;
	string raw_path;
	bool force_query;
	string raw_query;
	string fragment;
};

struct veb__ControllerPath {
	string path;
	veb__ControllerHandler handler;
	string host;
};

struct veb__Controller {
	Array_veb__ControllerPath_ptr controllers;
};

struct veb__Route {
	Array_net__http__Method methods;
	string path;
	string host;
	Array_voidptr middlewares;
	Array_voidptr after_middlewares;
};

struct veb__RouteMiddleware {
	Array_string url_parts;
	voidptr handler;
};

struct net__http__UnexpectedExtraAttributeError {
	Error Error;
	Array_string attributes;
};

struct os__File {
	voidptr cfile;
	int fd;
	bool is_opened;
};

struct veb__StringResponse {
	bool open;
	string str;
	i64 pos;
	bool should_close_conn;
};

struct veb__RequestParams {
	voidptr global_app;
	Array_veb__ControllerPath_ptr controllers;
	Map_string_veb__Route* routes;
	int timeout_in_seconds;
	u8* buf;
	Array_int idx;
	Array_net__http__Request incomplete_requests;
	Array_veb__FileResponse file_responses;
	Array_veb__StringResponse string_responses;
};

struct cmd__CmdSet {
	int port;
	string args;
	bool nohup;
	int workers;
};

struct sql_db__Personal {
	int pid;
	string id;
	string email;
	string passwd;
	string whoami;
	Array_sql_db__PersonalFlag challenge;
};

struct sql_db__PersonalFlag {
	int parents_id;
	int parents_challenge;
	string complete;
};

struct sql_db__Task {
	int tid;
	string type_text;
	Array_sql_db__PostFlag flag;
	Array_sql_db__PersonalFlag challenge;
	string name;
	string diff;
	string intro;
	int max_score;
	int score;
	bool container;
};

struct sql_db__PostFlag {
	int parents_challenge;
	string flag;
};

struct sql_db__BlackId {
	int id;
	string name;
};

struct sql_db__BlackList {
	string ip;
	Array_sql_db__BlackId id;
};

struct sql_db__StatusReturn {
	bool return_bool;
	bool find_passwd;
	Array_sql_db__Personal id_check;
};

struct sql_db__Type {
	string name;
	Array_sql_db__Task type_text;
};

struct time__DateTimeParser {
	string datetime;
	string format;
	int current_pos_datetime;
};

struct time__TimeParseError {
	Error Error;
	int code;
	string message;
};

struct time__StopWatchOptions {
	bool auto_start;
};

struct time__StopWatch {
	u64 elapsed;
	u64 start;
	u64 end;
};
typedef net__http__HeaderKV Array_fixed_net__http__HeaderKV_50 [50];

struct net__http__HeaderConfig {
	net__http__CommonHeader key;
	string value;
};

struct net__http__HeaderCoerceConfig {
	bool canonicalize;
};

struct net__http__HeaderQueryConfig {
	bool exact;
};

struct net__http__HeaderRenderConfig {
	net__http__Version version;
	bool coerce;
	bool canonicalize;
};

struct net__http__HeaderKeyError {
	Error Error;
	int code;
	string header;
	u8 invalid_char;
};

struct net__http__HttpProxy {
	string scheme;
	string username;
	string password;
	string host;
	string hostname;
	int port;
	string url;
};

struct io__BufferedReader {
	io__Reader reader;
	Array_u8 buf;
	int offset;
	int len;
	int fails;
	int mfails;
	bool end_of_stream;
	int total_read;
};

struct net__http__LineSegmentIndexes {
	int start;
	int end;
};

struct net__http__WaitTillRunningParams {
	int max_retries;
	int retry_period_ms;
};

struct net__http__HandlerWorker {
	int id;
	chan_net__TcpConn_ptr ch;
	net__http__Handler handler;
};

struct net__ShutdownConfig {
	net__ShutdownDirection how;
};

struct net__Socket {
	int handle;
};

struct net__ListenOptions {
	bool dualstack;
	int backlog;
};

struct os__NotExpected {
	string cause;
	int code;
};

struct os__FilePermission {
	bool read;
	bool write;
	bool execute;
};

struct os__Stat {
	u64 dev;
	u64 inode;
	u32 mode;
	u64 nlink;
	u32 uid;
	u32 gid;
	u64 rdev;
	u64 size;
	i64 atime;
	i64 mtime;
	i64 ctime;
};

struct os__PathKind {
	bool is_file;
	bool is_dir;
	bool is_link;
};

struct os__SystemError {
	string msg;
	int code;
};

struct os__DiskUsage {
	u64 total;
	u64 available;
	u64 used;
};

struct os__Result {
	int exit_code;
	string output;
};

struct os__Command {
	voidptr f;
	bool eof;
	int exit_code;
	string path;
	bool redirect_stdout;
};

struct os__MvParams {
	bool overwrite;
};

struct os__MkdirParams {
	u32 mode;
};

struct net__urllib__Userinfo {
	string username;
	string password;
	bool password_set;
};

struct net__urllib__Values {
	Array_net__urllib__QueryValue data;
	int len;
};

struct encoding__html__EscapeConfig {
	bool quote;
};

struct compress__gzip__CompressParams {
	int compression_level;
	compress__gzip__CompressFlags flags;
};

struct compress__gzip__DecompressParams {
	bool verify_header_checksum;
	bool verify_length;
	bool verify_checksum;
	compress__gzip__DecompressFlags flags;
};

struct compress__gzip__GzipHeader {
	int length;
	Array_u8 extra;
	Array_u8 filename;
	Array_u8 comment;
	u32 modification_time;
	u8 operating_system;
};

struct io__BufferedReaderConfig {
	io__Reader reader;
	int cap;
	int retries;
};

struct io__BufferedReadLineConfig {
	u8 delim;
};

struct io__NotExpected {
	string cause;
	int code;
};

struct io__BufferedWriter {
	int n;
	io__Writer wr;
	Array_u8 buf;
};

struct io__BufferedWriterConfig {
	io__Writer writer;
	int cap;
};

struct io__CopySettings {
	int buffer_size;
};

struct io__MultiWriter {
	Array_io__Writer writers;
};

struct io__ReadAllConfig {
	bool read_to_end_of_stream;
	io__Reader reader;
};

struct io__ReaderWriterImpl {
	io__Reader r;
	io__Writer w;
};

struct picoev__Target {
	int fd;
	int loop_id;
	u32 events;
	anon_fn_int_int_voidptr cb;
	int backend;
};

struct picohttpparser__Response {
	int fd;
	u8* date;
	u8* buf_start;
	u8* buf;
};

struct picoev__Config {
	int port;
	anon_fn_voidptr_picohttpparser__request_mut_picohttpparser__response cb;
	anon_fn_voidptr_picohttpparser__request_mut_picohttpparser__response_ierror err_cb;
	anon_fn_mut_picoev__picoev_int_int raw_cb;
	voidptr user_data;
	int timeout_secs;
	int max_headers;
	int max_read;
	int max_write;
	net__AddrFamily family;
	string host;
};
struct _option_anon_fn_mut_net__mbedtls__ssllistener_string__result_net__mbedtls__SSLCerts {
	byte state;
	IError err;
	byte data[sizeof(void*) > 1 ? sizeof(void*) : 1];
};

struct net__mbedtls__SSLConnectConfig {
	string verify;
	string cert;
	string cert_key;
	bool validate;
	bool in_memory_verification;
	_option_anon_fn_mut_net__mbedtls__ssllistener_string__result_net__mbedtls__SSLCerts get_certificate;
};

struct arrays__WindowAttribute {
	int size;
	int step;
};

struct arrays__Block {
	u64 x;
	u64 y;
	u64 z;
	u64 w;
};

struct arrays__UnalignedBlock {
	u64 x;
	u64 y;
	u64 z;
	u64 w;
};

struct net__socks__SOCKS5Dialer {
	net__Dialer dialer;
	string proxy_address;
	string username;
	string password;
};

struct rand__config__NormalConfigStruct {
	f64 mu;
	f64 sigma;
};

struct rand__config__ShuffleConfigStruct {
	int start;
	int end;
};

struct rand__config__PRNGConfigStruct {
	Array_u32 seed_;
};

struct net__http__chunked__ChunkScanner {
	int pos;
	string text;
};

struct sync__Semaphore {
	sem_t sem;
};

struct sync__Mutex {
	pthread_mutex_t mutex;
};

struct sync__RwMutex {
	pthread_rwlock_t mutex;
};

struct sync__RwMutexAttr {
	pthread_rwlockattr_t attr;
};

union net__conv__ConversionUnion {
	u64 as_int64;
	u32 as_int32;
	f64 as_double64;
	f32 as_double32;
};

struct strings__textscanner__TextScanner {
	string input;
	int ilen;
	int pos;
};
typedef term__termios__Cc Array_fixed_term__termios__Cc_32 [32];

struct hash__crc32__Crc32 {
	Array_u32 table;
};

struct picohttpparser__Pret {
	string err;
	int ret;
};
typedef picohttpparser__Header Array_fixed_picohttpparser__Header_100 [100];

struct crypto__sha256__Digest {
	Array_u32 h;
	Array_u8 x;
	int nx;
	u64 len;
	bool is224;
};

struct net__mbedtls__SSLCerts {
	mbedtls_x509_crt cacert;
	mbedtls_x509_crt client_cert;
	mbedtls_pk_context client_key;
};

struct rand__buffer__PRNGBuffer {
	int bytes_left;
	u64 buffer;
};

struct veb__MiddlewareOptions_T_main__Context {
	anon_fn_mut_main__context__bool handler;
	bool after;
};

struct mapnode {
	voidptr* children;
	int len;
	Array_fixed_string_11 keys;
	Array_fixed_voidptr_11 values;
};

struct StrIntpData {
	string str;
	u32 fmt;
	StrIntpMem d;
};

struct main__App {
	veb__StaticHandler StaticHandler;
	veb__Middleware_T_main__Context Middleware;
	db__sqlite__DB db;
};

struct db__sqlite__SQLError {
	MessageError MessageError;
};

struct net__http__Cookie {
	string name;
	string value;
	string path;
	string domain;
	time__Time expires;
	string raw_expires;
	int max_age;
	bool secure;
	bool http_only;
	net__http__SameSite same_site;
	string raw;
	Array_string unparsed;
};

struct veb__FileResponse {
	bool open;
	os__File file;
	i64 total;
	i64 pos;
	bool should_close_conn;
};

union encoding__base64__B64_64_datablock {
	u64 data;
	Array_fixed_u8_8 data_byte;
};

union encoding__base64__B64_32_datablock {
	u32 data;
	Array_fixed_u8_4 data_byte;
};

struct net__http__Header {
	Array_fixed_net__http__HeaderKV_50 data;
	int cur_pos;
};

struct net__http__SilentStreamingDownloader {
	string path;
	os__File f;
};

struct net__Unix {
	Array_fixed_u8_108 path;
};
#pragma pack(push, 1)

struct net__Ip {
	u16 port;
	Array_fixed_u8_4 addr;
	Array_fixed_u8_8 sin_pad;
};
#pragma pack(pop)
#pragma pack(push, 1)

struct net__Ip6 {
	u16 port;
	u32 flow_info;
	Array_fixed_u8_16 addr;
	u32 scope_id;
};
#pragma pack(pop)

struct net__TcpSocket {
	net__Socket Socket;
};

struct os__FileMode {
	os__FileType typ;
	os__FilePermission owner;
	os__FilePermission group;
	os__FilePermission others;
};

struct term__termios__Termios {
	term__termios__TcFlag c_iflag;
	term__termios__TcFlag c_oflag;
	term__termios__TcFlag c_cflag;
	term__termios__TcFlag c_lflag;
	term__termios__Cc c_line;
	Array_fixed_term__termios__Cc_32 c_cc;
	term__termios__Speed c_ispeed;
	term__termios__Speed c_ospeed;
};

struct os__Process {
	string filename;
	int pid;
	int code;
	os__ProcessState status;
	string err;
	Array_string args;
	string work_folder;
	bool env_is_custom;
	Array_string env;
	bool use_stdio_ctl;
	bool use_pgroup;
	Array_fixed_int_3 stdio_fd;
	voidptr wdata;
	bool create_no_window;
};

struct encoding__html__UnescapeConfig {
	encoding__html__EscapeConfig EscapeConfig;
	bool all;
};

struct picohttpparser__Request {
	int prev_len;
	string method;
	string path;
	Array_fixed_picohttpparser__Header_100 headers;
	int num_headers;
	string body;
};
typedef picoev__Target* Array_fixed_picoev__Target_ptr1_4096 [4096];

struct net__ssl__SSLConnectConfig {
	net__mbedtls__SSLConnectConfig SSLConnectConfig;
};

struct net__mbedtls__SSLConn {
	net__mbedtls__SSLConnectConfig config;
	mbedtls_net_context server_fd;
	mbedtls_ssl_context ssl;
	mbedtls_ssl_config conf;
	net__mbedtls__SSLCerts* certs;
	int handle;
	time__Duration duration;
	bool opened;
	string ip;
	bool owns_socket;
};

struct rand__wyrand__WyRandRNG {
	rand__buffer__PRNGBuffer PRNGBuffer;
	u64 state;
	int bytes_left;
	u64 buffer;
};

struct sync__Channel {
	u8* ringbuf;
	u8* statusbuf;
	u32 objsize;
	sync__Semaphore writesem;
	sync__Semaphore readsem;
	sync__Semaphore writesem_im;
	sync__Semaphore readsem_im;
	atomic_uintptr_t write_adr;
	atomic_uintptr_t read_adr;
	atomic_uintptr_t adr_read;
	atomic_uintptr_t adr_written;
	u32 write_free;
	u32 read_avail;
	u32 buf_elem_write_idx;
	u32 buf_elem_read_idx;
	sync__Subscription* write_subscriber;
	sync__Subscription* read_subscriber;
	u16 write_sub_mtx;
	u16 read_sub_mtx;
	u16 closed;
	u32 cap;
};

struct sync__ManyTimes {
	sync__RwMutex m;
	u64 times;
	u64 count;
};

struct sync__Once {
	sync__RwMutex m;
	u64 count;
};

struct sync__WaitGroup {
	u32 task_count;
	u32 wait_count;
	sync__Semaphore sem;
};

struct net__mbedtls__SSLListener {
	string saddr;
	net__mbedtls__SSLConnectConfig config;
	mbedtls_net_context server_fd;
	mbedtls_ssl_context ssl;
	mbedtls_ssl_config conf;
	net__mbedtls__SSLCerts* certs;
	bool opened;
};

struct net__http__Request {
	Map_string_string cookies;
	net__http__Version version;
	net__http__Method method;
	net__http__Header header;
	string host;
	string data;
	string url;
	string user_agent;
	bool verbose;
	voidptr user_ptr;
	net__http__HttpProxy* proxy;
	i64 read_timeout;
	i64 write_timeout;
	bool validate;
	string verify;
	string cert;
	string cert_key;
	bool in_memory_verification;
	bool allow_redirect;
	int max_retries;
	net__http__RequestRedirectFn on_redirect;
	net__http__RequestProgressFn on_progress;
	net__http__RequestProgressBodyFn on_progress_body;
	net__http__RequestFinishFn on_finish;
	i64 stop_copying_limit;
	i64 stop_receiving_limit;
};

struct net__TcpConn {
	net__TcpSocket sock;
	int handle;
	time__Time write_deadline;
	time__Time read_deadline;
	time__Duration read_timeout;
	time__Duration write_timeout;
	bool is_blocking;
};

struct net__http__Response {
	string body;
	net__http__Header header;
	int status_code;
	string status_msg;
	string http_version;
};

struct picoev__Picoev {
	anon_fn_voidptr_picohttpparser__request_mut_picohttpparser__response cb;
	anon_fn_voidptr_picohttpparser__request_mut_picohttpparser__response_ierror error_callback;
	anon_fn_mut_picoev__picoev_int_int raw_callback;
	int timeout_secs;
	int max_headers;
	int max_read;
	int max_write;
	picoev__LoopType* loop;
	Array_fixed_picoev__Target_ptr1_4096 file_descriptors;
	Map_int_i64 timeouts;
	int num_loops;
	u8* buf;
	Array_fixed_int_1024 idx;
	u8* out;
	string date;
	voidptr user_data;
};

struct net__ssl__SSLConn {
	net__mbedtls__SSLConn SSLConn;
};

struct net__http__FetchConfig {
	string url;
	net__http__Method method;
	net__http__Header header;
	string data;
	Map_string_string params;
	Map_string_string cookies;
	string user_agent;
	voidptr user_ptr;
	bool verbose;
	net__http__HttpProxy* proxy;
	bool validate;
	string verify;
	string cert;
	string cert_key;
	bool in_memory_verification;
	bool allow_redirect;
	int max_retries;
	net__http__RequestRedirectFn on_redirect;
	net__http__RequestProgressFn on_progress;
	net__http__RequestProgressBodyFn on_progress_body;
	net__http__RequestFinishFn on_finish;
	i64 stop_copying_limit;
	i64 stop_receiving_limit;
};

struct net__http__TerminalStreamingDownloader {
	net__http__SilentStreamingDownloader SilentStreamingDownloader;
	time__Time start_time;
	time__Time past_time;
	u64 past_received;
};

struct net__http__PostMultipartFormConfig {
	Map_string_string form;
	Map_string_Array_net__http__FileData files;
	net__http__Header header;
};

struct net__http__ResponseConfig {
	net__http__Version version;
	net__http__Status status;
	net__http__Header header;
	string body;
};

struct net__TcpListener {
	net__TcpSocket sock;
	time__Duration accept_timeout;
	time__Time accept_deadline;
	bool is_blocking;
};

union net__AddrData {
	net__Unix Unix;
	net__Ip Ip;
	net__Ip6 Ip6;
};

struct os__FileInfo {
	os__FileMode FileMode;
	u64 size;
	i64 mtime;
};
typedef struct epoll_event Array_fixed_C__epoll_event_1024 [1024];

struct net__ssl__SSLDialer {
	net__ssl__SSLConnectConfig config;
};

struct veb__Context {
	string content_type;
	bool done;
	bool takeover;
	veb__ContextReturnType return_type;
	string return_file;
	bool client_wants_to_close;
	i64 page_gen_start;
	net__http__Request req;
	Map_string_string custom_mime_types;
	net__TcpConn* conn;
	Map_string_string query;
	Map_string_string form;
	Map_string_Array_net__http__FileData files;
	net__http__Response res;
	string form_error;
	int livereload_poll_interval_ms;
};

struct net__http__DownloaderParams {
	net__http__FetchConfig FetchConfig;
	net__http__Downloader* downloader;
};

struct net__http__Server {
	net__http__ServerStatus state;
	string addr;
	int port;
	net__http__Handler handler;
	time__Duration read_timeout;
	time__Duration write_timeout;
	time__Duration accept_timeout;
	int pool_channel_slots;
	int worker_num;
	net__TcpListener listener;
	anon_fn_mut_net__http__server on_running;
	anon_fn_mut_net__http__server on_stopped;
	anon_fn_mut_net__http__server on_closed;
	bool show_startup_message;
};
#pragma pack(push, 1)

struct net__Addr {
	u16 f;
	net__AddrData addr;
};
#pragma pack(pop)

struct picoev__EpollLoop {
	int id;
	int epoll_fd;
	Array_fixed_C__epoll_event_1024 events;
	i64 now;
};

struct main__Context {
	veb__Context Context;
};

struct net__UdpSocket {
	net__Socket Socket;
	net__Addr l;
	bool has_r;
	net__Addr r;
};

struct net__UdpConn {
	net__UdpSocket sock;
	time__Time write_deadline;
	time__Time read_deadline;
	time__Duration read_timeout;
	time__Duration write_timeout;
};
// #end sorted_symbols

// BEGIN_multi_return_structs
struct multi_return_u32_u32 {
	u32 arg0;
	u32 arg1;
};

struct multi_return_string_string {
	string arg0;
	string arg1;
};

struct multi_return_int_int {
	int arg0;
	int arg1;
};

struct multi_return_u32_u32_u32 {
	u32 arg0;
	u32 arg1;
	u32 arg2;
};

struct multi_return_strconv__ParserState_strconv__PrepNumber {
	strconv__ParserState arg0;
	strconv__PrepNumber arg1;
};

struct multi_return_u64_int {
	u64 arg0;
	int arg1;
};

struct multi_return_i64_int {
	i64 arg0;
	int arg1;
};

struct multi_return_strconv__Dec32_bool {
	strconv__Dec32 arg0;
	bool arg1;
};

struct multi_return_strconv__Dec64_bool {
	strconv__Dec64 arg0;
	bool arg1;
};

struct multi_return_ref_C__sqlite3_stmt_int {
	struct sqlite3_stmt* arg0;
	int arg1;
};

struct multi_return_Array_net__http__Method_string_string {
	Array_net__http__Method arg0;
	string arg1;
	string arg2;
};

struct multi_return_Map_string_string_Map_string_Array_net__http__FileData {
	Map_string_string arg0;
	Map_string_Array_net__http__FileData arg1;
};

struct multi_return_u64_u64 {
	u64 arg0;
	u64 arg1;
};

struct multi_return_f64_int {
	f64 arg0;
	int arg1;
};

struct multi_return_string_orm__QueryData {
	string arg0;
	orm__QueryData arg1;
};

struct multi_return_int_int_int_int {
	int arg0;
	int arg1;
	int arg2;
	int arg3;
};

struct multi_return_int_int_int {
	int arg0;
	int arg1;
	int arg2;
};

struct multi_return_int_int_int_int_int_i64_bool {
	int arg0;
	int arg1;
	int arg2;
	int arg3;
	int arg4;
	i64 arg5;
	bool arg6;
};

struct multi_return_net__http__Method_net__urllib__URL_net__http__Version {
	net__http__Method arg0;
	net__urllib__URL arg1;
	net__http__Version arg2;
};

struct multi_return_string_int_string {
	string arg0;
	int arg1;
	string arg2;
};

struct multi_return_int_net__Addr {
	int arg0;
	net__Addr arg1;
};

struct multi_return_string_u16 {
	string arg0;
	u16 arg1;
};

struct multi_return_string_int {
	string arg0;
	int arg1;
};

struct multi_return_int_bool {
	int arg0;
	bool arg1;
};

struct multi_return_string_string_string {
	string arg0;
	string arg1;
	string arg2;
};

struct multi_return_f64_f64 {
	f64 arg0;
	f64 arg1;
};

struct multi_return_os__File_string {
	os__File arg0;
	string arg1;
};

struct multi_return_u64_u8 {
	u64 arg0;
	u8 arg1;
};

struct multi_return_ref_u16_ref_sync__Subscription {
	u16* arg0;
	sync__Subscription** arg1;
};

// END_multi_return_structs


typedef struct thread_arg_picoev__update_date_string {
	void (*fn) (picoev__Picoev*);
	picoev__Picoev* arg1;
} thread_arg_picoev__update_date_string;
static bool Array_u8_contains(Array_u8 a, u8 v); // auto
static bool Array_int_contains(Array_int a, int v); // auto
static bool Array_string_contains(Array_string a, string v); // auto
static bool Array_sql_db__PostFlag_contains(Array_sql_db__PostFlag a, sql_db__PostFlag v); // auto
static bool Array_net__http__Method_contains(Array_net__http__Method a, net__http__Method v); // auto

// V Option_xxx definitions:
struct _option_multi_return_string_string {
	byte state;
	IError err;
	byte data[sizeof(multi_return_string_string) > 1 ? sizeof(multi_return_string_string) : 1];
};

struct _option_u8 {
	byte state;
	IError err;
	byte data[sizeof(u8) > 1 ? sizeof(u8) : 1];
};

struct _option_bool {
	byte state;
	IError err;
	byte data[sizeof(bool) > 1 ? sizeof(bool) : 1];
};

struct _option_f32 {
	byte state;
	IError err;
	byte data[sizeof(f32) > 1 ? sizeof(f32) : 1];
};

struct _option_f64 {
	byte state;
	IError err;
	byte data[sizeof(f64) > 1 ? sizeof(f64) : 1];
};

struct _option_i8 {
	byte state;
	IError err;
	byte data[sizeof(i8) > 1 ? sizeof(i8) : 1];
};

struct _option_i16 {
	byte state;
	IError err;
	byte data[sizeof(i16) > 1 ? sizeof(i16) : 1];
};

struct _option_i64 {
	byte state;
	IError err;
	byte data[sizeof(i64) > 1 ? sizeof(i64) : 1];
};

struct _option_u16 {
	byte state;
	IError err;
	byte data[sizeof(u16) > 1 ? sizeof(u16) : 1];
};

struct _option_u32 {
	byte state;
	IError err;
	byte data[sizeof(u32) > 1 ? sizeof(u32) : 1];
};

struct _option_u64 {
	byte state;
	IError err;
	byte data[sizeof(u64) > 1 ? sizeof(u64) : 1];
};

struct _option_string {
	byte state;
	IError err;
	byte data[sizeof(string) > 1 ? sizeof(string) : 1];
};

struct _option_time__Time {
	byte state;
	IError err;
	byte data[sizeof(time__Time) > 1 ? sizeof(time__Time) : 1];
};

struct _option_db__sqlite__DB {
	byte state;
	IError err;
	byte data[sizeof(db__sqlite__DB) > 1 ? sizeof(db__sqlite__DB) : 1];
};

struct _option_net__Addr {
	byte state;
	IError err;
	byte data[sizeof(net__Addr) > 1 ? sizeof(net__Addr) : 1];
};

struct _option_net__http__Cookie {
	byte state;
	IError err;
	byte data[sizeof(net__http__Cookie) > 1 ? sizeof(net__http__Cookie) : 1];
};

struct _option_Array_string {
	byte state;
	IError err;
	byte data[sizeof(Array_string) > 1 ? sizeof(Array_string) : 1];
};

struct _option_veb__Context_ptr {
	byte state;
	IError err;
	byte data[sizeof(veb__Context*) > 1 ? sizeof(veb__Context*) : 1];
};

struct _option_veb__Route {
	byte state;
	IError err;
	byte data[sizeof(veb__Route) > 1 ? sizeof(veb__Route) : 1];
};


// V result_xxx definitions:
struct _result_string {
	bool is_error;
	IError err;
	byte data[sizeof(string) > 1 ? sizeof(string) : 1];
};

struct _result_void {
	bool is_error;
	IError err;
	byte data[sizeof(u8) > 1 ? sizeof(u8) : 1];
};

struct _result_int {
	bool is_error;
	IError err;
	byte data[sizeof(int) > 1 ? sizeof(int) : 1];
};

struct _result_net__mbedtls__SSLCerts_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__mbedtls__SSLCerts*) > 1 ? sizeof(net__mbedtls__SSLCerts*) : 1];
};

struct _result_u64 {
	bool is_error;
	IError err;
	byte data[sizeof(u64) > 1 ? sizeof(u64) : 1];
};

struct _result_i64 {
	bool is_error;
	IError err;
	byte data[sizeof(i64) > 1 ? sizeof(i64) : 1];
};

struct _result_rune {
	bool is_error;
	IError err;
	byte data[sizeof(rune) > 1 ? sizeof(rune) : 1];
};

struct _result_Array_string {
	bool is_error;
	IError err;
	byte data[sizeof(Array_string) > 1 ? sizeof(Array_string) : 1];
};

struct _result_net__urllib__URL {
	bool is_error;
	IError err;
	byte data[sizeof(net__urllib__URL) > 1 ? sizeof(net__urllib__URL) : 1];
};

struct _result_net__urllib__ParseAuthorityRes {
	bool is_error;
	IError err;
	byte data[sizeof(net__urllib__ParseAuthorityRes) > 1 ? sizeof(net__urllib__ParseAuthorityRes) : 1];
};

struct _result_bool {
	bool is_error;
	IError err;
	byte data[sizeof(bool) > 1 ? sizeof(bool) : 1];
};

struct _result_Array_Array_orm__Primitive {
	bool is_error;
	IError err;
	byte data[sizeof(Array_Array_orm__Primitive) > 1 ? sizeof(Array_Array_orm__Primitive) : 1];
};

struct _result_os__File {
	bool is_error;
	IError err;
	byte data[sizeof(os__File) > 1 ? sizeof(os__File) : 1];
};

struct _result_FILE_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(FILE*) > 1 ? sizeof(FILE*) : 1];
};

struct _result_strings__Builder {
	bool is_error;
	IError err;
	byte data[sizeof(strings__Builder) > 1 ? sizeof(strings__Builder) : 1];
};

struct _result_os__Stat {
	bool is_error;
	IError err;
	byte data[sizeof(os__Stat) > 1 ? sizeof(os__Stat) : 1];
};

struct _result_db__sqlite__Stmt {
	bool is_error;
	IError err;
	byte data[sizeof(db__sqlite__Stmt) > 1 ? sizeof(db__sqlite__Stmt) : 1];
};

struct _result_orm__Primitive {
	bool is_error;
	IError err;
	byte data[sizeof(orm__Primitive) > 1 ? sizeof(orm__Primitive) : 1];
};

struct _result_db__sqlite__DB {
	bool is_error;
	IError err;
	byte data[sizeof(db__sqlite__DB) > 1 ? sizeof(db__sqlite__DB) : 1];
};

struct _result_Array_db__sqlite__Row {
	bool is_error;
	IError err;
	byte data[sizeof(Array_db__sqlite__Row) > 1 ? sizeof(Array_db__sqlite__Row) : 1];
};

struct _result_Array_sql_db__Personal {
	bool is_error;
	IError err;
	byte data[sizeof(Array_sql_db__Personal) > 1 ? sizeof(Array_sql_db__Personal) : 1];
};

struct _result_Array_sql_db__PersonalFlag {
	bool is_error;
	IError err;
	byte data[sizeof(Array_sql_db__PersonalFlag) > 1 ? sizeof(Array_sql_db__PersonalFlag) : 1];
};

struct _result_Array_sql_db__Task {
	bool is_error;
	IError err;
	byte data[sizeof(Array_sql_db__Task) > 1 ? sizeof(Array_sql_db__Task) : 1];
};

struct _result_Array_sql_db__PostFlag {
	bool is_error;
	IError err;
	byte data[sizeof(Array_sql_db__PostFlag) > 1 ? sizeof(Array_sql_db__PostFlag) : 1];
};

struct _result_u32 {
	bool is_error;
	IError err;
	byte data[sizeof(u32) > 1 ? sizeof(u32) : 1];
};

struct _result_Array_net__Addr {
	bool is_error;
	IError err;
	byte data[sizeof(Array_net__Addr) > 1 ? sizeof(Array_net__Addr) : 1];
};

struct _result_multi_return_string_u16 {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_string_u16) > 1 ? sizeof(multi_return_string_u16) : 1];
};

struct _result_net__Addr {
	bool is_error;
	IError err;
	byte data[sizeof(net__Addr) > 1 ? sizeof(net__Addr) : 1];
};

struct _result_net__Connection {
	bool is_error;
	IError err;
	byte data[sizeof(net__Connection) > 1 ? sizeof(net__Connection) : 1];
};

struct _result_net__TcpConn_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__TcpConn*) > 1 ? sizeof(net__TcpConn*) : 1];
};

struct _result_net__TcpSocket {
	bool is_error;
	IError err;
	byte data[sizeof(net__TcpSocket) > 1 ? sizeof(net__TcpSocket) : 1];
};

struct _result_time__Time {
	bool is_error;
	IError err;
	byte data[sizeof(time__Time) > 1 ? sizeof(time__Time) : 1];
};

struct _result_u16 {
	bool is_error;
	IError err;
	byte data[sizeof(u16) > 1 ? sizeof(u16) : 1];
};

struct _result_picoev__EpollLoop_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(picoev__EpollLoop*) > 1 ? sizeof(picoev__EpollLoop*) : 1];
};

struct _result_picoev__Picoev_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(picoev__Picoev*) > 1 ? sizeof(picoev__Picoev*) : 1];
};

struct _result_net__mbedtls__SSLConn_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__mbedtls__SSLConn*) > 1 ? sizeof(net__mbedtls__SSLConn*) : 1];
};

struct _result_net__ssl__SSLConn_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__ssl__SSLConn*) > 1 ? sizeof(net__ssl__SSLConn*) : 1];
};

struct _result_Array_u8 {
	bool is_error;
	IError err;
	byte data[sizeof(Array_u8) > 1 ? sizeof(Array_u8) : 1];
};

struct _result_net__http__Header {
	bool is_error;
	IError err;
	byte data[sizeof(net__http__Header) > 1 ? sizeof(net__http__Header) : 1];
};

struct _result_net__http__Request {
	bool is_error;
	IError err;
	byte data[sizeof(net__http__Request) > 1 ? sizeof(net__http__Request) : 1];
};

struct _result_multi_return_net__http__Method_net__urllib__URL_net__http__Version {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_net__http__Method_net__urllib__URL_net__http__Version) > 1 ? sizeof(multi_return_net__http__Method_net__urllib__URL_net__http__Version) : 1];
};

struct _result_Array_veb__ControllerPath_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(Array_veb__ControllerPath_ptr) > 1 ? sizeof(Array_veb__ControllerPath_ptr) : 1];
};

struct _result_multi_return_Array_net__http__Method_string_string {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_Array_net__http__Method_string_string) > 1 ? sizeof(multi_return_Array_net__http__Method_string_string) : 1];
};

struct _result_multi_return_Map_string_string_Map_string_Array_net__http__FileData {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_Map_string_string_Map_string_Array_net__http__FileData) > 1 ? sizeof(multi_return_Map_string_string_Map_string_Array_net__http__FileData) : 1];
};

struct _result_Map_string_veb__Route {
	bool is_error;
	IError err;
	byte data[sizeof(Map_string_veb__Route) > 1 ? sizeof(Map_string_veb__Route) : 1];
};

struct _result_Array_main__Rank {
	bool is_error;
	IError err;
	byte data[sizeof(Array_main__Rank) > 1 ? sizeof(Array_main__Rank) : 1];
};

struct _result_main__Rank {
	bool is_error;
	IError err;
	byte data[sizeof(main__Rank) > 1 ? sizeof(main__Rank) : 1];
};

struct _result_Array_bool {
	bool is_error;
	IError err;
	byte data[sizeof(Array_bool) > 1 ? sizeof(Array_bool) : 1];
};


// V definitions:
static char * v_typeof_interface_IError(int sidx);
int v_typeof_interface_idx_IError(int sidx);
char * v_typeof_sumtype_orm__Primitive(int);
static char * v_typeof_interface_veb__ControllerInterface(int sidx);
int v_typeof_interface_idx_veb__ControllerInterface(int sidx);
static char * v_typeof_interface_veb__MiddlewareApp(int sidx);
int v_typeof_interface_idx_veb__MiddlewareApp(int sidx);
static char * v_typeof_interface_veb__HasBeforeRequest(int sidx);
int v_typeof_interface_idx_veb__HasBeforeRequest(int sidx);
static char * v_typeof_interface_veb__StaticApp(int sidx);
int v_typeof_interface_idx_veb__StaticApp(int sidx);
static char * v_typeof_interface_veb__BeforeAcceptApp(int sidx);
int v_typeof_interface_idx_veb__BeforeAcceptApp(int sidx);
static char * v_typeof_interface_orm__Connection(int sidx);
int v_typeof_interface_idx_orm__Connection(int sidx);
static char * v_typeof_interface_net__http__Downloader(int sidx);
int v_typeof_interface_idx_net__http__Downloader(int sidx);
static char * v_typeof_interface_net__http__Handler(int sidx);
int v_typeof_interface_idx_net__http__Handler(int sidx);
static char * v_typeof_interface_net__Connection(int sidx);
int v_typeof_interface_idx_net__Connection(int sidx);
static char * v_typeof_interface_net__Dialer(int sidx);
int v_typeof_interface_idx_net__Dialer(int sidx);
static char * v_typeof_interface_io__Reader(int sidx);
int v_typeof_interface_idx_io__Reader(int sidx);
static char * v_typeof_interface_io__Writer(int sidx);
int v_typeof_interface_idx_io__Writer(int sidx);
static char * v_typeof_interface_io__RandomReader(int sidx);
int v_typeof_interface_idx_io__RandomReader(int sidx);
static char * v_typeof_interface_io__ReaderWriter(int sidx);
int v_typeof_interface_idx_io__ReaderWriter(int sidx);
static char * v_typeof_interface_io__RandomWriter(int sidx);
int v_typeof_interface_idx_io__RandomWriter(int sidx);
static char * v_typeof_interface_rand__PRNG(int sidx);
int v_typeof_interface_idx_rand__PRNG(int sidx);
static char * v_typeof_interface_hash__Hash(int sidx);
int v_typeof_interface_idx_hash__Hash(int sidx);
static char * v_typeof_interface_hash__Hash32er(int sidx);
int v_typeof_interface_idx_hash__Hash32er(int sidx);
static char * v_typeof_interface_hash__Hash64er(int sidx);
int v_typeof_interface_idx_hash__Hash64er(int sidx);
// end of definitions #endif
strings__Builder strings__new_builder(int initial_size);
Array_u8 strings__Builder_reuse_as_plain_u8_array(strings__Builder* b);
void strings__Builder_write_ptr(strings__Builder* b, u8* ptr, int len);
void strings__Builder_write_rune(strings__Builder* b, rune r);
void strings__Builder_write_runes(strings__Builder* b, Array_rune runes);
void strings__Builder_write_u8(strings__Builder* b, u8 data);
void strings__Builder_write_byte(strings__Builder* b, u8 data);
void strings__Builder_write_decimal(strings__Builder* b, i64 n);
_result_int strings__Builder_write(strings__Builder* b, Array_u8 data);
void strings__Builder_drain_builder(strings__Builder* b, strings__Builder* other, int other_new_cap);
u8 strings__Builder_byte_at(strings__Builder* b, int n);
void strings__Builder_write_string(strings__Builder* b, string s);
void strings__Builder_write_string2(strings__Builder* b, string s1, string s2);
void strings__Builder_go_back(strings__Builder* b, int n);
string strings__Builder_spart(strings__Builder* b, int start_pos, int n);
string strings__Builder_cut_last(strings__Builder* b, int n);
string strings__Builder_cut_to(strings__Builder* b, int pos);
void strings__Builder_go_back_to(strings__Builder* b, int pos);
void strings__Builder_writeln(strings__Builder* b, string s);
void strings__Builder_writeln2(strings__Builder* b, string s1, string s2);
string strings__Builder_last_n(strings__Builder* b, int n);
string strings__Builder_after(strings__Builder* b, int n);
string strings__Builder_str(strings__Builder* b);
void strings__Builder_ensure_cap(strings__Builder* b, int n);
void strings__Builder_grow_len(strings__Builder* b, int n);
void strings__Builder_free(strings__Builder* b);
int math__bits__trailing_zeros_32(u32 x);
int math__bits__trailing_zeros_64(u64 x);
u32 math__bits__rotate_left_32(u32 x, int k);
int math__bits__len_32(u32 x);
multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y);
_result_u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size);
_result_i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOCAL_SYMBOL multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp);
VV_LOCAL_SYMBOL strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp);
string strconv__f32_to_str(f32 f, int n_digit);
VV_LOCAL_SYMBOL string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOCAL_SYMBOL multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp);
VV_LOCAL_SYMBOL strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp);
string strconv__f64_to_str(f64 f, int n_digit);
string strconv__f64_to_str_pad(f64 f, int n_digit);
void strconv__format_str_sb(string s, strconv__BF_param p, strings__Builder* sb);
void strconv__format_dec_sb(u64 d, strconv__BF_param p, strings__Builder* res);
string strconv__f64_to_str_lnd1(f64 f, int dec_digit);
string strconv__format_fl(f64 f, strconv__BF_param p);
string strconv__format_es(f64 f, strconv__BF_param p);
string strconv__remove_tail_zeros(string s);
string strconv__ftoa_64(f64 f);
string strconv__ftoa_32(f32 f);
string strconv__format_int(i64 n, int radix);
string strconv__format_uint(u64 n, int radix);
string strconv__f32_to_str_l(f32 f);
string strconv__f32_to_str_l_with_dot(f32 f);
string strconv__f64_to_str_l(f64 f);
string strconv__f64_to_str_l_with_dot(f64 f);
string strconv__fxx_to_str_l_parse(string s);
string strconv__fxx_to_str_l_parse_with_dot(string s);
VV_LOCAL_SYMBOL u32 strconv__bool_to_u32(bool b);
VV_LOCAL_SYMBOL u64 strconv__bool_to_u64(bool b);
VV_LOCAL_SYMBOL string strconv__get_string_special(bool neg, bool expZero, bool mantZero);
VV_LOCAL_SYMBOL u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift);
VV_LOCAL_SYMBOL u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j);
VV_LOCAL_SYMBOL u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j);
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_32(u32 i_v);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_32(u32 v, u32 p);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_32(u32 v, u32 p);
VV_LOCAL_SYMBOL u32 strconv__log10_pow2(int e);
VV_LOCAL_SYMBOL u32 strconv__log10_pow5(int e);
VV_LOCAL_SYMBOL int strconv__pow5_bits(int e);
VV_LOCAL_SYMBOL u64 strconv__shift_right_128(strconv__Uint128 v, int shift);
VV_LOCAL_SYMBOL u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift);
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_64(u64 v_i);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_64(u64 v, u32 p);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_64(u64 v, u32 p);
int strconv__dec_digits(u64 n);
VV_LOCAL_SYMBOL array __new_array(int mylen, int cap, int elm_size);
VV_LOCAL_SYMBOL array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val);
VV_LOCAL_SYMBOL array __new_array_with_multi_default(int mylen, int cap, int elm_size, voidptr val);
VV_LOCAL_SYMBOL array __new_array_with_array_default(int mylen, int cap, int elm_size, array val, int depth);
VV_LOCAL_SYMBOL array __new_array_with_map_default(int mylen, int cap, int elm_size, map val);
VV_LOCAL_SYMBOL array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array);
VV_LOCAL_SYMBOL void array_ensure_cap(array* a, int required);
VV_LOCAL_SYMBOL void array_insert_many(array* a, int i, voidptr val, int size);
VV_LOCAL_SYMBOL void array_prepend_many(array* a, voidptr val, int size);
void array_delete(array* a, int i);
void array_delete_many(array* a, int i, int size);
void array_clear(array* a);
void array_trim(array* a, int index);
VV_LOCAL_SYMBOL voidptr array_get_unsafe(array a, int i);
VV_LOCAL_SYMBOL voidptr array_get(array a, int i);
VV_LOCAL_SYMBOL voidptr array_get_with_check(array a, int i);
voidptr array_first(array a);
VV_LOCAL_SYMBOL array array_slice(array a, int start, int _end);
VV_LOCAL_SYMBOL array array_slice_ni(array a, int _start, int _end);
VV_LOCAL_SYMBOL array array_clone_static_to_depth(array a, int depth);
array array_clone(array* a);
array array_clone_to_depth(array* a, int depth);
VV_LOCAL_SYMBOL void array_set_unsafe(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_set(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_push(array* a, voidptr val);
void array_push_many(array* a, voidptr val, int size);
void array_free(array* a);
array array_filter(array a, bool (*predicate)(voidptr ));
array array_map(array a, voidptr (*callback)(voidptr ));
void array_sort(array* a, int (*callback)(voidptr , voidptr ));
void Array_string_free(Array_string* a);
string Array_string_str(Array_string a);
string Array_u8_hex(Array_u8 b);
int copy(Array_u8* dst, Array_u8 src);
Array_u8 voidptr_vbytes(voidptr data, int len);
Array_u8 u8_vbytes(u8* data, int len);
void u8_free(u8* data);
VV_LOCAL_SYMBOL void panic_on_negative_len(int len);
VV_LOCAL_SYMBOL void panic_on_negative_cap(int cap);
VV_LOCAL_SYMBOL array __new_array_noscan(int mylen, int cap, int elm_size);
VV_LOCAL_SYMBOL array __new_array_with_default_noscan(int mylen, int cap, int elm_size, voidptr val);
VV_LOCAL_SYMBOL array __new_array_with_multi_default_noscan(int mylen, int cap, int elm_size, voidptr val);
VV_LOCAL_SYMBOL array __new_array_with_array_default_noscan(int mylen, int cap, int elm_size, array val);
VV_LOCAL_SYMBOL array new_array_from_c_array_noscan(int len, int cap, int elm_size, voidptr c_array);
VV_LOCAL_SYMBOL void array_ensure_cap_noscan(array* a, int required);
VV_LOCAL_SYMBOL array array_repeat_to_depth_noscan(array a, int count, int depth);
VV_LOCAL_SYMBOL void array_insert_noscan(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_insert_many_noscan(array* a, int i, voidptr val, int size);
VV_LOCAL_SYMBOL void array_prepend_noscan(array* a, voidptr val);
VV_LOCAL_SYMBOL void array_prepend_many_noscan(array* a, voidptr val, int size);
VV_LOCAL_SYMBOL voidptr array_pop_noscan(array* a);
VV_LOCAL_SYMBOL array array_clone_static_to_depth_noscan(array a, int depth);
VV_LOCAL_SYMBOL array array_clone_to_depth_noscan(array* a, int depth);
VV_LOCAL_SYMBOL void array_push_noscan(array* a, voidptr val);
VV_LOCAL_SYMBOL void array_push_many_noscan(array* a, voidptr val, int size);
VV_LOCAL_SYMBOL array array_reverse_noscan(array a);
VV_LOCAL_SYMBOL void array_grow_cap_noscan(array* a, int amount);
VV_LOCAL_SYMBOL void array_grow_len_noscan(array* a, int amount);
void print_backtrace(void);
bool print_backtrace_skipping_top_frames(int xskipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_linux(int skipframes);
VV_LOCAL_SYMBOL void v_segmentation_fault_handler(i32 signal_number);
void _v_exit(int code);
_result_void at_exit(void (*cb)());
void panic_option_not_set(string s);
void panic_result_not_set(string s);
string vcurrent_hash(void);
void _v_panic(string s);
string c_error_number_str(int errnum);
void panic_n(string s, i64 number1);
void panic_n2(string s, i64 number1, i64 number2);
VV_LOCAL_SYMBOL void panic_n3(string s, i64 number1, i64 number2, i64 number3);
void panic_error_number(string basestr, int errnum);
void eprintln(string s);
void eprint(string s);
void flush_stdout(void);
void flush_stderr(void);
void print(string s);
void println(string s);
VV_LOCAL_SYMBOL void _writeln_to_fd(int fd, string s);
VV_LOCAL_SYMBOL void _write_buf_to_fd(int fd, u8* buf, int buf_len);
VV_LOCAL_SYMBOL void _memory_panic(string fname, isize size);
u8* _v_malloc(isize n);
u8* malloc_noscan(isize n);
VV_LOCAL_SYMBOL u64 __at_least_one(u64 how_many);
u8* malloc_uncollectable(isize n);
u8* v_realloc(u8* b, isize n);
u8* realloc_data(u8* old_data, int old_size, int new_size);
u8* vcalloc(isize n);
u8* vcalloc_noscan(isize n);
void _v_free(voidptr ptr);
voidptr memdup(voidptr src, isize sz);
voidptr memdup_noscan(voidptr src, isize sz);
voidptr memdup_uncollectable(voidptr src, isize sz);
VV_LOCAL_SYMBOL int v_fixed_index(int i, int len);
Array_string arguments(void);
bool isnil(voidptr v);
VV_LOCAL_SYMBOL voidptr __as_cast(voidptr obj, int obj_type, int expected_type);
void VAssertMetaInfo_free(VAssertMetaInfo* ami);
VV_LOCAL_SYMBOL void __print_assert_failure(VAssertMetaInfo* i);
void gc_set_warn_proc(void (*cb)(char* msg, usize arg));
VV_LOCAL_SYMBOL void internal_gc_warn_proc_none(char* msg, usize arg);
VV_LOCAL_SYMBOL void builtin_init(void);
int vstrlen(u8* s);
int vstrlen_char(char* s);
voidptr vmemcpy(voidptr dest, const voidptr const_src, isize n);
voidptr vmemmove(voidptr dest, const voidptr const_src, isize n);
int vmemcmp(const voidptr const_s1, const voidptr const_s2, isize n);
voidptr vmemset(voidptr s, int c, isize n);
string f64_str(f64 x);
string f64_strg(f64 x);
string float_literal_str(float_literal d);
string f32_str(f32 x);
string f32_strg(f32 x);
f32 f32_abs(f32 a);
f64 f64_abs(f64 a);
f64 f64_max(f64 a, f64 b);
string ptr_str(voidptr ptr);
string isize_str(isize x);
string usize_str(usize x);
string char_str(char* cptr);
VV_LOCAL_SYMBOL string int_str_l(int nn, int max);
string i8_str(i8 n);
string i16_str(i16 n);
string u16_str(u16 n);
string i32_str(i32 n);
string int_str(int n);
string u32_str(u32 nn);
string int_literal_str(int_literal n);
string i64_str(i64 nn);
string u64_str(u64 nn);
string bool_str(bool b);
VV_LOCAL_SYMBOL string u64_to_hex_no_leading_zeros(u64 nn, u8 len);
string u64_hex(u64 nn);
string voidptr_str(voidptr nn);
string byteptr_str(byteptr nn);
string charptr_str(charptr nn);
string u8_str(u8 b);
string u8_ascii_str(u8 b);
string Array_u8_bytestr(Array_u8 b);
VV_LOCAL_SYMBOL string _Atomic__int_str(int x);
VV_LOCAL_SYMBOL bool fast_string_eq(string a, string b);
VV_LOCAL_SYMBOL u64 map_hash_string(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_1(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_2(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_4(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_8(voidptr pkey);
VV_LOCAL_SYMBOL void DenseArray_zeros_to_end(DenseArray* d);
VV_LOCAL_SYMBOL DenseArray new_dense_array(int key_bytes, int value_bytes);
VV_LOCAL_SYMBOL voidptr DenseArray_key(DenseArray* d, int i);
VV_LOCAL_SYMBOL voidptr DenseArray_value(DenseArray* d, int i);
VV_LOCAL_SYMBOL bool DenseArray_has_index(DenseArray* d, int i);
VV_LOCAL_SYMBOL int DenseArray_expand(DenseArray* d);
VV_LOCAL_SYMBOL bool map_eq_string(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_1(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_2(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_4(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_8(voidptr a, voidptr b);
VV_LOCAL_SYMBOL void map_clone_string(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_1(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_2(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_4(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_8(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_free_string(voidptr pkey);
VV_LOCAL_SYMBOL void map_free_nop(voidptr _d1);
VV_LOCAL_SYMBOL map new_map(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
VV_LOCAL_SYMBOL map new_map_init(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
VV_LOCAL_SYMBOL map new_map_update_init(map* update, int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
map map_move(map* m);
void map_clear(map* m);
VV_LOCAL_SYMBOL multi_return_u32_u32 map_key_to_index(map* m, voidptr pkey);
VV_LOCAL_SYMBOL multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas);
VV_LOCAL_SYMBOL void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi);
VV_LOCAL_SYMBOL void map_ensure_extra_metas(map* m, u32 probe_count);
VV_LOCAL_SYMBOL void map_set(map* m, voidptr key, voidptr value);
VV_LOCAL_SYMBOL void map_expand(map* m);
VV_LOCAL_SYMBOL void map_rehash(map* m);
void map_reserve(map* m, u32 meta_bytes);
VV_LOCAL_SYMBOL void map_cached_rehash(map* m, u32 old_cap);
VV_LOCAL_SYMBOL voidptr map_get_and_set(map* m, voidptr key, voidptr zero);
VV_LOCAL_SYMBOL voidptr map_get(map* m, voidptr key, voidptr zero);
VV_LOCAL_SYMBOL voidptr map_get_check(map* m, voidptr key);
VV_LOCAL_SYMBOL bool map_exists(map* m, voidptr key);
VV_LOCAL_SYMBOL void DenseArray_delete(DenseArray* d, int i);
void map_delete(map* m, voidptr key);
array map_keys(map* m);
array map_values(map* m);
VV_LOCAL_SYMBOL DenseArray DenseArray_clone(DenseArray* d);
map map_clone(map* m);
void map_free(map* m);
VV_LOCAL_SYMBOL u8* __malloc_at_least_one(u64 how_many_bytes, bool noscan);
VV_LOCAL_SYMBOL DenseArray new_dense_array_noscan(int key_bytes, bool key_noscan, int value_bytes, bool value_noscan);
VV_LOCAL_SYMBOL map new_map_noscan_key(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
VV_LOCAL_SYMBOL map new_map_noscan_value(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
VV_LOCAL_SYMBOL map new_map_noscan_key_value(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
VV_LOCAL_SYMBOL map new_map_init_noscan_key(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
VV_LOCAL_SYMBOL map new_map_init_noscan_value(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
VV_LOCAL_SYMBOL map new_map_init_noscan_key_value(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
void IError_free(IError* ie);
VV_LOCAL_SYMBOL void _option_none(voidptr data, _option* option, int size);
VV_LOCAL_SYMBOL void _option_ok(voidptr data, _option* option, int size);
VV_LOCAL_SYMBOL void _option_clone(_option* current, _option* option, int size);
VV_LOCAL_SYMBOL string None___str(None__ _d1);
string none_str(none _d1);
VV_LOCAL_SYMBOL void _result_ok(voidptr data, _result* res, int size);
string IError_str(IError err);
string Error_msg(Error err);
int Error_code(Error err);
string MessageError_str(MessageError err);
string MessageError_msg(MessageError err);
int MessageError_code(MessageError err);
void MessageError_free(MessageError* err);
IError _v_error(string message);
IError error_with_code(string message, int code);
string rune_str(rune c);
string Array_rune_string(Array_rune ra);
rune rune_to_upper(rune c);
rune rune_to_lower(rune c);
VV_LOCAL_SYMBOL rune rune_map_to(rune c, MapMode mode);
VV_LOCAL_SYMBOL void mapnode_free(mapnode* n);
void SortedMap_free(SortedMap* m);
Array_rune string_runes(string s);
string cstring_to_vstring(const char* const_s);
string tos_clone(const u8* const_s);
string tos(u8* s, int len);
string tos2(u8* s);
string tos3(char* s);
string tos4(u8* s);
string tos5(char* s);
string u8_vstring(u8* bp);
string u8_vstring_with_len(u8* bp, int len);
string char_vstring(char* cp);
string u8_vstring_literal_with_len(u8* bp, int len);
string char_vstring_literal_with_len(char* cp, int len);
bool string_is_pure_ascii(string s);
VV_LOCAL_SYMBOL string string_clone_static(string a);
string string_clone(string a);
string string_replace(string s, string rep, string with);
string string_replace_each(string s, Array_string vals);
int string_int(string s);
i64 string_i64(string s);
u8 string_u8(string s);
u64 string_u64(string s);
VV_LOCAL_SYMBOL bool string__eq(string s, string a);
VV_LOCAL_SYMBOL bool string__lt(string s, string a);
VV_LOCAL_SYMBOL string string__plus(string s, string a);
Array_string string_split(string s, string delim);
_option_multi_return_string_string string_split_once(string s, string delim);
Array_string string_split_nth(string s, string delim, int nth);
string string_substr(string s, int start, int _end);
string string_substr_unsafe(string s, int start, int _end);
_result_string string_substr_with_check(string s, int start, int _end);
string string_substr_ni(string s, int _start, int _end);
VV_LOCAL_SYMBOL int string_index_(string s, string p);
_option_int string_index(string s, string p);
_option_int string_last_index(string s, string needle);
VV_LOCAL_SYMBOL int string_index_kmp(string s, string p);
int string_index_any(string s, string chars);
VV_LOCAL_SYMBOL int string_index_last_(string s, string p);
_option_int string_index_after(string s, string p, int start);
int string_index_after_(string s, string p, int start);
int string_index_u8(string s, u8 c);
int string_last_index_u8(string s, u8 c);
int string_count(string s, string substr);
bool string_contains_u8(string s, u8 x);
bool string_contains(string s, string substr);
bool string_contains_only(string s, string chars);
bool string_starts_with(string s, string p);
bool string_ends_with(string s, string p);
string string_to_lower_ascii(string s);
string string_to_lower(string s);
string string_to_upper_ascii(string s);
string string_to_upper(string s);
string string_capitalize(string s);
string string_trim_space(string s);
string string_trim(string s, string cutset);
VV_LOCAL_SYMBOL string string_trim_chars(string s, string cutset, TrimMode mode);
VV_LOCAL_SYMBOL string string_trim_runes(string s, string cutset, TrimMode mode);
string string_trim_left(string s, string cutset);
string string_trim_right(string s, string cutset);
string string_str(string s);
VV_LOCAL_SYMBOL u8 string_at(string s, int idx);
VV_LOCAL_SYMBOL _option_u8 string_at_with_check(string s, int idx);
bool u8_is_space(u8 c);
bool u8_is_digit(u8 c);
bool u8_is_letter(u8 c);
bool u8_is_alnum(u8 c);
void string_free(string* s);
string string_all_before(string s, string sub);
string string_all_before_last(string s, string sub);
string string_all_after(string s, string sub);
string string_all_after_last(string s, string sub);
string Array_string_join(Array_string a, string sep);
Array_u8 string_bytes(string s);
string string_repeat(string s, int count);
bool string_match_glob(string name, string pattern);
VV_LOCAL_SYMBOL string data_to_hex_string(u8* data, int len);
string byteptr_vstring(byteptr bp);
string byteptr_vstring_with_len(byteptr bp, int len);
string charptr_vstring(charptr cp);
string charptr_vstring_with_len(charptr cp, int len);
string byteptr_vstring_literal(byteptr bp);
string charptr_vstring_literal(charptr cp);
string StrIntpType_str(StrIntpType x);
VV_LOCAL_SYMBOL f32 fabs32(f32 x);
VV_LOCAL_SYMBOL f64 fabs64(f64 x);
VV_LOCAL_SYMBOL u64 abs64(i64 x);
VV_LOCAL_SYMBOL void StrIntpData_process_str_intp_data(StrIntpData* data, strings__Builder* sb);
string str_intp(int data_len, StrIntpData* input_base);
int utf8_char_len(u8 b);
string utf32_to_str(u32 code);
string utf32_to_str_no_malloc(u32 code, u8* buf);
int utf32_decode_to_buffer(u32 code, u8* buf);
int string_utf32_code(string _rune);
_result_rune Array_u8_utf8_to_utf32(Array_u8 _bytes);
int utf8_str_visible_length(string s);
bool ArrayFlags_has(ArrayFlags* e, ArrayFlags flag_);
bool ArrayFlags_all(ArrayFlags* e, ArrayFlags flag_);
void ArrayFlags_set(ArrayFlags* e, ArrayFlags flag_);
void ArrayFlags_clear(ArrayFlags* e, ArrayFlags flag_);
string json__encode(voidptr x);
string json__encode_pretty(voidptr x);
VV_LOCAL_SYMBOL int json__decode_int(struct cJSON* root);
VV_LOCAL_SYMBOL i8 json__decode_i8(struct cJSON* root);
VV_LOCAL_SYMBOL i16 json__decode_i16(struct cJSON* root);
VV_LOCAL_SYMBOL i64 json__decode_i64(struct cJSON* root);
VV_LOCAL_SYMBOL u8 json__decode_byte(struct cJSON* root);
VV_LOCAL_SYMBOL u8 json__decode_u8(struct cJSON* root);
VV_LOCAL_SYMBOL u16 json__decode_u16(struct cJSON* root);
VV_LOCAL_SYMBOL u32 json__decode_u32(struct cJSON* root);
VV_LOCAL_SYMBOL u64 json__decode_u64(struct cJSON* root);
VV_LOCAL_SYMBOL f32 json__decode_f32(struct cJSON* root);
VV_LOCAL_SYMBOL f64 json__decode_f64(struct cJSON* root);
VV_LOCAL_SYMBOL rune json__decode_rune(struct cJSON* root);
VV_LOCAL_SYMBOL string json__decode_string(struct cJSON* root);
VV_LOCAL_SYMBOL bool json__decode_bool(struct cJSON* root);
VV_LOCAL_SYMBOL struct cJSON* json__encode_int(int val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_i8(i8 val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_i16(i16 val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_i64(i64 val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_byte(u8 root);
VV_LOCAL_SYMBOL struct cJSON* json__encode_u8(u8 val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_u16(u16 val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_u32(u32 val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_u64(u64 val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_f32(f32 val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_f64(f64 val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_bool(bool val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_rune(rune val);
VV_LOCAL_SYMBOL struct cJSON* json__encode_string(string val);
VV_LOCAL_SYMBOL struct cJSON* json__json_parse(string s);
VV_LOCAL_SYMBOL string json__json_print(struct cJSON* data);
VV_LOCAL_SYMBOL string json__json_print_pretty(struct cJSON* data);
VV_LOCAL_SYMBOL int encoding__base64__encode_from_buffer(u8* dest, u8* src, int src_len);
int encoding__base64__decode_in_buffer(string* data, u8* buffer);
VV_LOCAL_SYMBOL int encoding__base64__decode_from_buffer(u8* dest, u8* src, int src_len);
string encoding__base64__decode_str(string data);
string encoding__base64__encode_str(string data);
VV_LOCAL_SYMBOL string encoding__base64__alloc_and_encode(u8* src, int len);
string encoding__base64__url_decode_str(string data);
string encoding__base64__url_encode_str(string data);
VV_LOCAL_SYMBOL u64 encoding__base64__assemble64(u8 n1, u8 n2, u8 n3, u8 n4, u8 n5, u8 n6, u8 n7, u8 n8);
VV_LOCAL_SYMBOL u32 encoding__base64__assemble32(u8 n1, u8 n2, u8 n3, u8 n4);
i64 time__Duration_nanoseconds(time__Duration d);
i64 time__Duration_microseconds(time__Duration d);
i64 time__Duration_milliseconds(time__Duration d);
f64 time__Duration_seconds(time__Duration d);
string time__Duration_str(time__Duration d);
VV_LOCAL_SYMBOL void time__int_to_byte_array_no_pad(int value, Array_u8* arr, int size);
string time__Time_format_ss(time__Time t);
string time__Time_http_header_string(time__Time t);
bool time__Time__eq(time__Time t1, time__Time t2);
bool time__Time__lt(time__Time t1, time__Time t2);
time__Duration time__Time__minus(time__Time lhs, time__Time rhs);
string time__TimeParseError_msg(time__TimeParseError err);
time__StopWatch time__new_stopwatch(time__StopWatchOptions opts);
void time__StopWatch_start(time__StopWatch* t);
time__Duration time__StopWatch_elapsed(time__StopWatch t);
time__Time time__now(void);
time__Time time__utc(void);
VV_LOCAL_SYMBOL time__Time time__time_with_unix(time__Time t);
i64 time__ticks(void);
string time__Time_str(time__Time t);
VV_LOCAL_SYMBOL time__Time time__convert_ctime(struct tm t, int nanosecond);
string time__Time_smonth(time__Time t);
i64 time__Time_unix(time__Time t);
time__Time time__Time_add(time__Time t, time__Duration duration_in_nanosecond);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time t);
string time__Time_weekday_str(time__Time t);
time__Time time__Time_as_local(time__Time t);
VV_LOCAL_SYMBOL i64 time__make_unix_time(struct tm t);
u64 time__sys_mono_now(void);
VV_LOCAL_SYMBOL time__Time time__linux_now(void);
VV_LOCAL_SYMBOL time__Time time__linux_utc(void);
struct timespec time__Duration_timespec(time__Duration d);
void time__sleep(time__Duration duration);
time__Time time__unix(i64 epoch);
time__Time time__unix_nanosecond(i64 abs_unix_timestamp, int nanosecond);
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_date_from_day_offset(i64 day_offset_);
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_time_from_second_offset(i64 second_offset_);
VV_LOCAL_SYMBOL string net__urllib__error_msg(string message, string val);
VV_LOCAL_SYMBOL bool net__urllib__should_escape(u8 c, net__urllib__EncodingMode mode);
_result_string net__urllib__query_unescape(string s);
VV_LOCAL_SYMBOL _result_string net__urllib__unescape(string s_, net__urllib__EncodingMode mode);
VV_LOCAL_SYMBOL string net__urllib__escape(string s, net__urllib__EncodingMode mode);
net__urllib__Userinfo* net__urllib__user(string username);
VV_LOCAL_SYMBOL net__urllib__Userinfo* net__urllib__user_password(string username, string password);
VV_LOCAL_SYMBOL bool net__urllib__Userinfo_empty(net__urllib__Userinfo* u);
VV_LOCAL_SYMBOL string net__urllib__Userinfo_str(net__urllib__Userinfo* u);
VV_LOCAL_SYMBOL _result_Array_string net__urllib__split_by_scheme(string rawurl);
VV_LOCAL_SYMBOL multi_return_string_string net__urllib__split(string s, u8 sep, bool cutc);
_result_net__urllib__URL net__urllib__parse(string rawurl);
VV_LOCAL_SYMBOL _result_net__urllib__URL net__urllib__parse_url(string rawurl, bool via_request);
VV_LOCAL_SYMBOL _result_net__urllib__ParseAuthorityRes net__urllib__parse_authority(string authority);
VV_LOCAL_SYMBOL _result_string net__urllib__parse_host(string host);
_result_bool net__urllib__URL_set_path(net__urllib__URL* u, string p);
string net__urllib__URL_escaped_path(net__urllib__URL* u);
VV_LOCAL_SYMBOL bool net__urllib__valid_encoded_path(string s);
VV_LOCAL_SYMBOL bool net__urllib__valid_optional_port(string port);
string net__urllib__URL_str(net__urllib__URL u);
VV_LOCAL_SYMBOL net__urllib__Values net__urllib__parse_query_silent(string query);
VV_LOCAL_SYMBOL _result_bool net__urllib__parse_query_values(net__urllib__Values* m, string query);
net__urllib__Values net__urllib__URL_query(net__urllib__URL* u);
multi_return_string_string net__urllib__split_host_port(string hostport);
bool net__urllib__valid_userinfo(string s);
VV_LOCAL_SYMBOL bool net__urllib__string_contains_ctl_u8(string s);
bool net__urllib__ishex(u8 c);
VV_LOCAL_SYMBOL u8 net__urllib__unhex(u8 c);
net__urllib__Values net__urllib__new_values(void);
void net__urllib__Values_add(net__urllib__Values* v, string key, string value);
io__BufferedReader* io__new_buffered_reader(io__BufferedReaderConfig o);
_result_int io__BufferedReader_read(io__BufferedReader* r, Array_u8* buf);
void io__BufferedReader_free(io__BufferedReader* r);
VV_LOCAL_SYMBOL bool io__BufferedReader_fill_buffer(io__BufferedReader* r);
VV_LOCAL_SYMBOL bool io__BufferedReader_needs_fill(io__BufferedReader r);
bool io__BufferedReader_end_of_stream(io__BufferedReader r);
_result_string io__BufferedReader_read_line(io__BufferedReader* r, io__BufferedReadLineConfig config);
int io__BufferedWriter_buffered(io__BufferedWriter b);
_result_void io__BufferedWriter_flush(io__BufferedWriter* b);
int io__BufferedWriter_available(io__BufferedWriter b);
_result_int io__BufferedWriter_write(io__BufferedWriter* b, Array_u8 src);
_result_int io__MultiWriter_write(io__MultiWriter* m, Array_u8 buf);
VV_LOCAL_SYMBOL string io__NotExpected_msg(io__NotExpected err);
VV_LOCAL_SYMBOL int io__NotExpected_code(io__NotExpected err);
_result_int io__ReaderWriterImpl_read(io__ReaderWriterImpl* r, Array_u8* buf);
_result_int io__ReaderWriterImpl_write(io__ReaderWriterImpl* r, Array_u8 buf);
Array_string arrays__uniq_T_string(Array_string a);
u16 net__conv__hton16(u16 host);
u16 net__conv__ntoh16(u16 net);
u16 net__conv__reverse_bytes_u16(u16 a);
void strings__textscanner__TextScanner_free(strings__textscanner__TextScanner* ss);
term__termios__TcFlag term__termios__invert(term__termios__TcFlag value);
int term__termios__tcgetattr(int fd, term__termios__Termios* termios_p);
int term__termios__tcsetattr(int fd, int optional_actions, term__termios__Termios* termios_p);
int term__termios__set_state(int fd, term__termios__Termios new_state);
void term__termios__Termios_disable_echo(term__termios__Termios* t);
VV_LOCAL_SYMBOL void picohttpparser__Request_phr_parse_request_path(picohttpparser__Request* r, u8* buf_start, u8* buf_end, picohttpparser__Pret* pret);
VV_LOCAL_SYMBOL u8* picohttpparser__Request_phr_parse_request(picohttpparser__Request* r, u8* buf_start, u8* buf_end, picohttpparser__Pret* pret);
VV_LOCAL_SYMBOL u8* picohttpparser__Request_parse_headers(picohttpparser__Request* r, u8* buf_start, u8* buf_end, picohttpparser__Pret* pret);
VV_LOCAL_SYMBOL u8* picohttpparser__is_complete(u8* buf_start, u8* buf_end, int last_len, picohttpparser__Pret* pret);
VV_LOCAL_SYMBOL int picohttpparser__parse_http_version(u8* buf_start, u8* buf_end, picohttpparser__Pret* pret);
VV_LOCAL_SYMBOL int picohttpparser__get_token_length_to_eol(u8* buf_start, u8* buf_end, picohttpparser__Pret* pret);
VV_LOCAL_SYMBOL string picohttpparser__advance_token(u8* tok_start, u8* tok_end, picohttpparser__Pret* pret);
VV_LOCAL_SYMBOL bool picohttpparser__is_printable_ascii(u8 c);
_result_int picohttpparser__Request_parse_request(picohttpparser__Request* r, string s);
int picohttpparser__Response_end(picohttpparser__Response* r);
void encoding__binary__big_endian_put_u32(Array_u8* b, u32 v);
void encoding__binary__big_endian_put_u64(Array_u8* b, u64 v);
u64 hash__wymum(u64 a, u64 b);
VV_LOCAL_SYMBOL string orm__OperationKind_to_str(orm__OperationKind kind);
VV_LOCAL_SYMBOL bool orm__OperationKind_is_unary(orm__OperationKind kind);
VV_LOCAL_SYMBOL string orm__OrderType_to_str(orm__OrderType kind);
multi_return_string_orm__QueryData orm__orm_stmt_gen(orm__SQLDialect sql_dialect, string table, string q, orm__StmtKind kind, bool num, string qm, int start_pos, orm__QueryData data, orm__QueryData where);
string orm__orm_select_gen(orm__SelectConfig cfg, string q, bool num, string qm, int start_pos, orm__QueryData where);
VV_LOCAL_SYMBOL string orm__gen_where_clause(orm__QueryData where, string q, string qm, bool num, int* c);
_result_string orm__orm_table_gen(string table, string q, bool defaults, int def_unique_len, Array_orm__TableField fields, _result_string (*sql_from_v)(int ), bool alternative);
VV_LOCAL_SYMBOL int orm__sql_field_type(orm__TableField field);
VV_LOCAL_SYMBOL string orm__sql_field_name(orm__TableField field);
VV_LOCAL_SYMBOL orm__Primitive orm__bool_to_primitive(bool b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_bool_to_primitive(_option_bool b);
VV_LOCAL_SYMBOL orm__Primitive orm__f32_to_primitive(f32 b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_f32_to_primitive(_option_f32 b);
VV_LOCAL_SYMBOL orm__Primitive orm__f64_to_primitive(f64 b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_f64_to_primitive(_option_f64 b);
VV_LOCAL_SYMBOL orm__Primitive orm__i8_to_primitive(i8 b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_i8_to_primitive(_option_i8 b);
VV_LOCAL_SYMBOL orm__Primitive orm__i16_to_primitive(i16 b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_i16_to_primitive(_option_i16 b);
VV_LOCAL_SYMBOL orm__Primitive orm__int_to_primitive(int b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_int_to_primitive(_option_int b);
VV_LOCAL_SYMBOL orm__Primitive orm__int_literal_to_primitive(int b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_int_literal_to_primitive(_option_int b);
VV_LOCAL_SYMBOL orm__Primitive orm__float_literal_to_primitive(f64 b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_float_literal_to_primitive(_option_f64 b);
VV_LOCAL_SYMBOL orm__Primitive orm__i64_to_primitive(i64 b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_i64_to_primitive(_option_i64 b);
VV_LOCAL_SYMBOL orm__Primitive orm__u8_to_primitive(u8 b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_u8_to_primitive(_option_u8 b);
VV_LOCAL_SYMBOL orm__Primitive orm__u16_to_primitive(u16 b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_u16_to_primitive(_option_u16 b);
VV_LOCAL_SYMBOL orm__Primitive orm__u32_to_primitive(u32 b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_u32_to_primitive(_option_u32 b);
VV_LOCAL_SYMBOL orm__Primitive orm__u64_to_primitive(u64 b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_u64_to_primitive(_option_u64 b);
VV_LOCAL_SYMBOL orm__Primitive orm__string_to_primitive(string b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_string_to_primitive(_option_string b);
VV_LOCAL_SYMBOL orm__Primitive orm__time_to_primitive(time__Time b);
VV_LOCAL_SYMBOL orm__Primitive orm__option_time_to_primitive(_option_time__Time b);
VV_LOCAL_SYMBOL orm__Primitive orm__infix_to_primitive(orm__InfixType b);
VV_LOCAL_SYMBOL string orm__factory_insert_qm_value(bool num, string qm, int c);
string os__getenv(string key);
_option_string os__getenv_opt(string key);
int os__fd_close(int fd);
VV_LOCAL_SYMBOL string os__NotExpected_msg(os__NotExpected err);
VV_LOCAL_SYMBOL int os__NotExpected_code(os__NotExpected err);
_result_os__File os__open(string path);
_result_os__File os__create(string path);
_result_int os__File_read(os__File* f, Array_u8* buf);
_result_int os__File_write(os__File* f, Array_u8 buf);
_result_void os__File_write_full_buffer(os__File* f, voidptr buffer, usize buffer_len);
VV_LOCAL_SYMBOL _result_int os__fread(voidptr ptr, int item_size, int items, FILE* stream);
_result_int os__File_read_from(os__File* f, u64 pos, Array_u8* buf);
string os__FileNotOpenedError_msg(os__FileNotOpenedError err);
string os__SizeOfTypeIs0Error_msg(os__SizeOfTypeIs0Error err);
VV_LOCAL_SYMBOL IError os__error_file_not_opened(void);
_result_void os__File_seek(os__File* f, i64 pos, os__SeekMode mode);
_result_i64 os__File_tell(os__File* f);
VV_LOCAL_SYMBOL _result_int os__find_cfile_size(FILE* fp);
VV_LOCAL_SYMBOL _result_strings__Builder os__slurp_file_in_builder(FILE* fp);
_result_string os__read_file(string path);
_result_FILE_ptr os__vfopen(string path, string mode);
int os__fileno(voidptr cfile);
VV_LOCAL_SYMBOL multi_return_int_bool os__posix_wait4_to_exit_status(int waitret);
string os__posix_get_error_msg(int code);
int os__system(string cmd);
bool os__exists(string path);
_result_void os__rm(string path);
VV_LOCAL_SYMBOL void os__print_c_errno(void);
string os__get_raw_line(void);
string os__getwd(void);
void os__flush(void);
int os__is_atty(int fd);
IError os__last_error(void);
IError os__error_posix(os__SystemError e);
void os__Result_free(os__Result* result);
string os__sigint_to_signal_name(int si);
string os__file_ext(string opath);
string os__base(string path);
string os__file_name(string path);
_option_string os__input_opt(string prompt);
string os__input(string prompt);
_result_void os__write_file(string path, string text);
string os__ExecutableNotFoundError_msg(os__ExecutableNotFoundError err);
string os__join_path(string base, Array_string dirs);
VV_LOCAL_SYMBOL void os__normalize_path_in_builder(strings__Builder* sb);
_result_Array_string os__ls(string path);
void os__File_close(os__File* f);
_result_string os__input_password(string prompt);
void os__Process_close(os__Process* p);
void os__Process_free(os__Process* p);
_result_os__Stat os__stat(string path);
os__FileType os__Stat_get_filetype(os__Stat st);
bool os__is_dir(string path);
string encoding__html__escape(string input, encoding__html__EscapeConfig config);
void crypto__sha256__Digest_free(crypto__sha256__Digest* d);
VV_LOCAL_SYMBOL void crypto__sha256__Digest_init(crypto__sha256__Digest* d);
void crypto__sha256__Digest_reset(crypto__sha256__Digest* d);
VV_LOCAL_SYMBOL crypto__sha256__Digest* crypto__sha256__Digest_clone(crypto__sha256__Digest* d);
crypto__sha256__Digest* crypto__sha256__new(void);
_result_int crypto__sha256__Digest_write(crypto__sha256__Digest* d, Array_u8 p_);
Array_u8 crypto__sha256__Digest_sum(crypto__sha256__Digest* d, Array_u8 b_in);
VV_LOCAL_SYMBOL Array_u8 crypto__sha256__Digest_checksum(crypto__sha256__Digest* d);
Array_u8 crypto__sha256__sum(Array_u8 data);
Array_u8 crypto__sha256__sum256(Array_u8 data);
VV_LOCAL_SYMBOL void crypto__sha256__block(crypto__sha256__Digest* dig, Array_u8 p);
int crypto__sha256__Digest_size(crypto__sha256__Digest* d);
int crypto__sha256__Digest_block_size(crypto__sha256__Digest* d);
VV_LOCAL_SYMBOL void crypto__sha256__block_generic(crypto__sha256__Digest* dig, Array_u8 p_);
VV_LOCAL_SYMBOL u32 rand__seed__nr_next(u32 prev);
Array_u32 rand__seed__time_seed_array(int count);
u64 rand__seed__time_seed_64(void);
_result_Array_Array_orm__Primitive db__sqlite__DB_select(db__sqlite__DB _v_toheap_db, orm__SelectConfig config, orm__QueryData data, orm__QueryData where);
_result_void db__sqlite__DB_insert(db__sqlite__DB _v_toheap_db, string table, orm__QueryData data);
_result_void db__sqlite__DB_update(db__sqlite__DB _v_toheap_db, string table, orm__QueryData data, orm__QueryData where);
_result_void db__sqlite__DB_delete(db__sqlite__DB _v_toheap_db, string table, orm__QueryData where);
int db__sqlite__DB_last_id(db__sqlite__DB _v_toheap_db);
_result_void db__sqlite__DB_create(db__sqlite__DB _v_toheap_db, string table, Array_orm__TableField fields);
_result_void db__sqlite__DB_drop(db__sqlite__DB _v_toheap_db, string table);
VV_LOCAL_SYMBOL _result_void db__sqlite__sqlite_stmt_worker(db__sqlite__DB _v_toheap_db, string query, orm__QueryData data, orm__QueryData where);
VV_LOCAL_SYMBOL _result_void db__sqlite__sqlite_stmt_binder(db__sqlite__Stmt _v_toheap_stmt, orm__QueryData d, string query, int* c);
VV_LOCAL_SYMBOL int db__sqlite__bind(db__sqlite__Stmt _v_toheap_stmt, int* c, orm__Primitive data);
VV_LOCAL_SYMBOL _result_orm__Primitive db__sqlite__Stmt_sqlite_select_column(db__sqlite__Stmt _v_toheap_stmt, int idx, int typ);
VV_LOCAL_SYMBOL _result_string db__sqlite__sqlite_type_from_v(int typ);
string db__sqlite__DB_str(db__sqlite__DB* db);
_result_db__sqlite__DB db__sqlite__connect(string path);
_result_int db__sqlite__DB_q_int(db__sqlite__DB* db, string query);
_result_Array_db__sqlite__Row db__sqlite__DB_exec(db__sqlite__DB* db, string query);
IError db__sqlite__DB_error_message(db__sqlite__DB* db, int code, string query);
_result_void db__sqlite__DB_synchronization_mode(db__sqlite__DB* db, db__sqlite__SyncMode sync_mode);
_result_void db__sqlite__DB_journal_mode(db__sqlite__DB* db, db__sqlite__JournalMode journal_mode);
VV_LOCAL_SYMBOL multi_return_ref_C__sqlite3_stmt_int db__sqlite__DB_init_stmt(db__sqlite__DB* db, string query);
VV_LOCAL_SYMBOL _result_db__sqlite__Stmt db__sqlite__DB_new_init_stmt(db__sqlite__DB* db, string query);
VV_LOCAL_SYMBOL int db__sqlite__Stmt_bind_null(db__sqlite__Stmt* stmt, int idx);
VV_LOCAL_SYMBOL int db__sqlite__Stmt_bind_int(db__sqlite__Stmt* stmt, int idx, int v);
VV_LOCAL_SYMBOL int db__sqlite__Stmt_bind_i64(db__sqlite__Stmt* stmt, int idx, i64 v);
VV_LOCAL_SYMBOL int db__sqlite__Stmt_bind_f64(db__sqlite__Stmt* stmt, int idx, f64 v);
VV_LOCAL_SYMBOL int db__sqlite__Stmt_bind_text(db__sqlite__Stmt* stmt, int idx, string s);
VV_LOCAL_SYMBOL _option_int db__sqlite__Stmt_get_int(db__sqlite__Stmt* stmt, int idx);
VV_LOCAL_SYMBOL _option_i64 db__sqlite__Stmt_get_i64(db__sqlite__Stmt* stmt, int idx);
VV_LOCAL_SYMBOL _option_f64 db__sqlite__Stmt_get_f64(db__sqlite__Stmt* stmt, int idx);
VV_LOCAL_SYMBOL _option_string db__sqlite__Stmt_get_text(db__sqlite__Stmt* stmt, int idx);
VV_LOCAL_SYMBOL int db__sqlite__Stmt_step(db__sqlite__Stmt* stmt);
VV_LOCAL_SYMBOL _result_void db__sqlite__Stmt_orm_step(db__sqlite__Stmt* stmt, string query);
VV_LOCAL_SYMBOL void db__sqlite__Stmt_finalize(db__sqlite__Stmt* stmt);
VV_LOCAL_SYMBOL string cmd__CmdOption_options(cmd__CmdOption long_option, Array_string args);
VV_LOCAL_SYMBOL bool cmd__CmdOption_set_options(cmd__CmdOption long_option, Array_string args);
VV_LOCAL_SYMBOL bool cmd__is_options(Array_string args, Array_cmd__CmdOption long_options, string abr);
VV_LOCAL_SYMBOL string cmd__return_args(Array_string args);
cmd__CmdSet cmd__start(string version);
VV_LOCAL_SYMBOL void cmd__help(Array_cmd__CmdOption long_options, string version);
string err_log__sha256_str(string data);
void err_log__logs(string data);
int runtime__nr_jobs(void);
int runtime__nr_cpus(void);
void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, Array_u32 seed_data);
u8 rand__wyrand__WyRandRNG_u8(rand__wyrand__WyRandRNG* rng);
u16 rand__wyrand__WyRandRNG_u16(rand__wyrand__WyRandRNG* rng);
u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng);
u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng);
int rand__wyrand__WyRandRNG_block_size(rand__wyrand__WyRandRNG* rng);
void rand__wyrand__WyRandRNG_free(rand__wyrand__WyRandRNG* rng);
VV_LOCAL_SYMBOL db__sqlite__DB sql_db__connect(void);
_option_db__sqlite__DB sql_db__connect_db(bool set_nohup, string args);
Array_sql_db__Personal sql_db__get_personal(db__sqlite__DB _v_toheap_db);
Array_sql_db__Task sql_db__find_challenge(db__sqlite__DB _v_toheap_db);
bool sql_db__bool_solve(sql_db__PersonalFlag pf);
int sql_db__challenge_score(db__sqlite__DB _v_toheap_db, sql_db__PersonalFlag pf);
VV_LOCAL_SYMBOL void sql_db__create_db(db__sqlite__DB _v_toheap_db);
void sql_db__test_main_function(db__sqlite__DB* db);
VV_LOCAL_SYMBOL Array_sql_db__Personal sql_db__personal_err(void);
sql_db__StatusReturn sql_db__login_status(db__sqlite__DB _v_toheap_db, string c_id, string c_pwd);
sql_db__StatusReturn sql_db__login_root_status(db__sqlite__DB _v_toheap_db, string c_id, string c_pwd);
sql_db__StatusReturn sql_db__select_passwd_db(db__sqlite__DB _v_toheap_db, string ip, string email, string passwd);
bool sql_db__register_status(db__sqlite__DB _v_toheap_db, string id, string email, string passwd);
bool sql_db__register_db(db__sqlite__DB _v_toheap_db, string id, string email, string passwd);
bool sql_db__id_check(db__sqlite__DB _v_toheap_db, string c_id, string oldpasswd, string newpasswd);
VV_LOCAL_SYMBOL Array_sql_db__Task sql_db__challenge_err(void);
VV_LOCAL_SYMBOL Array_sql_db__Task sql_db__challenge_db(db__sqlite__DB _v_toheap_db, string i);
Array_sql_db__Type sql_db__build_challenge(db__sqlite__DB _v_toheap_db);
bool sql_db__post_flag(db__sqlite__DB _v_toheap_db, string ip, int tid, string flag, int pid);
sql_db__Personal sql_db__find_user(db__sqlite__DB _v_toheap_db, string id, string pwd);
VV_LOCAL_SYMBOL void rand__deinit(void);
VV_LOCAL_SYMBOL void rand__init(void);
_result_u32 rand__PRNG_u32n(rand__PRNG* rng, u32 max);
_result_int rand__PRNG_intn(rand__PRNG* rng, int max);
rand__PRNG* rand__new_default(rand__config__PRNGConfigStruct config_);
_result_int rand__intn(int max);
VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st(u32 n, u32 st);
VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st_noscan(u32 n, u32 st);
string sync__Channel_auto_str(sync__Channel* ch, string __v_typename);
void sync__Channel_close(sync__Channel* ch);
int sync__Channel_len(sync__Channel* ch);
bool sync__Channel_closed(sync__Channel* ch);
void sync__Channel_push(sync__Channel* ch, voidptr src);
ChanState sync__Channel_try_push(sync__Channel* ch, voidptr src);
VV_LOCAL_SYMBOL ChanState sync__Channel_try_push_priv(sync__Channel* ch, voidptr src, bool no_block);
bool sync__Channel_pop(sync__Channel* ch, voidptr dest);
ChanState sync__Channel_try_pop(sync__Channel* ch, voidptr dest);
VV_LOCAL_SYMBOL ChanState sync__Channel_try_pop_priv(sync__Channel* ch, voidptr dest, bool no_block);
int sync__channel_select(Array_sync__Channel_ptr* channels, Array_sync__Direction dir, Array_voidptr* objrefs, time__Duration timeout);
string sync__Mutex_str(sync__Mutex* m);
string sync__RwMutex_str(sync__RwMutex* m);
VV_LOCAL_SYMBOL void sync__cpanic(int res);
VV_LOCAL_SYMBOL void sync__cpanic_errno(void);
VV_LOCAL_SYMBOL void sync__should_be_zero(int res);
void sync__WaitGroup_init(sync__WaitGroup* wg);
void sync__Mutex_init(sync__Mutex* m);
void sync__RwMutex_init(sync__RwMutex* m);
void sync__Mutex_lock(sync__Mutex* m);
void sync__Mutex_unlock(sync__Mutex* m);
void sync__RwMutex_rlock(sync__RwMutex* m);
void sync__RwMutex_lock(sync__RwMutex* m);
void sync__RwMutex_runlock(sync__RwMutex* m);
void sync__RwMutex_unlock(sync__RwMutex* m);
void sync__Semaphore_init(sync__Semaphore* sem, u32 n);
void sync__Semaphore_post(sync__Semaphore* sem);
void sync__Semaphore_wait(sync__Semaphore* sem);
bool sync__Semaphore_try_wait(sync__Semaphore* sem);
bool sync__Semaphore_timed_wait(sync__Semaphore* sem, time__Duration timeout);
void sync__Semaphore_destroy(sync__Semaphore* sem);
net__Addr net__new_ip6(u16 port, Array_fixed_u8_16 addr);
net__Addr net__new_ip(u16 port, Array_fixed_u8_4 addr);
net__AddrFamily net__Addr_family(net__Addr a);
string net__Ip_str(net__Ip a);
string net__Ip6_str(net__Ip6 a);
u32 net__Addr_len(net__Addr a);
_result_Array_net__Addr net__resolve_addrs(string addr, net__AddrFamily family, net__SocketType typ);
_result_Array_net__Addr net__resolve_addrs_fuzzy(string addr, net__SocketType typ);
_result_Array_net__Addr net__resolve_ipaddrs(string addr, net__AddrFamily family, net__SocketType typ);
string net__Addr_str(net__Addr a);
net__Addr net__addr_from_socket_handle(int handle);
_result_net__Addr net__peer_addr_from_socket_handle(int handle);
int net__shutdown(int handle, net__ShutdownConfig config);
_result_void net__close(int handle);
VV_LOCAL_SYMBOL _result_bool net__select(int handle, net__Select test, time__Duration timeout);
VV_LOCAL_SYMBOL _result_bool net__select_deadline(int handle, net__Select test, time__Time deadline);
VV_LOCAL_SYMBOL _result_void net__wait_for_common(int handle, time__Time deadline, time__Duration timeout, net__Select test);
VV_LOCAL_SYMBOL _result_void net__wait_for_write(int handle, time__Time deadline, time__Duration timeout);
VV_LOCAL_SYMBOL _result_void net__wait_for_read(int handle, time__Time deadline, time__Duration timeout);
_result_int net__socket_error_message(int potential_code, string s);
_result_int net__socket_error(int potential_code);
_result_void net__wrap_error(int error_code);
int net__error_code(void);
VV_LOCAL_SYMBOL void net__init(void);
_result_net__Addr net__Socket_address(net__Socket* s);
_result_net__Connection net__TCPDialer_dial(net__TCPDialer t, string address);
_result_net__TcpConn_ptr net__dial_tcp(string oaddress);
_result_void net__TcpConn_close(net__TcpConn* c);
_result_int net__TcpConn_read_ptr(net__TcpConn _v_toheap_c, u8* buf_ptr, int len);
_result_int net__TcpConn_read(net__TcpConn _v_toheap_c, Array_u8* buf);
_result_time__Time net__TcpConn_read_deadline(net__TcpConn* c);
_result_int net__TcpConn_write_ptr(net__TcpConn* c, u8* b, int len);
_result_int net__TcpConn_write(net__TcpConn* c, Array_u8 bytes);
_result_int net__TcpConn_write_string(net__TcpConn* c, string s);
_result_time__Time net__TcpConn_write_deadline(net__TcpConn* c);
time__Duration net__TcpConn_read_timeout(net__TcpConn* c);
void net__TcpConn_set_read_timeout(net__TcpConn* c, time__Duration t);
time__Duration net__TcpConn_write_timeout(net__TcpConn* c);
void net__TcpConn_set_write_timeout(net__TcpConn* c, time__Duration t);
_result_void net__TcpConn_wait_for_read(net__TcpConn _v_toheap_c);
_result_void net__TcpConn_wait_for_write(net__TcpConn* c);
_result_net__Addr net__TcpConn_peer_addr(net__TcpConn* c);
_result_string net__TcpConn_peer_ip(net__TcpConn* c);
_result_net__Addr net__TcpConn_addr(net__TcpConn* c);
string net__TcpConn_str(net__TcpConn _v_toheap_c);
_result_net__TcpSocket net__new_tcp_socket(net__AddrFamily family);
net__TcpSocket net__tcp_socket_from_handle_raw(int sockfd);
VV_LOCAL_SYMBOL _result_void net__TcpSocket_set_option(net__TcpSocket* s, int level, int opt, int value);
_result_void net__TcpSocket_set_option_int(net__TcpSocket* s, net__SocketOption opt, int value);
VV_LOCAL_SYMBOL _result_void net__TcpSocket_set_default_options(net__TcpSocket* s);
VV_LOCAL_SYMBOL _result_void net__TcpSocket_close(net__TcpSocket* s);
VV_LOCAL_SYMBOL _result_void net__TcpSocket_connect(net__TcpSocket* s, net__Addr a);
_result_int net__UdpConn_write_ptr(net__UdpConn* c, u8* b, int len);
_result_int net__UdpConn_write(net__UdpConn* c, Array_u8 buf);
_result_int net__UdpConn_write_to_ptr(net__UdpConn* c, net__Addr addr, u8* b, int len);
_result_time__Time net__UdpConn_write_deadline(net__UdpConn* c);
time__Duration net__UdpConn_write_timeout(net__UdpConn* c);
_result_void net__UdpConn_wait_for_write(net__UdpConn* c);
string net__UdpConn_str(net__UdpConn* c);
_option_net__Addr net__UdpSocket_remote(net__UdpSocket* s);
_result_u16 net__validate_port(int port);
_result_multi_return_string_u16 net__split_address(string addr);
_result_picoev__EpollLoop_ptr picoev__create_epoll_loop(int id);
VV_LOCAL_SYMBOL int picoev__Picoev_update_events(picoev__Picoev* pv, int fd, int events);
VV_LOCAL_SYMBOL int picoev__Picoev_poll_once(picoev__Picoev* pv, int max_wait_in_sec);
void picoev__Picoev_init(picoev__Picoev* pv);
int picoev__Picoev_add(picoev__Picoev* pv, int fd, int events, int timeout, voidptr callback);
int picoev__Picoev_delete(picoev__Picoev* pv, int fd);
VV_LOCAL_SYMBOL int picoev__Picoev_loop_once(picoev__Picoev* pv, int max_wait_in_sec);
VV_LOCAL_SYMBOL void picoev__Picoev_set_timeout(picoev__Picoev* pv, int fd, int secs);
VV_LOCAL_SYMBOL void picoev__Picoev_handle_timeout(picoev__Picoev* pv);
VV_LOCAL_SYMBOL void picoev__accept_callback(int listen_fd, int events, voidptr cb_arg);
void picoev__Picoev_close_conn(picoev__Picoev* pv, int fd);
VV_LOCAL_SYMBOL void picoev__raw_callback(int fd, int events, voidptr context);
VV_LOCAL_SYMBOL void picoev__default_error_callback(voidptr data, picohttpparser__Request req, picohttpparser__Response* res, IError __v_error);
_result_picoev__Picoev_ptr picoev__new(picoev__Config config);
void picoev__Picoev_serve(picoev__Picoev* pv);
VV_LOCAL_SYMBOL void picoev__update_date_string(picoev__Picoev* pv);
VV_LOCAL_SYMBOL i64 picoev__get_time(void);
VV_LOCAL_SYMBOL int picoev__accept(int fd);
VV_LOCAL_SYMBOL void picoev__close_socket(int fd);
VV_LOCAL_SYMBOL _result_void picoev__setup_sock(int fd);
VV_LOCAL_SYMBOL int picoev__req_read(int fd, u8* buffer, int max_len, int offset);
VV_LOCAL_SYMBOL bool picoev__fatal_socket_error(int fd);
VV_LOCAL_SYMBOL _result_int picoev__listen(picoev__Config config);
VV_LOCAL_SYMBOL void net__mbedtls__init(void);
net__mbedtls__SSLCerts* net__mbedtls__new_sslcerts(void);
_result_net__mbedtls__SSLCerts_ptr net__mbedtls__new_sslcerts_in_memory(string verify, string cert, string cert_key);
_result_net__mbedtls__SSLCerts_ptr net__mbedtls__new_sslcerts_from_file(string verify, string cert, string cert_key);
void net__mbedtls__SSLCerts_cleanup(net__mbedtls__SSLCerts* c);
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLListener_init(net__mbedtls__SSLListener* l);
VV_LOCAL_SYMBOL void net__mbedtls__SSLListener_init_sni(net__mbedtls__SSLListener* l, _result_net__mbedtls__SSLCerts_ptr (*get_cert_callback)(net__mbedtls__SSLListener* , string ));
struct _V_anon_fn_2d57aea9634ebb26_voidptr_c__mbedtls_ssl_context_char_int__int_6734_Ctx {
	_result_net__mbedtls__SSLCerts_ptr (*get_cert_callback) (net__mbedtls__SSLListener*, string);
	net__mbedtls__SSLListener* l;
};

struct _V_anon_fn_2d57aea9634ebb26_voidptr_c__mbedtls_ssl_context_char_int__int_6734_Ctx;
VV_LOCAL_SYMBOL int anon_fn_2d57aea9634ebb26_voidptr_c__mbedtls_ssl_context_char_int__int_6734(voidptr p_info, mbedtls_ssl_context* ssl, char* name, int lng);
_result_net__mbedtls__SSLConn_ptr net__mbedtls__new_ssl_conn(net__mbedtls__SSLConnectConfig config);
_result_void net__mbedtls__SSLConn_close(net__mbedtls__SSLConn* s);
_result_void net__mbedtls__SSLConn_shutdown(net__mbedtls__SSLConn* s);
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_init(net__mbedtls__SSLConn* s);
_result_void net__mbedtls__SSLConn_connect(net__mbedtls__SSLConn* s, net__TcpConn* tcp_conn, string hostname);
_result_void net__mbedtls__SSLConn_dial(net__mbedtls__SSLConn* s, string hostname, int port);
_result_net__Addr net__mbedtls__SSLConn_addr(net__mbedtls__SSLConn* s);
_result_net__Addr net__mbedtls__SSLConn_peer_addr(net__mbedtls__SSLConn* s);
_result_int net__mbedtls__SSLConn_socket_read_into_ptr(net__mbedtls__SSLConn* s, u8* buf_ptr, int len);
_result_int net__mbedtls__SSLConn_read(net__mbedtls__SSLConn* s, Array_u8* buffer);
_result_int net__mbedtls__SSLConn_write_ptr(net__mbedtls__SSLConn* s, u8* bytes, int len);
_result_int net__mbedtls__SSLConn_write(net__mbedtls__SSLConn* s, Array_u8 bytes);
_result_int net__mbedtls__SSLConn_write_string(net__mbedtls__SSLConn* s, string str);
VV_LOCAL_SYMBOL _result_bool net__mbedtls__select(int handle, net__mbedtls__Select test, time__Duration timeout);
VV_LOCAL_SYMBOL _result_void net__mbedtls__wait_for(int handle, net__mbedtls__Select what, time__Duration timeout);
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_wait_for_write(net__mbedtls__SSLConn* s, time__Duration timeout);
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_wait_for_read(net__mbedtls__SSLConn* s, time__Duration timeout);
_result_net__Connection net__ssl__SSLDialer_dial(net__ssl__SSLDialer d, string address);
_result_net__ssl__SSLConn_ptr net__ssl__new_ssl_conn(net__ssl__SSLConnectConfig config);
_result_net__Connection net__socks__SOCKS5Dialer_dial(net__socks__SOCKS5Dialer sd, string address);
VV_LOCAL_SYMBOL _result_net__Connection net__socks__handshake(net__Connection* con, string host, string username, string password);
VV_LOCAL_SYMBOL string net__socks__reply(u8 code);
VV_LOCAL_SYMBOL _result_Array_u8 net__socks__parse_ipv4(string addr);
Array_net__http__Cookie_ptr net__http__read_cookies(net__http__Header h, string filter);
string net__http__Cookie_str(net__http__Cookie* c);
VV_LOCAL_SYMBOL string net__http__sanitize(bool (*valid)(u8 ), string v);
string net__http__sanitize_cookie_value(string v);
VV_LOCAL_SYMBOL string net__http__sanitize_cookie_path(string v);
VV_LOCAL_SYMBOL bool net__http__valid_cookie_value_byte(u8 b);
VV_LOCAL_SYMBOL bool net__http__valid_cookie_path_byte(u8 b);
VV_LOCAL_SYMBOL bool net__http__valid_cookie_domain(string v);
bool net__http__is_cookie_domain_name(string _s);
VV_LOCAL_SYMBOL _result_string net__http__parse_cookie_value(string _raw, bool allow_double_quote);
VV_LOCAL_SYMBOL bool net__http__is_cookie_name_valid(string name);
_result_void net__http__SilentStreamingDownloader_on_start(net__http__SilentStreamingDownloader* d, net__http__Request* request, string path);
_result_void net__http__SilentStreamingDownloader_on_chunk(net__http__SilentStreamingDownloader* d, net__http__Request* request, Array_u8 chunk, u64 already_received, u64 expected);
_result_void net__http__SilentStreamingDownloader_on_finish(net__http__SilentStreamingDownloader* d, net__http__Request* request, net__http__Response* response);
_result_void net__http__TerminalStreamingDownloader_on_start(net__http__TerminalStreamingDownloader* d, net__http__Request* request, string path);
_result_void net__http__TerminalStreamingDownloader_on_chunk(net__http__TerminalStreamingDownloader* d, net__http__Request* request, Array_u8 chunk, u64 already_received, u64 expected);
_result_void net__http__TerminalStreamingDownloader_on_finish(net__http__TerminalStreamingDownloader* d, net__http__Request* request, net__http__Response* response);
string net__http__CommonHeader_str(net__http__CommonHeader h);
void net__http__Header_free(net__http__Header* h);
net__http__Header net__http__new_header(Array_net__http__HeaderConfig kvs);
_result_net__http__Header net__http__new_custom_header_from_map(Map_string_string kvs);
void net__http__Header_add(net__http__Header* h, net__http__CommonHeader key, string value);
_result_void net__http__Header_add_custom(net__http__Header* h, string key, string value);
_result_void net__http__Header_add_custom_map(net__http__Header* h, Map_string_string kvs);
void net__http__Header_set(net__http__Header* h, net__http__CommonHeader key, string value);
_result_void net__http__Header_set_custom(net__http__Header* h, string key, string value);
bool net__http__Header_contains(net__http__Header h, net__http__CommonHeader key);
_result_string net__http__Header_get(net__http__Header h, net__http__CommonHeader key);
_result_string net__http__Header_get_custom(net__http__Header h, string key, net__http__HeaderQueryConfig flags);
Array_string net__http__Header_values(net__http__Header h, net__http__CommonHeader key);
Array_string net__http__Header_custom_values(net__http__Header h, string key, net__http__HeaderQueryConfig flags);
Array_string net__http__Header_keys(net__http__Header h);
string net__http__Header_render(net__http__Header h, net__http__HeaderRenderConfig flags);
void net__http__Header_render_into_sb(net__http__Header h, strings__Builder* sb, net__http__HeaderRenderConfig flags);
net__http__Header net__http__Header_join(net__http__Header h, net__http__Header other);
VV_LOCAL_SYMBOL string net__http__canonicalize(string name);
string net__http__HeaderKeyError_msg(net__http__HeaderKeyError err);
int net__http__HeaderKeyError_code(net__http__HeaderKeyError err);
VV_LOCAL_SYMBOL _result_void net__http__is_valid(string header);
VV_LOCAL_SYMBOL bool net__http__is_token(u8 b);
string net__http__Header_str(net__http__Header h);
VV_LOCAL_SYMBOL _result_int net__http__parse_header_fast(string s);
string net__http__Method_str(net__http__Method m);
net__http__Method net__http__method_from_str(string m);
VV_LOCAL_SYMBOL void net__http__Request_free(net__http__Request* req);
_option_net__http__Cookie net__http__Request_cookie(net__http__Request* req, string name);
_result_net__http__Request net__http__parse_request_head(io__BufferedReader* reader);
VV_LOCAL_SYMBOL _result_multi_return_net__http__Method_net__urllib__URL_net__http__Version net__http__parse_request_line(string s);
Map_string_string net__http__parse_form(string body);
string net__http__UnexpectedExtraAttributeError_msg(net__http__UnexpectedExtraAttributeError err);
string net__http__MultiplePathAttributesError_msg(net__http__MultiplePathAttributesError err);
multi_return_Map_string_string_Map_string_Array_net__http__FileData net__http__parse_multipart_form(string body, string boundary);
VV_LOCAL_SYMBOL Map_string_string net__http__parse_disposition(string line);
VV_LOCAL_SYMBOL void net__http__Response_free(net__http__Response* resp);
Array_u8 net__http__Response_bytes(net__http__Response resp);
string net__http__Response_bytestr(net__http__Response resp);
void net__http__Response_set_status(net__http__Response* r, net__http__Status s);
net__http__Version net__http__Response_version(net__http__Response r);
void net__http__Response_set_version(net__http__Response* r, net__http__Version v);
net__http__Response net__http__new_response(net__http__ResponseConfig conf);
VV_LOCAL_SYMBOL net__http__Response net__http__DebugHandler_handle(net__http__DebugHandler d, net__http__Request req);
string net__http__Status_str(net__http__Status code);
int net__http__Status_int(net__http__Status code);
VV_LOCAL_SYMBOL multi_return_int_int net__http__fast_request_words(string line);
string net__http__Version_str(net__http__Version v);
net__http__Version net__http__version_from_str(string v);
multi_return_int_int net__http__Version_protos(net__http__Version v);
_result_string veb__Context_get_header(veb__Context* ctx, net__http__CommonHeader key);
_result_string veb__Context_get_custom_header(veb__Context* ctx, string key);
void veb__Context_set_header(veb__Context* ctx, net__http__CommonHeader key, string value);
_result_void veb__Context_set_custom_header(veb__Context* ctx, string key, string value);
veb__Result veb__Context_send_response_to_client(veb__Context* ctx, string mimetype, string response);
veb__Result veb__Context_html(veb__Context* ctx, string s);
veb__Result veb__Context_text(veb__Context* ctx, string s);
veb__Result veb__Context_file(veb__Context* ctx, string file_path);
VV_LOCAL_SYMBOL veb__Result veb__Context_send_file(veb__Context* ctx, string content_type, string file_path);
veb__Result veb__Context_ok(veb__Context* ctx, string s);
veb__Result veb__Context_request_error(veb__Context* ctx, string msg);
veb__Result veb__Context_server_error(veb__Context* ctx, string msg);
veb__Result veb__Context_server_error_with_status(veb__Context* ctx, net__http__Status s);
veb__Result veb__Context_no_content(veb__Context* ctx);
veb__Result veb__Context_redirect(veb__Context* ctx, string url, veb__RedirectParams params);
veb__Result veb__Context_before_request(veb__Context* ctx);
veb__Result veb__Context_not_found(veb__Context* ctx);
_option_string veb__Context_get_cookie(veb__Context* ctx, string key);
void veb__Context_set_cookie(veb__Context* ctx, net__http__Cookie cookie);
void veb__Context_set_content_type(veb__Context* ctx, string mime);
void veb__Context_takeover_conn(veb__Context* ctx);
string veb__Context_user_agent(veb__Context* ctx);
string veb__Context_ip(veb__Context* ctx);
VV_LOCAL_SYMBOL _result_Array_veb__ControllerPath_ptr veb__check_duplicate_routes_in_controllers_T_main__App(main__App* global_app, Map_string_veb__Route routes);
VV_LOCAL_SYMBOL string veb__filter(string s);
string veb__Middleware_T_main__Context_str_T_main__Context(veb__Middleware_T_main__Context* m);
void veb__Middleware_T_main__Context_use_T_main__Context(veb__Middleware_T_main__Context* m, veb__MiddlewareOptions_T_main__Context options);
void veb__Middleware_T_main__Context_route_use_T_main__Context(veb__Middleware_T_main__Context* m, string route, veb__MiddlewareOptions_T_main__Context options);
VV_LOCAL_SYMBOL Array_voidptr veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(veb__Middleware_T_main__Context* m, string route_path);
VV_LOCAL_SYMBOL Array_voidptr veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(veb__Middleware_T_main__Context* m, string route_path);
VV_LOCAL_SYMBOL Array_voidptr veb__Middleware_T_main__Context_get_global_handlers_T_main__Context(veb__Middleware_T_main__Context* m);
VV_LOCAL_SYMBOL Array_voidptr veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(veb__Middleware_T_main__Context* m);
VV_LOCAL_SYMBOL bool veb__validate_middleware_T_main__Context(main__Context* ctx, Array_voidptr raw_handlers);
void veb__CorsOptions_set_headers(veb__CorsOptions* options, veb__Context* ctx);
bool veb__CorsOptions_validate_request(veb__CorsOptions* options, veb__Context* ctx);
veb__MiddlewareOptions_T_main__Context veb__cors_T_main__Context(veb__CorsOptions options);
struct _V_anon_fn_ccb961b82e6b9984_mut_t__bool_9654_T_main__Context_Ctx {
	veb__CorsOptions options;
};

struct _V_anon_fn_ccb961b82e6b9984_mut_t__bool_9654_T_main__Context_Ctx;
VV_LOCAL_SYMBOL bool anon_fn_ccb961b82e6b9984_mut_t__bool_9654_T_main__Context(main__Context* ctx);
VV_LOCAL_SYMBOL _result_multi_return_Array_net__http__Method_string_string veb__parse_attrs(string name, Array_string attrs);
VV_LOCAL_SYMBOL Map_string_string veb__parse_query_from_url(net__urllib__URL url);
VV_LOCAL_SYMBOL _result_multi_return_Map_string_string_Map_string_Array_net__http__FileData veb__parse_form_from_request(net__http__Request request);
VV_LOCAL_SYMBOL int veb__sendfile(int out_fd, int in_fd, int nr_bytes);
VV_LOCAL_SYMBOL _result_void veb__StaticHandler_scan_static_directory(veb__StaticHandler* sh, string directory_path, string mount_path, string host);
_result_bool veb__StaticHandler_handle_static(veb__StaticHandler* sh, string directory_path, bool root);
_result_bool veb__StaticHandler_host_handle_static(veb__StaticHandler* sh, string host, string directory_path, bool root);
_result_void veb__StaticHandler_host_serve_static(veb__StaticHandler* sh, string host, string url, string file_path);
veb__Result veb__no_result(void);
VV_LOCAL_SYMBOL _result_Map_string_veb__Route veb__generate_routes_T_main__App_main__Context(main__App* app);
void veb__FileResponse_done(veb__FileResponse* fr);
void veb__StringResponse_done(veb__StringResponse* sr);
void veb__RequestParams_request_done(veb__RequestParams* params, int fd);
_result_void veb__run_at_T_main__App_main__Context(main__App* global_app, veb__RunParams params);
VV_LOCAL_SYMBOL void veb__ev_callback_T_main__App_main__Context(picoev__Picoev* pv, int fd, int events);
VV_LOCAL_SYMBOL void veb__handle_timeout(picoev__Picoev* pv, veb__RequestParams* params, int fd);
VV_LOCAL_SYMBOL void veb__handle_write_file(picoev__Picoev* pv, veb__RequestParams* params, int fd);
VV_LOCAL_SYMBOL void veb__handle_write_string(picoev__Picoev* pv, veb__RequestParams* params, int fd);
VV_LOCAL_SYMBOL void veb__handle_read_T_main__App_main__Context(picoev__Picoev* pv, veb__RequestParams* params, int fd);
VV_LOCAL_SYMBOL void veb__handle_complete_request(bool should_close, picoev__Picoev* pv, int fd);
VV_LOCAL_SYMBOL _option_veb__Context_ptr veb__handle_request_T_main__App_main__Context(net__TcpConn* conn, net__http__Request req, veb__RequestParams* params);
VV_LOCAL_SYMBOL void veb__handle_route_T_main__App_main__Context(main__App* app, main__Context* user_context, net__urllib__URL url, string host, Map_string_veb__Route* routes);
VV_LOCAL_SYMBOL _option_Array_string veb__route_matches(Array_string url_words, Array_string route_words);
VV_LOCAL_SYMBOL bool veb__serve_if_static_T_main__App_main__Context(main__App* app, main__Context* user_context, net__urllib__URL url, string host);
VV_LOCAL_SYMBOL _result_void veb__send_string(net__TcpConn* conn, string s);
VV_LOCAL_SYMBOL _result_int veb__send_string_ptr(net__TcpConn* conn, u8* ptr, int len);
VV_LOCAL_SYMBOL _result_void veb__fast_send_resp_header(net__TcpConn* conn, net__http__Response resp);
VV_LOCAL_SYMBOL _result_void veb__fast_send_resp(net__TcpConn* conn, net__http__Response resp);
void veb__Context_error(veb__Context* ctx, string s);
VV_LOCAL_SYMBOL string main__cookie_id(main__Context _v_toheap_ctx);
VV_LOCAL_SYMBOL string main__cookie_passwd(main__Context _v_toheap_ctx);
VV_LOCAL_SYMBOL string main__cookie_mess(main__Context* ctx);
VV_LOCAL_SYMBOL void main__main(void);
VV_LOCAL_SYMBOL main__App* main__new_app(db__sqlite__DB _v_toheap_db);
VV_LOCAL_SYMBOL veb__Result main__App_index(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_find_index(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_error(main__App* app, main__Context* ctx);
veb__Result main__Context_not_found(main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_login(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_loginapi(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_signup(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_signupapi(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_member(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_memberapi(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_challenge(main__App* app, main__Context* ctx, string display_challenge);
VV_LOCAL_SYMBOL veb__Result main__App_flagapi(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_team(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_ranking(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_rankapi(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_notice(main__App* app, main__Context* ctx);
VV_LOCAL_SYMBOL veb__Result main__App_console(main__App* app, main__Context* ctx);
static string sql_db__Personal_str(sql_db__Personal it); // auto
static string indent_sql_db__Personal_str(sql_db__Personal it, int indent_count); // auto
static string net__TcpSocket_str(net__TcpSocket it); // auto
static string indent_net__TcpSocket_str(net__TcpSocket it, int indent_count); // auto
static string Array_net__http__Method_str(Array_net__http__Method a); // auto
static string indent_Array_net__http__Method_str(Array_net__http__Method a, int indent_count); // auto
static string Array_sql_db__PersonalFlag_str(Array_sql_db__PersonalFlag a); // auto
static string indent_Array_sql_db__PersonalFlag_str(Array_sql_db__PersonalFlag a, int indent_count); // auto
static string net__Socket_str(net__Socket it); // auto
static string indent_net__Socket_str(net__Socket it, int indent_count); // auto
static string sql_db__PersonalFlag_str(sql_db__PersonalFlag it); // auto
static string indent_sql_db__PersonalFlag_str(sql_db__PersonalFlag it, int indent_count); // auto
orm__Primitive orm__Null_to_sumtype_orm__Primitive(orm__Null* x);
orm__Primitive bool_to_sumtype_orm__Primitive(bool* x);
orm__Primitive f32_to_sumtype_orm__Primitive(f32* x);
orm__Primitive f64_to_sumtype_orm__Primitive(f64* x);
orm__Primitive i8_to_sumtype_orm__Primitive(i8* x);
orm__Primitive i16_to_sumtype_orm__Primitive(i16* x);
orm__Primitive int_to_sumtype_orm__Primitive(int* x);
orm__Primitive i64_to_sumtype_orm__Primitive(i64* x);
orm__Primitive u8_to_sumtype_orm__Primitive(u8* x);
orm__Primitive u16_to_sumtype_orm__Primitive(u16* x);
orm__Primitive u32_to_sumtype_orm__Primitive(u32* x);
orm__Primitive u64_to_sumtype_orm__Primitive(u64* x);
orm__Primitive string_to_sumtype_orm__Primitive(string* x);
orm__Primitive time__Time_to_sumtype_orm__Primitive(time__Time* x);
orm__Primitive orm__InfixType_to_sumtype_orm__Primitive(orm__InfixType* x);
bool Array_string_arr_eq(Array_string a, Array_string b); // auto
bool sql_db__PostFlag_struct_eq(sql_db__PostFlag a, sql_db__PostFlag b); // auto

// V sort fn definitions:
VV_LOCAL_SYMBOL  int compare_3040552254790933403_RepIndex_by_idx(RepIndex* a, RepIndex* b) {
	if (a->idx < b->idx) return -1;
	else return 1;
}


// V global/const non-precomputed definitions:
string _const_strconv__digit_pairs; // a string literal, inited later
string _const_strconv__base_digits; // a string literal, inited later
string _const_digit_pairs; // a string literal, inited later
string _const_encoding__base64__enc_table; // a string literal, inited later
string _const_time__months_string; // a string literal, inited later
string _const_net__urllib__err_msg_escape; // a string literal, inited later
string _const_vlog__false_log; // a string literal, inited later
string _const_vlog__true_log; // a string literal, inited later
string _const_vlog__set_log; // a string literal, inited later
string _const_vlog__warn_log; // a string literal, inited later
string _const_picohttpparser__token_char_map; // str inited later
string _const_os__path_separator; // a string literal, inited later
string _const_sql_db__solved; // a string literal, inited later
string _const_sql_db__unsolved; // a string literal, inited later
string _const_veb__boundary_start; // a string literal, inited later
string _const_main__version; // a string literal, inited later
const u32 _const_math__bits__de_bruijn32 = 125613361; // precomputed2
Array_fixed_u8_32 _const_math__bits__de_bruijn32tab = {((u8)(0)), 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 
31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9}; // fixed array const
const u64 _const_math__bits__de_bruijn64 = 285870213051353865U; // precomputed2
Array_fixed_u8_64 _const_math__bits__de_bruijn64tab = {((u8)(0)), 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 
62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 
63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 
54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6}; // fixed array const
const u32 _const_math__bits__n32 = 32; // precomputed2
const u64 _const_math__bits__two32 = 4294967296U; // precomputed2
const u64 _const_math__bits__mask32 = 4294967295U; // precomputed2
Array_fixed_u8_256 _const_math__bits__len_8_tab = {((u8)(0x00)), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08}; // fixed array const
const u32 _const_strconv__single_plus_zero = 0; // precomputed2
const u32 _const_strconv__single_minus_zero = 2147483648; // precomputed2
const u32 _const_strconv__single_plus_infinity = 2139095040; // precomputed2
const u32 _const_strconv__single_minus_infinity = 4286578688; // precomputed2
const u64 _const_strconv__double_plus_zero = 0U; // precomputed2
const u64 _const_strconv__double_minus_zero = 9223372036854775808U; // precomputed2
const u64 _const_strconv__double_plus_infinity = 9218868437227405312U; // precomputed2
const u64 _const_strconv__double_minus_infinity = 18442240474082181120U; // precomputed2
Array_fixed_u32_10 _const_strconv__ten_pow_table_32 = {((u32)(1U)), ((u32)(10U)), ((u32)(100U)), ((u32)(1000U)), ((u32)(10000U)), ((u32)(100000U)), ((u32)(1000000U)), ((u32)(10000000U)), ((u32)(100000000U)), ((u32)(1000000000U))}; // fixed array const
const u32 _const_strconv__mantbits32 = 23; // precomputed2
const u32 _const_strconv__expbits32 = 8; // precomputed2
Array_fixed_u64_20 _const_strconv__ten_pow_table_64 = {((u64)(1U)), ((u64)(10U)), ((u64)(100U)), ((u64)(1000U)), ((u64)(10000U)), ((u64)(100000U)), ((u64)(1000000U)), ((u64)(10000000U)), ((u64)(100000000U)), ((u64)(1000000000U)), ((u64)(10000000000U)), ((u64)(100000000000U)), ((u64)(1000000000000U)), ((u64)(10000000000000U)), ((u64)(100000000000000U)), ((u64)(1000000000000000U)), ((u64)(10000000000000000U)), ((u64)(100000000000000000U)), ((u64)(1000000000000000000U)), ((u64)(10000000000000000000U))}; // fixed array const
const u32 _const_strconv__mantbits64 = 52; // precomputed2
const u32 _const_strconv__expbits64 = 11; // precomputed2
Array_fixed_f64_36 _const_strconv__dec_round = {((f64)(0.5)), 0.05, 0.005, 0.0005, 0.00005, 0.000005, 0.0000005, 0.00000005, 0.000000005, 0.0000000005, 0.00000000005, 0.000000000005, 0.0000000000005, 0.00000000000005, 0.000000000000005, 0.0000000000000005, 
0.00000000000000005, 0.000000000000000005, 0.0000000000000000005, 0.00000000000000000005, 0.000000000000000000005, 0.0000000000000000000005, 0.00000000000000000000005, 0.000000000000000000000005, 0.0000000000000000000000005, 0.00000000000000000000000005, 0.000000000000000000000000005, 0.0000000000000000000000000005, 0.00000000000000000000000000005, 0.000000000000000000000000000005, 0.0000000000000000000000000000005, 0.00000000000000000000000000000005, 0.000000000000000000000000000000005, 0.0000000000000000000000000000000005, 0.00000000000000000000000000000000005, 0.000000000000000000000000000000000005}; // fixed array const
Array_fixed_u64_47 _const_strconv__pow5_split_32 = {((u64)(1152921504606846976U)), ((u64)(1441151880758558720U)), ((u64)(1801439850948198400U)), ((u64)(2251799813685248000U)), ((u64)(1407374883553280000U)), ((u64)(1759218604441600000U)), ((u64)(2199023255552000000U)), ((u64)(1374389534720000000U)), ((u64)(1717986918400000000U)), ((u64)(2147483648000000000U)), ((u64)(1342177280000000000U)), ((u64)(1677721600000000000U)), ((u64)(2097152000000000000U)), ((u64)(1310720000000000000U)), ((u64)(1638400000000000000U)), ((u64)(2048000000000000000U)), 
((u64)(1280000000000000000U)), ((u64)(1600000000000000000U)), ((u64)(2000000000000000000U)), ((u64)(1250000000000000000U)), ((u64)(1562500000000000000U)), ((u64)(1953125000000000000U)), ((u64)(1220703125000000000U)), ((u64)(1525878906250000000U)), ((u64)(1907348632812500000U)), ((u64)(1192092895507812500U)), ((u64)(1490116119384765625U)), ((u64)(1862645149230957031U)), ((u64)(1164153218269348144U)), ((u64)(1455191522836685180U)), ((u64)(1818989403545856475U)), ((u64)(2273736754432320594U)), 
((u64)(1421085471520200371U)), ((u64)(1776356839400250464U)), ((u64)(2220446049250313080U)), ((u64)(1387778780781445675U)), ((u64)(1734723475976807094U)), ((u64)(2168404344971008868U)), ((u64)(1355252715606880542U)), ((u64)(1694065894508600678U)), ((u64)(2117582368135750847U)), ((u64)(1323488980084844279U)), ((u64)(1654361225106055349U)), ((u64)(2067951531382569187U)), ((u64)(1292469707114105741U)), ((u64)(1615587133892632177U)), ((u64)(2019483917365790221U))}; // fixed array const
Array_fixed_u64_31 _const_strconv__pow5_inv_split_32 = {((u64)(576460752303423489U)), ((u64)(461168601842738791U)), ((u64)(368934881474191033U)), ((u64)(295147905179352826U)), ((u64)(472236648286964522U)), ((u64)(377789318629571618U)), ((u64)(302231454903657294U)), ((u64)(483570327845851670U)), ((u64)(386856262276681336U)), ((u64)(309485009821345069U)), ((u64)(495176015714152110U)), ((u64)(396140812571321688U)), ((u64)(316912650057057351U)), ((u64)(507060240091291761U)), ((u64)(405648192073033409U)), ((u64)(324518553658426727U)), 
((u64)(519229685853482763U)), ((u64)(415383748682786211U)), ((u64)(332306998946228969U)), ((u64)(531691198313966350U)), ((u64)(425352958651173080U)), ((u64)(340282366920938464U)), ((u64)(544451787073501542U)), ((u64)(435561429658801234U)), ((u64)(348449143727040987U)), ((u64)(557518629963265579U)), ((u64)(446014903970612463U)), ((u64)(356811923176489971U)), ((u64)(570899077082383953U)), ((u64)(456719261665907162U)), ((u64)(365375409332725730U))}; // fixed array const
Array_fixed_u64_652 _const_strconv__pow5_split_64_x = {((u64)(0x0000000000000000U)), ((u64)(0x0100000000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x0140000000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x0190000000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01f4000000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x0138800000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x0186a00000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01e8480000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01312d0000000000U)), 
((u64)(0x0000000000000000U)), ((u64)(0x017d784000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01dcd65000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x012a05f200000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x0174876e80000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01d1a94a20000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x012309ce54000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x016bcc41e9000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01c6bf5263400000U)), 
((u64)(0x0000000000000000U)), ((u64)(0x011c37937e080000U)), ((u64)(0x0000000000000000U)), ((u64)(0x016345785d8a0000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01bc16d674ec8000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01158e460913d000U)), ((u64)(0x0000000000000000U)), ((u64)(0x015af1d78b58c400U)), ((u64)(0x0000000000000000U)), ((u64)(0x01b1ae4d6e2ef500U)), ((u64)(0x0000000000000000U)), ((u64)(0x010f0cf064dd5920U)), ((u64)(0x0000000000000000U)), ((u64)(0x0152d02c7e14af68U)), 
((u64)(0x0000000000000000U)), ((u64)(0x01a784379d99db42U)), ((u64)(0x4000000000000000U)), ((u64)(0x0108b2a2c2802909U)), ((u64)(0x9000000000000000U)), ((u64)(0x014adf4b7320334bU)), ((u64)(0x7400000000000000U)), ((u64)(0x019d971e4fe8401eU)), ((u64)(0x0880000000000000U)), ((u64)(0x01027e72f1f12813U)), ((u64)(0xcaa0000000000000U)), ((u64)(0x01431e0fae6d7217U)), ((u64)(0xbd48000000000000U)), ((u64)(0x0193e5939a08ce9dU)), ((u64)(0x2c9a000000000000U)), ((u64)(0x01f8def8808b0245U)), 
((u64)(0x3be0400000000000U)), ((u64)(0x013b8b5b5056e16bU)), ((u64)(0x0ad8500000000000U)), ((u64)(0x018a6e32246c99c6U)), ((u64)(0x8d8e640000000000U)), ((u64)(0x01ed09bead87c037U)), ((u64)(0xb878fe8000000000U)), ((u64)(0x013426172c74d822U)), ((u64)(0x66973e2000000000U)), ((u64)(0x01812f9cf7920e2bU)), ((u64)(0x403d0da800000000U)), ((u64)(0x01e17b84357691b6U)), ((u64)(0xe826288900000000U)), ((u64)(0x012ced32a16a1b11U)), ((u64)(0x622fb2ab40000000U)), ((u64)(0x0178287f49c4a1d6U)), 
((u64)(0xfabb9f5610000000U)), ((u64)(0x01d6329f1c35ca4bU)), ((u64)(0x7cb54395ca000000U)), ((u64)(0x0125dfa371a19e6fU)), ((u64)(0x5be2947b3c800000U)), ((u64)(0x016f578c4e0a060bU)), ((u64)(0x32db399a0ba00000U)), ((u64)(0x01cb2d6f618c878eU)), ((u64)(0xdfc9040047440000U)), ((u64)(0x011efc659cf7d4b8U)), ((u64)(0x17bb450059150000U)), ((u64)(0x0166bb7f0435c9e7U)), ((u64)(0xddaa16406f5a4000U)), ((u64)(0x01c06a5ec5433c60U)), ((u64)(0x8a8a4de845986800U)), ((u64)(0x0118427b3b4a05bcU)), 
((u64)(0xad2ce16256fe8200U)), ((u64)(0x015e531a0a1c872bU)), ((u64)(0x987819baecbe2280U)), ((u64)(0x01b5e7e08ca3a8f6U)), ((u64)(0x1f4b1014d3f6d590U)), ((u64)(0x0111b0ec57e6499aU)), ((u64)(0xa71dd41a08f48af4U)), ((u64)(0x01561d276ddfdc00U)), ((u64)(0xd0e549208b31adb1U)), ((u64)(0x01aba4714957d300U)), ((u64)(0x828f4db456ff0c8eU)), ((u64)(0x010b46c6cdd6e3e0U)), ((u64)(0xa33321216cbecfb2U)), ((u64)(0x014e1878814c9cd8U)), ((u64)(0xcbffe969c7ee839eU)), ((u64)(0x01a19e96a19fc40eU)), 
((u64)(0x3f7ff1e21cf51243U)), ((u64)(0x0105031e2503da89U)), ((u64)(0x8f5fee5aa43256d4U)), ((u64)(0x014643e5ae44d12bU)), ((u64)(0x7337e9f14d3eec89U)), ((u64)(0x0197d4df19d60576U)), ((u64)(0x1005e46da08ea7abU)), ((u64)(0x01fdca16e04b86d4U)), ((u64)(0x8a03aec4845928cbU)), ((u64)(0x013e9e4e4c2f3444U)), ((u64)(0xac849a75a56f72fdU)), ((u64)(0x018e45e1df3b0155U)), ((u64)(0x17a5c1130ecb4fbdU)), ((u64)(0x01f1d75a5709c1abU)), ((u64)(0xeec798abe93f11d6U)), ((u64)(0x013726987666190aU)), 
((u64)(0xaa797ed6e38ed64bU)), ((u64)(0x0184f03e93ff9f4dU)), ((u64)(0x1517de8c9c728bdeU)), ((u64)(0x01e62c4e38ff8721U)), ((u64)(0xad2eeb17e1c7976bU)), ((u64)(0x012fdbb0e39fb474U)), ((u64)(0xd87aa5ddda397d46U)), ((u64)(0x017bd29d1c87a191U)), ((u64)(0x4e994f5550c7dc97U)), ((u64)(0x01dac74463a989f6U)), ((u64)(0xf11fd195527ce9deU)), ((u64)(0x0128bc8abe49f639U)), ((u64)(0x6d67c5faa71c2456U)), ((u64)(0x0172ebad6ddc73c8U)), ((u64)(0x88c1b77950e32d6cU)), ((u64)(0x01cfa698c95390baU)), 
((u64)(0x957912abd28dfc63U)), ((u64)(0x0121c81f7dd43a74U)), ((u64)(0xbad75756c7317b7cU)), ((u64)(0x016a3a275d494911U)), ((u64)(0x298d2d2c78fdda5bU)), ((u64)(0x01c4c8b1349b9b56U)), ((u64)(0xd9f83c3bcb9ea879U)), ((u64)(0x011afd6ec0e14115U)), ((u64)(0x50764b4abe865297U)), ((u64)(0x0161bcca7119915bU)), ((u64)(0x2493de1d6e27e73dU)), ((u64)(0x01ba2bfd0d5ff5b2U)), ((u64)(0x56dc6ad264d8f086U)), ((u64)(0x01145b7e285bf98fU)), ((u64)(0x2c938586fe0f2ca8U)), ((u64)(0x0159725db272f7f3U)), 
((u64)(0xf7b866e8bd92f7d2U)), ((u64)(0x01afcef51f0fb5efU)), ((u64)(0xfad34051767bdae3U)), ((u64)(0x010de1593369d1b5U)), ((u64)(0x79881065d41ad19cU)), ((u64)(0x015159af80444623U)), ((u64)(0x57ea147f49218603U)), ((u64)(0x01a5b01b605557acU)), ((u64)(0xb6f24ccf8db4f3c1U)), ((u64)(0x01078e111c3556cbU)), ((u64)(0xa4aee003712230b2U)), ((u64)(0x014971956342ac7eU)), ((u64)(0x4dda98044d6abcdfU)), ((u64)(0x019bcdfabc13579eU)), ((u64)(0xf0a89f02b062b60bU)), ((u64)(0x010160bcb58c16c2U)), 
((u64)(0xacd2c6c35c7b638eU)), ((u64)(0x0141b8ebe2ef1c73U)), ((u64)(0x98077874339a3c71U)), ((u64)(0x01922726dbaae390U)), ((u64)(0xbe0956914080cb8eU)), ((u64)(0x01f6b0f092959c74U)), ((u64)(0xf6c5d61ac8507f38U)), ((u64)(0x013a2e965b9d81c8U)), ((u64)(0x34774ba17a649f07U)), ((u64)(0x0188ba3bf284e23bU)), ((u64)(0x01951e89d8fdc6c8U)), ((u64)(0x01eae8caef261acaU)), ((u64)(0x40fd3316279e9c3dU)), ((u64)(0x0132d17ed577d0beU)), ((u64)(0xd13c7fdbb186434cU)), ((u64)(0x017f85de8ad5c4edU)), 
((u64)(0x458b9fd29de7d420U)), ((u64)(0x01df67562d8b3629U)), ((u64)(0xcb7743e3a2b0e494U)), ((u64)(0x012ba095dc7701d9U)), ((u64)(0x3e5514dc8b5d1db9U)), ((u64)(0x017688bb5394c250U)), ((u64)(0x4dea5a13ae346527U)), ((u64)(0x01d42aea2879f2e4U)), ((u64)(0xb0b2784c4ce0bf38U)), ((u64)(0x01249ad2594c37ceU)), ((u64)(0x5cdf165f6018ef06U)), ((u64)(0x016dc186ef9f45c2U)), ((u64)(0xf416dbf7381f2ac8U)), ((u64)(0x01c931e8ab871732U)), ((u64)(0xd88e497a83137abdU)), ((u64)(0x011dbf316b346e7fU)), 
((u64)(0xceb1dbd923d8596cU)), ((u64)(0x01652efdc6018a1fU)), ((u64)(0xc25e52cf6cce6fc7U)), ((u64)(0x01be7abd3781eca7U)), ((u64)(0xd97af3c1a40105dcU)), ((u64)(0x01170cb642b133e8U)), ((u64)(0x0fd9b0b20d014754U)), ((u64)(0x015ccfe3d35d80e3U)), ((u64)(0xd3d01cde90419929U)), ((u64)(0x01b403dcc834e11bU)), ((u64)(0x6462120b1a28ffb9U)), ((u64)(0x01108269fd210cb1U)), ((u64)(0xbd7a968de0b33fa8U)), ((u64)(0x0154a3047c694fddU)), ((u64)(0x2cd93c3158e00f92U)), ((u64)(0x01a9cbc59b83a3d5U)), 
((u64)(0x3c07c59ed78c09bbU)), ((u64)(0x010a1f5b81324665U)), ((u64)(0x8b09b7068d6f0c2aU)), ((u64)(0x014ca732617ed7feU)), ((u64)(0x2dcc24c830cacf34U)), ((u64)(0x019fd0fef9de8dfeU)), ((u64)(0xdc9f96fd1e7ec180U)), ((u64)(0x0103e29f5c2b18beU)), ((u64)(0x93c77cbc661e71e1U)), ((u64)(0x0144db473335deeeU)), ((u64)(0x38b95beb7fa60e59U)), ((u64)(0x01961219000356aaU)), ((u64)(0xc6e7b2e65f8f91efU)), ((u64)(0x01fb969f40042c54U)), ((u64)(0xfc50cfcffbb9bb35U)), ((u64)(0x013d3e2388029bb4U)), 
((u64)(0x3b6503c3faa82a03U)), ((u64)(0x018c8dac6a0342a2U)), ((u64)(0xca3e44b4f9523484U)), ((u64)(0x01efb1178484134aU)), ((u64)(0xbe66eaf11bd360d2U)), ((u64)(0x0135ceaeb2d28c0eU)), ((u64)(0x6e00a5ad62c83907U)), ((u64)(0x0183425a5f872f12U)), ((u64)(0x0980cf18bb7a4749U)), ((u64)(0x01e412f0f768fad7U)), ((u64)(0x65f0816f752c6c8dU)), ((u64)(0x012e8bd69aa19cc6U)), ((u64)(0xff6ca1cb527787b1U)), ((u64)(0x017a2ecc414a03f7U)), ((u64)(0xff47ca3e2715699dU)), ((u64)(0x01d8ba7f519c84f5U)), 
((u64)(0xbf8cde66d86d6202U)), ((u64)(0x0127748f9301d319U)), ((u64)(0x2f7016008e88ba83U)), ((u64)(0x017151b377c247e0U)), ((u64)(0x3b4c1b80b22ae923U)), ((u64)(0x01cda62055b2d9d8U)), ((u64)(0x250f91306f5ad1b6U)), ((u64)(0x012087d4358fc827U)), ((u64)(0xee53757c8b318623U)), ((u64)(0x0168a9c942f3ba30U)), ((u64)(0x29e852dbadfde7acU)), ((u64)(0x01c2d43b93b0a8bdU)), ((u64)(0x3a3133c94cbeb0ccU)), ((u64)(0x0119c4a53c4e6976U)), ((u64)(0xc8bd80bb9fee5cffU)), ((u64)(0x016035ce8b6203d3U)), 
((u64)(0xbaece0ea87e9f43eU)), ((u64)(0x01b843422e3a84c8U)), ((u64)(0x74d40c9294f238a7U)), ((u64)(0x01132a095ce492fdU)), ((u64)(0xd2090fb73a2ec6d1U)), ((u64)(0x0157f48bb41db7bcU)), ((u64)(0x068b53a508ba7885U)), ((u64)(0x01adf1aea12525acU)), ((u64)(0x8417144725748b53U)), ((u64)(0x010cb70d24b7378bU)), ((u64)(0x651cd958eed1ae28U)), ((u64)(0x014fe4d06de5056eU)), ((u64)(0xfe640faf2a8619b2U)), ((u64)(0x01a3de04895e46c9U)), ((u64)(0x3efe89cd7a93d00fU)), ((u64)(0x01066ac2d5daec3eU)), 
((u64)(0xcebe2c40d938c413U)), ((u64)(0x014805738b51a74dU)), ((u64)(0x426db7510f86f518U)), ((u64)(0x019a06d06e261121U)), ((u64)(0xc9849292a9b4592fU)), ((u64)(0x0100444244d7cab4U)), ((u64)(0xfbe5b73754216f7aU)), ((u64)(0x01405552d60dbd61U)), ((u64)(0x7adf25052929cb59U)), ((u64)(0x01906aa78b912cbaU)), ((u64)(0x1996ee4673743e2fU)), ((u64)(0x01f485516e7577e9U)), ((u64)(0xaffe54ec0828a6ddU)), ((u64)(0x0138d352e5096af1U)), ((u64)(0x1bfdea270a32d095U)), ((u64)(0x018708279e4bc5aeU)), 
((u64)(0xa2fd64b0ccbf84baU)), ((u64)(0x01e8ca3185deb719U)), ((u64)(0x05de5eee7ff7b2f4U)), ((u64)(0x01317e5ef3ab3270U)), ((u64)(0x0755f6aa1ff59fb1U)), ((u64)(0x017dddf6b095ff0cU)), ((u64)(0x092b7454a7f3079eU)), ((u64)(0x01dd55745cbb7ecfU)), ((u64)(0x65bb28b4e8f7e4c3U)), ((u64)(0x012a5568b9f52f41U)), ((u64)(0xbf29f2e22335ddf3U)), ((u64)(0x0174eac2e8727b11U)), ((u64)(0x2ef46f9aac035570U)), ((u64)(0x01d22573a28f19d6U)), ((u64)(0xdd58c5c0ab821566U)), ((u64)(0x0123576845997025U)), 
((u64)(0x54aef730d6629ac0U)), ((u64)(0x016c2d4256ffcc2fU)), ((u64)(0x29dab4fd0bfb4170U)), ((u64)(0x01c73892ecbfbf3bU)), ((u64)(0xfa28b11e277d08e6U)), ((u64)(0x011c835bd3f7d784U)), ((u64)(0x38b2dd65b15c4b1fU)), ((u64)(0x0163a432c8f5cd66U)), ((u64)(0xc6df94bf1db35de7U)), ((u64)(0x01bc8d3f7b3340bfU)), ((u64)(0xdc4bbcf772901ab0U)), ((u64)(0x0115d847ad000877U)), ((u64)(0xd35eac354f34215cU)), ((u64)(0x015b4e5998400a95U)), ((u64)(0x48365742a30129b4U)), ((u64)(0x01b221effe500d3bU)), 
((u64)(0x0d21f689a5e0ba10U)), ((u64)(0x010f5535fef20845U)), ((u64)(0x506a742c0f58e894U)), ((u64)(0x01532a837eae8a56U)), ((u64)(0xe4851137132f22b9U)), ((u64)(0x01a7f5245e5a2cebU)), ((u64)(0x6ed32ac26bfd75b4U)), ((u64)(0x0108f936baf85c13U)), ((u64)(0x4a87f57306fcd321U)), ((u64)(0x014b378469b67318U)), ((u64)(0x5d29f2cfc8bc07e9U)), ((u64)(0x019e056584240fdeU)), ((u64)(0xfa3a37c1dd7584f1U)), ((u64)(0x0102c35f729689eaU)), ((u64)(0xb8c8c5b254d2e62eU)), ((u64)(0x014374374f3c2c65U)), 
((u64)(0x26faf71eea079fb9U)), ((u64)(0x01945145230b377fU)), ((u64)(0xf0b9b4e6a48987a8U)), ((u64)(0x01f965966bce055eU)), ((u64)(0x5674111026d5f4c9U)), ((u64)(0x013bdf7e0360c35bU)), ((u64)(0x2c111554308b71fbU)), ((u64)(0x018ad75d8438f432U)), ((u64)(0xb7155aa93cae4e7aU)), ((u64)(0x01ed8d34e547313eU)), ((u64)(0x326d58a9c5ecf10cU)), ((u64)(0x013478410f4c7ec7U)), ((u64)(0xff08aed437682d4fU)), ((u64)(0x01819651531f9e78U)), ((u64)(0x3ecada89454238a3U)), ((u64)(0x01e1fbe5a7e78617U)), 
((u64)(0x873ec895cb496366U)), ((u64)(0x012d3d6f88f0b3ceU)), ((u64)(0x290e7abb3e1bbc3fU)), ((u64)(0x01788ccb6b2ce0c2U)), ((u64)(0xb352196a0da2ab4fU)), ((u64)(0x01d6affe45f818f2U)), ((u64)(0xb0134fe24885ab11U)), ((u64)(0x01262dfeebbb0f97U)), ((u64)(0x9c1823dadaa715d6U)), ((u64)(0x016fb97ea6a9d37dU)), ((u64)(0x031e2cd19150db4bU)), ((u64)(0x01cba7de5054485dU)), ((u64)(0x21f2dc02fad2890fU)), ((u64)(0x011f48eaf234ad3aU)), ((u64)(0xaa6f9303b9872b53U)), ((u64)(0x01671b25aec1d888U)), 
((u64)(0xd50b77c4a7e8f628U)), ((u64)(0x01c0e1ef1a724eaaU)), ((u64)(0xc5272adae8f199d9U)), ((u64)(0x01188d357087712aU)), ((u64)(0x7670f591a32e004fU)), ((u64)(0x015eb082cca94d75U)), ((u64)(0xd40d32f60bf98063U)), ((u64)(0x01b65ca37fd3a0d2U)), ((u64)(0xc4883fd9c77bf03eU)), ((u64)(0x0111f9e62fe44483U)), ((u64)(0xb5aa4fd0395aec4dU)), ((u64)(0x0156785fbbdd55a4U)), ((u64)(0xe314e3c447b1a760U)), ((u64)(0x01ac1677aad4ab0dU)), ((u64)(0xaded0e5aaccf089cU)), ((u64)(0x010b8e0acac4eae8U)), 
((u64)(0xd96851f15802cac3U)), ((u64)(0x014e718d7d7625a2U)), ((u64)(0x8fc2666dae037d74U)), ((u64)(0x01a20df0dcd3af0bU)), ((u64)(0x39d980048cc22e68U)), ((u64)(0x010548b68a044d67U)), ((u64)(0x084fe005aff2ba03U)), ((u64)(0x01469ae42c8560c1U)), ((u64)(0x4a63d8071bef6883U)), ((u64)(0x0198419d37a6b8f1U)), ((u64)(0x9cfcce08e2eb42a4U)), ((u64)(0x01fe52048590672dU)), ((u64)(0x821e00c58dd309a7U)), ((u64)(0x013ef342d37a407cU)), ((u64)(0xa2a580f6f147cc10U)), ((u64)(0x018eb0138858d09bU)), 
((u64)(0x8b4ee134ad99bf15U)), ((u64)(0x01f25c186a6f04c2U)), ((u64)(0x97114cc0ec80176dU)), ((u64)(0x0137798f428562f9U)), ((u64)(0xfcd59ff127a01d48U)), ((u64)(0x018557f31326bbb7U)), ((u64)(0xfc0b07ed7188249aU)), ((u64)(0x01e6adefd7f06aa5U)), ((u64)(0xbd86e4f466f516e0U)), ((u64)(0x01302cb5e6f642a7U)), ((u64)(0xace89e3180b25c98U)), ((u64)(0x017c37e360b3d351U)), ((u64)(0x1822c5bde0def3beU)), ((u64)(0x01db45dc38e0c826U)), ((u64)(0xcf15bb96ac8b5857U)), ((u64)(0x01290ba9a38c7d17U)), 
((u64)(0xc2db2a7c57ae2e6dU)), ((u64)(0x01734e940c6f9c5dU)), ((u64)(0x3391f51b6d99ba08U)), ((u64)(0x01d022390f8b8375U)), ((u64)(0x403b393124801445U)), ((u64)(0x01221563a9b73229U)), ((u64)(0x904a077d6da01956U)), ((u64)(0x016a9abc9424feb3U)), ((u64)(0x745c895cc9081facU)), ((u64)(0x01c5416bb92e3e60U)), ((u64)(0x48b9d5d9fda513cbU)), ((u64)(0x011b48e353bce6fcU)), ((u64)(0x5ae84b507d0e58beU)), ((u64)(0x01621b1c28ac20bbU)), ((u64)(0x31a25e249c51eeeeU)), ((u64)(0x01baa1e332d728eaU)), 
((u64)(0x5f057ad6e1b33554U)), ((u64)(0x0114a52dffc67992U)), ((u64)(0xf6c6d98c9a2002aaU)), ((u64)(0x0159ce797fb817f6U)), ((u64)(0xb4788fefc0a80354U)), ((u64)(0x01b04217dfa61df4U)), ((u64)(0xf0cb59f5d8690214U)), ((u64)(0x010e294eebc7d2b8U)), ((u64)(0x2cfe30734e83429aU)), ((u64)(0x0151b3a2a6b9c767U)), ((u64)(0xf83dbc9022241340U)), ((u64)(0x01a6208b50683940U)), ((u64)(0x9b2695da15568c08U)), ((u64)(0x0107d457124123c8U)), ((u64)(0xc1f03b509aac2f0aU)), ((u64)(0x0149c96cd6d16cbaU)), 
((u64)(0x726c4a24c1573acdU)), ((u64)(0x019c3bc80c85c7e9U)), ((u64)(0xe783ae56f8d684c0U)), ((u64)(0x0101a55d07d39cf1U)), ((u64)(0x616499ecb70c25f0U)), ((u64)(0x01420eb449c8842eU)), ((u64)(0xf9bdc067e4cf2f6cU)), ((u64)(0x019292615c3aa539U)), ((u64)(0x782d3081de02fb47U)), ((u64)(0x01f736f9b3494e88U)), ((u64)(0x4b1c3e512ac1dd0cU)), ((u64)(0x013a825c100dd115U)), ((u64)(0x9de34de57572544fU)), ((u64)(0x018922f31411455aU)), ((u64)(0x455c215ed2cee963U)), ((u64)(0x01eb6bafd91596b1U)), 
((u64)(0xcb5994db43c151deU)), ((u64)(0x0133234de7ad7e2eU)), ((u64)(0x7e2ffa1214b1a655U)), ((u64)(0x017fec216198ddbaU)), ((u64)(0x1dbbf89699de0febU)), ((u64)(0x01dfe729b9ff1529U)), ((u64)(0xb2957b5e202ac9f3U)), ((u64)(0x012bf07a143f6d39U)), ((u64)(0x1f3ada35a8357c6fU)), ((u64)(0x0176ec98994f4888U)), ((u64)(0x270990c31242db8bU)), ((u64)(0x01d4a7bebfa31aaaU)), ((u64)(0x5865fa79eb69c937U)), ((u64)(0x0124e8d737c5f0aaU)), ((u64)(0xee7f791866443b85U)), ((u64)(0x016e230d05b76cd4U)), 
((u64)(0x2a1f575e7fd54a66U)), ((u64)(0x01c9abd04725480aU)), ((u64)(0x5a53969b0fe54e80U)), ((u64)(0x011e0b622c774d06U)), ((u64)(0xf0e87c41d3dea220U)), ((u64)(0x01658e3ab7952047U)), ((u64)(0xed229b5248d64aa8U)), ((u64)(0x01bef1c9657a6859U)), ((u64)(0x3435a1136d85eea9U)), ((u64)(0x0117571ddf6c8138U)), ((u64)(0x4143095848e76a53U)), ((u64)(0x015d2ce55747a186U)), ((u64)(0xd193cbae5b2144e8U)), ((u64)(0x01b4781ead1989e7U)), ((u64)(0xe2fc5f4cf8f4cb11U)), ((u64)(0x0110cb132c2ff630U)), 
((u64)(0x1bbb77203731fdd5U)), ((u64)(0x0154fdd7f73bf3bdU)), ((u64)(0x62aa54e844fe7d4aU)), ((u64)(0x01aa3d4df50af0acU)), ((u64)(0xbdaa75112b1f0e4eU)), ((u64)(0x010a6650b926d66bU)), ((u64)(0xad15125575e6d1e2U)), ((u64)(0x014cffe4e7708c06U)), ((u64)(0x585a56ead360865bU)), ((u64)(0x01a03fde214caf08U)), ((u64)(0x37387652c41c53f8U)), ((u64)(0x010427ead4cfed65U)), ((u64)(0x850693e7752368f7U)), ((u64)(0x014531e58a03e8beU)), ((u64)(0x264838e1526c4334U)), ((u64)(0x01967e5eec84e2eeU)), 
((u64)(0xafda4719a7075402U)), ((u64)(0x01fc1df6a7a61ba9U)), ((u64)(0x0de86c7008649481U)), ((u64)(0x013d92ba28c7d14aU)), ((u64)(0x9162878c0a7db9a1U)), ((u64)(0x018cf768b2f9c59cU)), ((u64)(0xb5bb296f0d1d280aU)), ((u64)(0x01f03542dfb83703U)), ((u64)(0x5194f9e568323906U)), ((u64)(0x01362149cbd32262U)), ((u64)(0xe5fa385ec23ec747U)), ((u64)(0x0183a99c3ec7eafaU)), ((u64)(0x9f78c67672ce7919U)), ((u64)(0x01e494034e79e5b9U)), ((u64)(0x03ab7c0a07c10bb0U)), ((u64)(0x012edc82110c2f94U)), 
((u64)(0x04965b0c89b14e9cU)), ((u64)(0x017a93a2954f3b79U)), ((u64)(0x45bbf1cfac1da243U)), ((u64)(0x01d9388b3aa30a57U)), ((u64)(0x8b957721cb92856aU)), ((u64)(0x0127c35704a5e676U)), ((u64)(0x2e7ad4ea3e7726c4U)), ((u64)(0x0171b42cc5cf6014U)), ((u64)(0x3a198a24ce14f075U)), ((u64)(0x01ce2137f7433819U)), ((u64)(0xc44ff65700cd1649U)), ((u64)(0x0120d4c2fa8a030fU)), ((u64)(0xb563f3ecc1005bdbU)), ((u64)(0x016909f3b92c83d3U)), ((u64)(0xa2bcf0e7f14072d2U)), ((u64)(0x01c34c70a777a4c8U)), 
((u64)(0x65b61690f6c847c3U)), ((u64)(0x011a0fc668aac6fdU)), ((u64)(0xbf239c35347a59b4U)), ((u64)(0x016093b802d578bcU)), ((u64)(0xeeec83428198f021U)), ((u64)(0x01b8b8a6038ad6ebU)), ((u64)(0x7553d20990ff9615U)), ((u64)(0x01137367c236c653U)), ((u64)(0x52a8c68bf53f7b9aU)), ((u64)(0x01585041b2c477e8U)), ((u64)(0x6752f82ef28f5a81U)), ((u64)(0x01ae64521f7595e2U)), ((u64)(0x8093db1d57999890U)), ((u64)(0x010cfeb353a97dadU)), ((u64)(0xe0b8d1e4ad7ffeb4U)), ((u64)(0x01503e602893dd18U)), 
((u64)(0x18e7065dd8dffe62U)), ((u64)(0x01a44df832b8d45fU)), ((u64)(0x6f9063faa78bfefdU)), ((u64)(0x0106b0bb1fb384bbU)), ((u64)(0x4b747cf9516efebcU)), ((u64)(0x01485ce9e7a065eaU)), ((u64)(0xde519c37a5cabe6bU)), ((u64)(0x019a742461887f64U)), ((u64)(0x0af301a2c79eb703U)), ((u64)(0x01008896bcf54f9fU)), ((u64)(0xcdafc20b798664c4U)), ((u64)(0x0140aabc6c32a386U)), ((u64)(0x811bb28e57e7fdf5U)), ((u64)(0x0190d56b873f4c68U)), ((u64)(0xa1629f31ede1fd72U)), ((u64)(0x01f50ac6690f1f82U)), 
((u64)(0xa4dda37f34ad3e67U)), ((u64)(0x013926bc01a973b1U)), ((u64)(0x0e150c5f01d88e01U)), ((u64)(0x0187706b0213d09eU)), ((u64)(0x919a4f76c24eb181U)), ((u64)(0x01e94c85c298c4c5U)), ((u64)(0x7b0071aa39712ef1U)), ((u64)(0x0131cfd3999f7afbU)), ((u64)(0x59c08e14c7cd7aadU)), ((u64)(0x017e43c8800759baU)), ((u64)(0xf030b199f9c0d958U)), ((u64)(0x01ddd4baa0093028U)), ((u64)(0x961e6f003c1887d7U)), ((u64)(0x012aa4f4a405be19U)), ((u64)(0xfba60ac04b1ea9cdU)), ((u64)(0x01754e31cd072d9fU)), 
((u64)(0xfa8f8d705de65440U)), ((u64)(0x01d2a1be4048f907U)), ((u64)(0xfc99b8663aaff4a8U)), ((u64)(0x0123a516e82d9ba4U)), ((u64)(0x3bc0267fc95bf1d2U)), ((u64)(0x016c8e5ca239028eU)), ((u64)(0xcab0301fbbb2ee47U)), ((u64)(0x01c7b1f3cac74331U)), ((u64)(0x1eae1e13d54fd4ecU)), ((u64)(0x011ccf385ebc89ffU)), ((u64)(0xe659a598caa3ca27U)), ((u64)(0x01640306766bac7eU)), ((u64)(0x9ff00efefd4cbcb1U)), ((u64)(0x01bd03c81406979eU)), ((u64)(0x23f6095f5e4ff5efU)), ((u64)(0x0116225d0c841ec3U)), 
((u64)(0xecf38bb735e3f36aU)), ((u64)(0x015baaf44fa52673U)), ((u64)(0xe8306ea5035cf045U)), ((u64)(0x01b295b1638e7010U)), ((u64)(0x911e4527221a162bU)), ((u64)(0x010f9d8ede39060aU)), ((u64)(0x3565d670eaa09bb6U)), ((u64)(0x015384f295c7478dU)), ((u64)(0x82bf4c0d2548c2a3U)), ((u64)(0x01a8662f3b391970U)), ((u64)(0x51b78f88374d79a6U)), ((u64)(0x01093fdd8503afe6U)), ((u64)(0xe625736a4520d810U)), ((u64)(0x014b8fd4e6449bdfU)), ((u64)(0xdfaed044d6690e14U)), ((u64)(0x019e73ca1fd5c2d7U)), ((u64)(0xebcd422b0601a8ccU)), ((u64)(0x0103085e53e599c6U)), ((u64)(0xa6c092b5c78212ffU)), ((u64)(0x0143ca75e8df0038U)), ((u64)(0xd070b763396297bfU)), ((u64)(0x0194bd136316c046U)), ((u64)(0x848ce53c07bb3dafU)), ((u64)(0x01f9ec583bdc7058U)), ((u64)(0x52d80f4584d5068dU)), ((u64)(0x013c33b72569c637U)), ((u64)(0x278e1316e60a4831U)), ((u64)(0x018b40a4eec437c5U))}; // fixed array const
Array_fixed_u64_584 _const_strconv__pow5_inv_split_64_x = {((u64)(0x0000000000000001U)), ((u64)(0x0400000000000000U)), ((u64)(0x3333333333333334U)), ((u64)(0x0333333333333333U)), ((u64)(0x28f5c28f5c28f5c3U)), ((u64)(0x028f5c28f5c28f5cU)), ((u64)(0xed916872b020c49cU)), ((u64)(0x020c49ba5e353f7cU)), ((u64)(0xaf4f0d844d013a93U)), ((u64)(0x0346dc5d63886594U)), ((u64)(0x8c3f3e0370cdc876U)), ((u64)(0x029f16b11c6d1e10U)), ((u64)(0xd698fe69270b06c5U)), ((u64)(0x0218def416bdb1a6U)), ((u64)(0xf0f4ca41d811a46eU)), ((u64)(0x035afe535795e90aU)), 
((u64)(0xf3f70834acdae9f1U)), ((u64)(0x02af31dc4611873bU)), ((u64)(0x5cc5a02a23e254c1U)), ((u64)(0x0225c17d04dad296U)), ((u64)(0xfad5cd10396a2135U)), ((u64)(0x036f9bfb3af7b756U)), ((u64)(0xfbde3da69454e75eU)), ((u64)(0x02bfaffc2f2c92abU)), ((u64)(0x2fe4fe1edd10b918U)), ((u64)(0x0232f33025bd4223U)), ((u64)(0x4ca19697c81ac1bfU)), ((u64)(0x0384b84d092ed038U)), ((u64)(0x3d4e1213067bce33U)), ((u64)(0x02d09370d4257360U)), ((u64)(0x643e74dc052fd829U)), ((u64)(0x024075f3dceac2b3U)), 
((u64)(0x6d30baf9a1e626a7U)), ((u64)(0x039a5652fb113785U)), ((u64)(0x2426fbfae7eb5220U)), ((u64)(0x02e1dea8c8da92d1U)), ((u64)(0x1cebfcc8b9890e80U)), ((u64)(0x024e4bba3a487574U)), ((u64)(0x94acc7a78f41b0ccU)), ((u64)(0x03b07929f6da5586U)), ((u64)(0xaa23d2ec729af3d7U)), ((u64)(0x02f394219248446bU)), ((u64)(0xbb4fdbf05baf2979U)), ((u64)(0x025c768141d369efU)), ((u64)(0xc54c931a2c4b758dU)), ((u64)(0x03c7240202ebdcb2U)), ((u64)(0x9dd6dc14f03c5e0bU)), ((u64)(0x0305b66802564a28U)), 
((u64)(0x4b1249aa59c9e4d6U)), ((u64)(0x026af8533511d4edU)), ((u64)(0x44ea0f76f60fd489U)), ((u64)(0x03de5a1ebb4fbb15U)), ((u64)(0x6a54d92bf80caa07U)), ((u64)(0x0318481895d96277U)), ((u64)(0x21dd7a89933d54d2U)), ((u64)(0x0279d346de4781f9U)), ((u64)(0x362f2a75b8622150U)), ((u64)(0x03f61ed7ca0c0328U)), ((u64)(0xf825bb91604e810dU)), ((u64)(0x032b4bdfd4d668ecU)), ((u64)(0xc684960de6a5340bU)), ((u64)(0x0289097fdd7853f0U)), ((u64)(0xd203ab3e521dc33cU)), ((u64)(0x02073accb12d0ff3U)), 
((u64)(0xe99f7863b696052cU)), ((u64)(0x033ec47ab514e652U)), ((u64)(0x87b2c6b62bab3757U)), ((u64)(0x02989d2ef743eb75U)), ((u64)(0xd2f56bc4efbc2c45U)), ((u64)(0x0213b0f25f69892aU)), ((u64)(0x1e55793b192d13a2U)), ((u64)(0x0352b4b6ff0f41deU)), ((u64)(0x4b77942f475742e8U)), ((u64)(0x02a8909265a5ce4bU)), ((u64)(0xd5f9435905df68baU)), ((u64)(0x022073a8515171d5U)), ((u64)(0x565b9ef4d6324129U)), ((u64)(0x03671f73b54f1c89U)), ((u64)(0xdeafb25d78283421U)), ((u64)(0x02b8e5f62aa5b06dU)), 
((u64)(0x188c8eb12cecf681U)), ((u64)(0x022d84c4eeeaf38bU)), ((u64)(0x8dadb11b7b14bd9bU)), ((u64)(0x037c07a17e44b8deU)), ((u64)(0x7157c0e2c8dd647cU)), ((u64)(0x02c99fb46503c718U)), ((u64)(0x8ddfcd823a4ab6caU)), ((u64)(0x023ae629ea696c13U)), ((u64)(0x1632e269f6ddf142U)), ((u64)(0x0391704310a8acecU)), ((u64)(0x44f581ee5f17f435U)), ((u64)(0x02dac035a6ed5723U)), ((u64)(0x372ace584c1329c4U)), ((u64)(0x024899c4858aac1cU)), ((u64)(0xbeaae3c079b842d3U)), ((u64)(0x03a75c6da27779c6U)), 
((u64)(0x6555830061603576U)), ((u64)(0x02ec49f14ec5fb05U)), ((u64)(0xb7779c004de6912bU)), ((u64)(0x0256a18dd89e626aU)), ((u64)(0xf258f99a163db512U)), ((u64)(0x03bdcf495a9703ddU)), ((u64)(0x5b7a614811caf741U)), ((u64)(0x02fe3f6de212697eU)), ((u64)(0xaf951aa00e3bf901U)), ((u64)(0x0264ff8b1b41edfeU)), ((u64)(0x7f54f7667d2cc19bU)), ((u64)(0x03d4cc11c5364997U)), ((u64)(0x32aa5f8530f09ae3U)), ((u64)(0x0310a3416a91d479U)), ((u64)(0xf55519375a5a1582U)), ((u64)(0x0273b5cdeedb1060U)), 
((u64)(0xbbbb5b8bc3c3559dU)), ((u64)(0x03ec56164af81a34U)), ((u64)(0x2fc916096969114aU)), ((u64)(0x03237811d593482aU)), ((u64)(0x596dab3ababa743cU)), ((u64)(0x0282c674aadc39bbU)), ((u64)(0x478aef622efb9030U)), ((u64)(0x0202385d557cfafcU)), ((u64)(0xd8de4bd04b2c19e6U)), ((u64)(0x0336c0955594c4c6U)), ((u64)(0xad7ea30d08f014b8U)), ((u64)(0x029233aaaadd6a38U)), ((u64)(0x24654f3da0c01093U)), ((u64)(0x020e8fbbbbe454faU)), ((u64)(0x3a3bb1fc346680ebU)), ((u64)(0x034a7f92c63a2190U)), 
((u64)(0x94fc8e635d1ecd89U)), ((u64)(0x02a1ffa89e94e7a6U)), ((u64)(0xaa63a51c4a7f0ad4U)), ((u64)(0x021b32ed4baa52ebU)), ((u64)(0xdd6c3b607731aaedU)), ((u64)(0x035eb7e212aa1e45U)), ((u64)(0x1789c919f8f488bdU)), ((u64)(0x02b22cb4dbbb4b6bU)), ((u64)(0xac6e3a7b2d906d64U)), ((u64)(0x022823c3e2fc3c55U)), ((u64)(0x13e390c515b3e23aU)), ((u64)(0x03736c6c9e606089U)), ((u64)(0xdcb60d6a77c31b62U)), ((u64)(0x02c2bd23b1e6b3a0U)), ((u64)(0x7d5e7121f968e2b5U)), ((u64)(0x0235641c8e52294dU)), 
((u64)(0xc8971b698f0e3787U)), ((u64)(0x0388a02db0837548U)), ((u64)(0xa078e2bad8d82c6cU)), ((u64)(0x02d3b357c0692aa0U)), ((u64)(0xe6c71bc8ad79bd24U)), ((u64)(0x0242f5dfcd20eee6U)), ((u64)(0x0ad82c7448c2c839U)), ((u64)(0x039e5632e1ce4b0bU)), ((u64)(0x3be023903a356cfaU)), ((u64)(0x02e511c24e3ea26fU)), ((u64)(0x2fe682d9c82abd95U)), ((u64)(0x0250db01d8321b8cU)), ((u64)(0x4ca4048fa6aac8eeU)), ((u64)(0x03b4919c8d1cf8e0U)), ((u64)(0x3d5003a61eef0725U)), ((u64)(0x02f6dae3a4172d80U)), 
((u64)(0x9773361e7f259f51U)), ((u64)(0x025f1582e9ac2466U)), ((u64)(0x8beb89ca6508fee8U)), ((u64)(0x03cb559e42ad070aU)), ((u64)(0x6fefa16eb73a6586U)), ((u64)(0x0309114b688a6c08U)), ((u64)(0xf3261abef8fb846bU)), ((u64)(0x026da76f86d52339U)), ((u64)(0x51d691318e5f3a45U)), ((u64)(0x03e2a57f3e21d1f6U)), ((u64)(0x0e4540f471e5c837U)), ((u64)(0x031bb798fe8174c5U)), ((u64)(0xd8376729f4b7d360U)), ((u64)(0x027c92e0cb9ac3d0U)), ((u64)(0xf38bd84321261effU)), ((u64)(0x03fa849adf5e061aU)), 
((u64)(0x293cad0280eb4bffU)), ((u64)(0x032ed07be5e4d1afU)), ((u64)(0xedca240200bc3cccU)), ((u64)(0x028bd9fcb7ea4158U)), ((u64)(0xbe3b50019a3030a4U)), ((u64)(0x02097b309321cde0U)), ((u64)(0xc9f88002904d1a9fU)), ((u64)(0x03425eb41e9c7c9aU)), ((u64)(0x3b2d3335403daee6U)), ((u64)(0x029b7ef67ee396e2U)), ((u64)(0x95bdc291003158b8U)), ((u64)(0x0215ff2b98b6124eU)), ((u64)(0x892f9db4cd1bc126U)), ((u64)(0x035665128df01d4aU)), ((u64)(0x07594af70a7c9a85U)), ((u64)(0x02ab840ed7f34aa2U)), 
((u64)(0x6c476f2c0863aed1U)), ((u64)(0x0222d00bdff5d54eU)), ((u64)(0x13a57eacda3917b4U)), ((u64)(0x036ae67966562217U)), ((u64)(0x0fb7988a482dac90U)), ((u64)(0x02bbeb9451de81acU)), ((u64)(0xd95fad3b6cf156daU)), ((u64)(0x022fefa9db1867bcU)), ((u64)(0xf565e1f8ae4ef15cU)), ((u64)(0x037fe5dc91c0a5faU)), ((u64)(0x911e4e608b725ab0U)), ((u64)(0x02ccb7e3a7cd5195U)), ((u64)(0xda7ea51a0928488dU)), ((u64)(0x023d5fe9530aa7aaU)), ((u64)(0xf7310829a8407415U)), ((u64)(0x039566421e7772aaU)), 
((u64)(0x2c2739baed005cdeU)), ((u64)(0x02ddeb68185f8eefU)), ((u64)(0xbcec2e2f24004a4bU)), ((u64)(0x024b22b9ad193f25U)), ((u64)(0x94ad16b1d333aa11U)), ((u64)(0x03ab6ac2ae8ecb6fU)), ((u64)(0xaa241227dc2954dbU)), ((u64)(0x02ef889bbed8a2bfU)), ((u64)(0x54e9a81fe35443e2U)), ((u64)(0x02593a163246e899U)), ((u64)(0x2175d9cc9eed396aU)), ((u64)(0x03c1f689ea0b0dc2U)), ((u64)(0xe7917b0a18bdc788U)), ((u64)(0x03019207ee6f3e34U)), ((u64)(0xb9412f3b46fe393aU)), ((u64)(0x0267a8065858fe90U)), 
((u64)(0xf535185ed7fd285cU)), ((u64)(0x03d90cd6f3c1974dU)), ((u64)(0xc42a79e57997537dU)), ((u64)(0x03140a458fce12a4U)), ((u64)(0x03552e512e12a931U)), ((u64)(0x02766e9e0ca4dbb7U)), ((u64)(0x9eeeb081e3510eb4U)), ((u64)(0x03f0b0fce107c5f1U)), ((u64)(0x4bf226ce4f740bc3U)), ((u64)(0x0326f3fd80d304c1U)), ((u64)(0xa3281f0b72c33c9cU)), ((u64)(0x02858ffe00a8d09aU)), ((u64)(0x1c2018d5f568fd4aU)), ((u64)(0x020473319a20a6e2U)), ((u64)(0xf9ccf48988a7fba9U)), ((u64)(0x033a51e8f69aa49cU)), 
((u64)(0xfb0a5d3ad3b99621U)), ((u64)(0x02950e53f87bb6e3U)), ((u64)(0x2f3b7dc8a96144e7U)), ((u64)(0x0210d8432d2fc583U)), ((u64)(0xe52bfc7442353b0cU)), ((u64)(0x034e26d1e1e608d1U)), ((u64)(0xb756639034f76270U)), ((u64)(0x02a4ebdb1b1e6d74U)), ((u64)(0x2c451c735d92b526U)), ((u64)(0x021d897c15b1f12aU)), ((u64)(0x13a1c71efc1deea3U)), ((u64)(0x0362759355e981ddU)), ((u64)(0x761b05b2634b2550U)), ((u64)(0x02b52adc44bace4aU)), ((u64)(0x91af37c1e908eaa6U)), ((u64)(0x022a88b036fbd83bU)), 
((u64)(0x82b1f2cfdb417770U)), ((u64)(0x03774119f192f392U)), ((u64)(0xcef4c23fe29ac5f3U)), ((u64)(0x02c5cdae5adbf60eU)), ((u64)(0x3f2a34ffe87bd190U)), ((u64)(0x0237d7beaf165e72U)), ((u64)(0x984387ffda5fb5b2U)), ((u64)(0x038c8c644b56fd83U)), ((u64)(0xe0360666484c915bU)), ((u64)(0x02d6d6b6a2abfe02U)), ((u64)(0x802b3851d3707449U)), ((u64)(0x024578921bbccb35U)), ((u64)(0x99dec082ebe72075U)), ((u64)(0x03a25a835f947855U)), ((u64)(0xae4bcd358985b391U)), ((u64)(0x02e8486919439377U)), 
((u64)(0xbea30a913ad15c74U)), ((u64)(0x02536d20e102dc5fU)), ((u64)(0xfdd1aa81f7b560b9U)), ((u64)(0x03b8ae9b019e2d65U)), ((u64)(0x97daeece5fc44d61U)), ((u64)(0x02fa2548ce182451U)), ((u64)(0xdfe258a51969d781U)), ((u64)(0x0261b76d71ace9daU)), ((u64)(0x996a276e8f0fbf34U)), ((u64)(0x03cf8be24f7b0fc4U)), ((u64)(0xe121b9253f3fcc2aU)), ((u64)(0x030c6fe83f95a636U)), ((u64)(0xb41afa8432997022U)), ((u64)(0x02705986994484f8U)), ((u64)(0xecf7f739ea8f19cfU)), ((u64)(0x03e6f5a4286da18dU)), 
((u64)(0x23f99294bba5ae40U)), ((u64)(0x031f2ae9b9f14e0bU)), ((u64)(0x4ffadbaa2fb7be99U)), ((u64)(0x027f5587c7f43e6fU)), ((u64)(0x7ff7c5dd1925fdc2U)), ((u64)(0x03feef3fa6539718U)), ((u64)(0xccc637e4141e649bU)), ((u64)(0x033258ffb842df46U)), ((u64)(0xd704f983434b83afU)), ((u64)(0x028ead9960357f6bU)), ((u64)(0x126a6135cf6f9c8cU)), ((u64)(0x020bbe144cf79923U)), ((u64)(0x83dd685618b29414U)), ((u64)(0x0345fced47f28e9eU)), ((u64)(0x9cb12044e08edcddU)), ((u64)(0x029e63f1065ba54bU)), 
((u64)(0x16f419d0b3a57d7dU)), ((u64)(0x02184ff405161dd6U)), ((u64)(0x8b20294dec3bfbfbU)), ((u64)(0x035a19866e89c956U)), ((u64)(0x3c19baa4bcfcc996U)), ((u64)(0x02ae7ad1f207d445U)), ((u64)(0xc9ae2eea30ca3adfU)), ((u64)(0x02252f0e5b39769dU)), ((u64)(0x0f7d17dd1add2afdU)), ((u64)(0x036eb1b091f58a96U)), ((u64)(0x3f97464a7be42264U)), ((u64)(0x02bef48d41913babU)), ((u64)(0xcc790508631ce850U)), ((u64)(0x02325d3dce0dc955U)), ((u64)(0xe0c1a1a704fb0d4dU)), ((u64)(0x0383c862e3494222U)), 
((u64)(0x4d67b4859d95a43eU)), ((u64)(0x02cfd3824f6dce82U)), ((u64)(0x711fc39e17aae9cbU)), ((u64)(0x023fdc683f8b0b9bU)), ((u64)(0xe832d2968c44a945U)), ((u64)(0x039960a6cc11ac2bU)), ((u64)(0xecf575453d03ba9eU)), ((u64)(0x02e11a1f09a7bcefU)), ((u64)(0x572ac4376402fbb1U)), ((u64)(0x024dae7f3aec9726U)), ((u64)(0x58446d256cd192b5U)), ((u64)(0x03af7d985e47583dU)), ((u64)(0x79d0575123dadbc4U)), ((u64)(0x02f2cae04b6c4697U)), ((u64)(0x94a6ac40e97be303U)), ((u64)(0x025bd5803c569edfU)), 
((u64)(0x8771139b0f2c9e6cU)), ((u64)(0x03c62266c6f0fe32U)), ((u64)(0x9f8da948d8f07ebdU)), ((u64)(0x0304e85238c0cb5bU)), ((u64)(0xe60aedd3e0c06564U)), ((u64)(0x026a5374fa33d5e2U)), ((u64)(0xa344afb9679a3bd2U)), ((u64)(0x03dd5254c3862304U)), ((u64)(0xe903bfc78614fca8U)), ((u64)(0x031775109c6b4f36U)), ((u64)(0xba6966393810ca20U)), ((u64)(0x02792a73b055d8f8U)), ((u64)(0x2a423d2859b4769aU)), ((u64)(0x03f510b91a22f4c1U)), ((u64)(0xee9b642047c39215U)), ((u64)(0x032a73c7481bf700U)), 
((u64)(0xbee2b680396941aaU)), ((u64)(0x02885c9f6ce32c00U)), ((u64)(0xff1bc53361210155U)), ((u64)(0x0206b07f8a4f5666U)), ((u64)(0x31c6085235019bbbU)), ((u64)(0x033de73276e5570bU)), ((u64)(0x27d1a041c4014963U)), ((u64)(0x0297ec285f1ddf3cU)), ((u64)(0xeca7b367d0010782U)), ((u64)(0x021323537f4b18fcU)), ((u64)(0xadd91f0c8001a59dU)), ((u64)(0x0351d21f3211c194U)), ((u64)(0xf17a7f3d3334847eU)), ((u64)(0x02a7db4c280e3476U)), ((u64)(0x279532975c2a0398U)), ((u64)(0x021fe2a3533e905fU)), 
((u64)(0xd8eeb75893766c26U)), ((u64)(0x0366376bb8641a31U)), ((u64)(0x7a5892ad42c52352U)), ((u64)(0x02b82c562d1ce1c1U)), ((u64)(0xfb7a0ef102374f75U)), ((u64)(0x022cf044f0e3e7cdU)), ((u64)(0xc59017e8038bb254U)), ((u64)(0x037b1a07e7d30c7cU)), ((u64)(0x37a67986693c8eaaU)), ((u64)(0x02c8e19feca8d6caU)), ((u64)(0xf951fad1edca0bbbU)), ((u64)(0x023a4e198a20abd4U)), ((u64)(0x28832ae97c76792bU)), ((u64)(0x03907cf5a9cddfbbU)), ((u64)(0x2068ef21305ec756U)), ((u64)(0x02d9fd9154a4b2fcU)), 
((u64)(0x19ed8c1a8d189f78U)), ((u64)(0x0247fe0ddd508f30U)), ((u64)(0x5caf4690e1c0ff26U)), ((u64)(0x03a66349621a7eb3U)), ((u64)(0x4a25d20d81673285U)), ((u64)(0x02eb82a11b48655cU)), ((u64)(0x3b5174d79ab8f537U)), ((u64)(0x0256021a7c39eab0U)), ((u64)(0x921bee25c45b21f1U)), ((u64)(0x03bcd02a605caab3U)), ((u64)(0xdb498b5169e2818eU)), ((u64)(0x02fd735519e3bbc2U)), ((u64)(0x15d46f7454b53472U)), ((u64)(0x02645c4414b62fcfU)), ((u64)(0xefba4bed545520b6U)), ((u64)(0x03d3c6d35456b2e4U)), 
((u64)(0xf2fb6ff110441a2bU)), ((u64)(0x030fd242a9def583U)), ((u64)(0x8f2f8cc0d9d014efU)), ((u64)(0x02730e9bbb18c469U)), ((u64)(0xb1e5ae015c80217fU)), ((u64)(0x03eb4a92c4f46d75U)), ((u64)(0xc1848b344a001accU)), ((u64)(0x0322a20f03f6bdf7U)), ((u64)(0xce03a2903b3348a3U)), ((u64)(0x02821b3f365efe5fU)), ((u64)(0xd802e873628f6d4fU)), ((u64)(0x0201af65c518cb7fU)), ((u64)(0x599e40b89db2487fU)), ((u64)(0x0335e56fa1c14599U)), ((u64)(0xe14b66fa17c1d399U)), ((u64)(0x029184594e3437adU)), 
((u64)(0x81091f2e7967dc7aU)), ((u64)(0x020e037aa4f692f1U)), ((u64)(0x9b41cb7d8f0c93f6U)), ((u64)(0x03499f2aa18a84b5U)), ((u64)(0xaf67d5fe0c0a0ff8U)), ((u64)(0x02a14c221ad536f7U)), ((u64)(0xf2b977fe70080cc7U)), ((u64)(0x021aa34e7bddc592U)), ((u64)(0x1df58cca4cd9ae0bU)), ((u64)(0x035dd2172c9608ebU)), ((u64)(0xe4c470a1d7148b3cU)), ((u64)(0x02b174df56de6d88U)), ((u64)(0x83d05a1b1276d5caU)), ((u64)(0x022790b2abe5246dU)), ((u64)(0x9fb3c35e83f1560fU)), ((u64)(0x0372811ddfd50715U)), 
((u64)(0xb2f635e5365aab3fU)), ((u64)(0x02c200e4b310d277U)), ((u64)(0xf591c4b75eaeef66U)), ((u64)(0x0234cd83c273db92U)), ((u64)(0xef4fa125644b18a3U)), ((u64)(0x0387af39371fc5b7U)), ((u64)(0x8c3fb41de9d5ad4fU)), ((u64)(0x02d2f2942c196af9U)), ((u64)(0x3cffc34b2177bdd9U)), ((u64)(0x02425ba9bce12261U)), ((u64)(0x94cc6bab68bf9628U)), ((u64)(0x039d5f75fb01d09bU)), ((u64)(0x10a38955ed6611b9U)), ((u64)(0x02e44c5e6267da16U)), ((u64)(0xda1c6dde5784dafbU)), ((u64)(0x02503d184eb97b44U)), 
((u64)(0xf693e2fd58d49191U)), ((u64)(0x03b394f3b128c53aU)), ((u64)(0xc5431bfde0aa0e0eU)), ((u64)(0x02f610c2f4209dc8U)), ((u64)(0x6a9c1664b3bb3e72U)), ((u64)(0x025e73cf29b3b16dU)), ((u64)(0x10f9bd6dec5eca4fU)), ((u64)(0x03ca52e50f85e8afU)), ((u64)(0xda616457f04bd50cU)), ((u64)(0x03084250d937ed58U)), ((u64)(0xe1e783798d09773dU)), ((u64)(0x026d01da475ff113U)), ((u64)(0x030c058f480f252eU)), ((u64)(0x03e19c9072331b53U)), ((u64)(0x68d66ad906728425U)), ((u64)(0x031ae3a6c1c27c42U)), 
((u64)(0x8711ef14052869b7U)), ((u64)(0x027be952349b969bU)), ((u64)(0x0b4fe4ecd50d75f2U)), ((u64)(0x03f97550542c242cU)), ((u64)(0xa2a650bd773df7f5U)), ((u64)(0x032df7737689b689U)), ((u64)(0xb551da312c31932aU)), ((u64)(0x028b2c5c5ed49207U)), ((u64)(0x5ddb14f4235adc22U)), ((u64)(0x0208f049e576db39U)), ((u64)(0x2fc4ee536bc49369U)), ((u64)(0x034180763bf15ec2U)), ((u64)(0xbfd0bea92303a921U)), ((u64)(0x029acd2b63277f01U)), ((u64)(0x9973cbba8269541aU)), ((u64)(0x021570ef8285ff34U)), 
((u64)(0x5bec792a6a42202aU)), ((u64)(0x0355817f373ccb87U)), ((u64)(0xe3239421ee9b4cefU)), ((u64)(0x02aacdff5f63d605U)), ((u64)(0xb5b6101b25490a59U)), ((u64)(0x02223e65e5e97804U)), ((u64)(0x22bce691d541aa27U)), ((u64)(0x0369fd6fd64259a1U)), ((u64)(0xb563eba7ddce21b9U)), ((u64)(0x02bb31264501e14dU)), ((u64)(0xf78322ecb171b494U)), ((u64)(0x022f5a850401810aU)), ((u64)(0x259e9e47824f8753U)), ((u64)(0x037ef73b399c01abU)), ((u64)(0x1e187e9f9b72d2a9U)), ((u64)(0x02cbf8fc2e1667bcU)), 
((u64)(0x4b46cbb2e2c24221U)), ((u64)(0x023cc73024deb963U)), ((u64)(0x120adf849e039d01U)), ((u64)(0x039471e6a1645bd2U)), ((u64)(0xdb3be603b19c7d9aU)), ((u64)(0x02dd27ebb4504974U)), ((u64)(0x7c2feb3627b0647cU)), ((u64)(0x024a865629d9d45dU)), ((u64)(0x2d197856a5e7072cU)), ((u64)(0x03aa7089dc8fba2fU)), ((u64)(0x8a7ac6abb7ec05bdU)), ((u64)(0x02eec06e4a0c94f2U)), ((u64)(0xd52f05562cbcd164U)), ((u64)(0x025899f1d4d6dd8eU)), ((u64)(0x21e4d556adfae8a0U)), ((u64)(0x03c0f64fbaf1627eU)), 
((u64)(0xe7ea444557fbed4dU)), ((u64)(0x0300c50c958de864U)), ((u64)(0xecbb69d1132ff10aU)), ((u64)(0x0267040a113e5383U)), ((u64)(0xadf8a94e851981aaU)), ((u64)(0x03d8067681fd526cU)), ((u64)(0x8b2d543ed0e13488U)), ((u64)(0x0313385ece6441f0U)), ((u64)(0xd5bddcff0d80f6d3U)), ((u64)(0x0275c6b23eb69b26U)), ((u64)(0x892fc7fe7c018aebU)), ((u64)(0x03efa45064575ea4U)), ((u64)(0x3a8c9ffec99ad589U)), ((u64)(0x03261d0d1d12b21dU)), ((u64)(0xc8707fff07af113bU)), ((u64)(0x0284e40a7da88e7dU)), 
((u64)(0x39f39998d2f2742fU)), ((u64)(0x0203e9a1fe2071feU)), ((u64)(0x8fec28f484b7204bU)), ((u64)(0x033975cffd00b663U)), ((u64)(0xd989ba5d36f8e6a2U)), ((u64)(0x02945e3ffd9a2b82U)), ((u64)(0x47a161e42bfa521cU)), ((u64)(0x02104b66647b5602U)), ((u64)(0x0c35696d132a1cf9U)), ((u64)(0x034d4570a0c5566aU)), ((u64)(0x09c454574288172dU)), ((u64)(0x02a4378d4d6aab88U)), ((u64)(0xa169dd129ba0128bU)), ((u64)(0x021cf93dd7888939U)), ((u64)(0x0242fb50f9001dabU)), ((u64)(0x03618ec958da7529U)), 
((u64)(0x9b68c90d940017bcU)), ((u64)(0x02b4723aad7b90edU)), ((u64)(0x4920a0d7a999ac96U)), ((u64)(0x0229f4fbbdfc73f1U)), ((u64)(0x750101590f5c4757U)), ((u64)(0x037654c5fcc71fe8U)), ((u64)(0x2a6734473f7d05dfU)), ((u64)(0x02c5109e63d27fedU)), ((u64)(0xeeb8f69f65fd9e4cU)), ((u64)(0x0237407eb641fff0U)), ((u64)(0xe45b24323cc8fd46U)), ((u64)(0x038b9a6456cfffe7U)), ((u64)(0xb6af502830a0ca9fU)), ((u64)(0x02d6151d123fffecU)), ((u64)(0xf88c402026e7087fU)), ((u64)(0x0244ddb0db666656U)), 
((u64)(0x2746cd003e3e73feU)), ((u64)(0x03a162b4923d708bU)), ((u64)(0x1f6bd73364fec332U)), ((u64)(0x02e7822a0e978d3cU)), ((u64)(0xe5efdf5c50cbcf5bU)), ((u64)(0x0252ce880bac70fcU)), ((u64)(0x3cb2fefa1adfb22bU)), ((u64)(0x03b7b0d9ac471b2eU)), ((u64)(0x308f3261af195b56U)), ((u64)(0x02f95a47bd05af58U)), ((u64)(0x5a0c284e25ade2abU)), ((u64)(0x0261150630d15913U)), ((u64)(0x29ad0d49d5e30445U)), ((u64)(0x03ce8809e7b55b52U)), ((u64)(0x548a7107de4f369dU)), ((u64)(0x030ba007ec9115dbU)), ((u64)(0xdd3b8d9fe50c2bb1U)), ((u64)(0x026fb3398a0dab15U)), ((u64)(0x952c15cca1ad12b5U)), ((u64)(0x03e5eb8f434911bcU)), ((u64)(0x775677d6e7bda891U)), ((u64)(0x031e560c35d40e30U)), ((u64)(0xc5dec645863153a7U)), ((u64)(0x027eab3cf7dcd826U))}; // fixed array const
bool v_memory_panic = false; // global 6

i64 total_m = ((i64)(0)); // global 6

int g_main_argc = ((int)(0)); // global 6

voidptr g_main_argv = ((void*)0); // global 6

voidptr g_live_reload_info; // global 6

Array_VCastTypeIndexName as_cast_type_indexes; // global 6

i64 _const_min_i64; // inited later
i64 _const_max_i64; // inited later
const u64 _const_max_u64 = 18446744073709551615U; // precomputed2
const f64 _const_max_load_factor = 0.8; // precomputed2
const u32 _const_hash_mask = 16777215; // precomputed2
const u32 _const_probe_inc = 16777216; // precomputed2
IError _const_none__; // inited later
Array_fixed_i32_1264 _const_rune_maps = {((i32)(0xB5)), 0xB5, 743, 0, 0xC0, 0xD6, 0, 32, 0xD8, 0xDE, 0, 32, 0xE0, 0xF6, -32, 0, 
0xF8, 0xFE, -32, 0, 0xFF, 0xFF, 121, 0, 0x100, 0x12F, -3, -3, 0x130, 0x130, 0, -199, 
0x131, 0x131, -232, 0, 0x132, 0x137, -3, -3, 0x139, 0x148, -3, -3, 0x14A, 0x177, -3, -3, 
0x178, 0x178, 0, -121, 0x179, 0x17E, -3, -3, 0x17F, 0x17F, -300, 0, 0x180, 0x180, 195, 0, 
0x181, 0x181, 0, 210, 0x182, 0x185, -3, -3, 0x186, 0x186, 0, 206, 0x187, 0x188, -3, -3, 
0x189, 0x18A, 0, 205, 0x18B, 0x18C, -3, -3, 0x18E, 0x18E, 0, 79, 0x18F, 0x18F, 0, 202, 
0x190, 0x190, 0, 203, 0x191, 0x192, -3, -3, 0x193, 0x193, 0, 205, 0x194, 0x194, 0, 207, 
0x195, 0x195, 97, 0, 0x196, 0x196, 0, 211, 0x197, 0x197, 0, 209, 0x198, 0x199, -3, -3, 
0x19A, 0x19A, 163, 0, 0x19C, 0x19C, 0, 211, 0x19D, 0x19D, 0, 213, 0x19E, 0x19E, 130, 0, 
0x19F, 0x19F, 0, 214, 0x1A0, 0x1A5, -3, -3, 0x1A6, 0x1A6, 0, 218, 0x1A7, 0x1A8, -3, -3, 
0x1A9, 0x1A9, 0, 218, 0x1AC, 0x1AD, -3, -3, 0x1AE, 0x1AE, 0, 218, 0x1AF, 0x1B0, -3, -3, 
0x1B1, 0x1B2, 0, 217, 0x1B3, 0x1B6, -3, -3, 0x1B7, 0x1B7, 0, 219, 0x1B8, 0x1B9, -3, -3, 
0x1BC, 0x1BD, -3, -3, 0x1BF, 0x1BF, 56, 0, 0x1C4, 0x1CC, -2, -2, 0x1CD, 0x1DC, -3, -3, 
0x1DD, 0x1DD, -79, 0, 0x1DE, 0x1EF, -3, -3, 0x1F1, 0x1F3, -2, -2, 0x1F4, 0x1F5, -3, -3, 
0x1F6, 0x1F6, 0, -97, 0x1F7, 0x1F7, 0, -56, 0x1F8, 0x21F, -3, -3, 0x220, 0x220, 0, -130, 
0x222, 0x233, -3, -3, 0x23A, 0x23A, 0, 10795, 0x23B, 0x23C, -3, -3, 0x23D, 0x23D, 0, -163, 
0x23E, 0x23E, 0, 10792, 0x23F, 0x240, 10815, 0, 0x241, 0x242, -3, -3, 0x243, 0x243, 0, -195, 
0x244, 0x244, 0, 69, 0x245, 0x245, 0, 71, 0x246, 0x24F, -3, -3, 0x250, 0x250, 10783, 0, 
0x251, 0x251, 10780, 0, 0x252, 0x252, 10782, 0, 0x253, 0x253, -210, 0, 0x254, 0x254, -206, 0, 
0x256, 0x257, -205, 0, 0x259, 0x259, -202, 0, 0x25B, 0x25B, -203, 0, 0x25C, 0x25C, 42319, 0, 
0x260, 0x260, -205, 0, 0x261, 0x261, 42315, 0, 0x263, 0x263, -207, 0, 0x265, 0x265, 42280, 0, 
0x266, 0x266, 42308, 0, 0x268, 0x268, -209, 0, 0x269, 0x269, -211, 0, 0x26A, 0x26A, 42308, 0, 
0x26B, 0x26B, 10743, 0, 0x26C, 0x26C, 42305, 0, 0x26F, 0x26F, -211, 0, 0x271, 0x271, 10749, 0, 
0x272, 0x272, -213, 0, 0x275, 0x275, -214, 0, 0x27D, 0x27D, 10727, 0, 0x280, 0x280, -218, 0, 
0x282, 0x282, 42307, 0, 0x283, 0x283, -218, 0, 0x287, 0x287, 42282, 0, 0x288, 0x288, -218, 0, 
0x289, 0x289, -69, 0, 0x28A, 0x28B, -217, 0, 0x28C, 0x28C, -71, 0, 0x292, 0x292, -219, 0, 
0x29D, 0x29D, 42261, 0, 0x29E, 0x29E, 42258, 0, 0x345, 0x345, 84, 0, 0x370, 0x373, -3, -3, 
0x376, 0x377, -3, -3, 0x37B, 0x37D, 130, 0, 0x37F, 0x37F, 0, 116, 0x386, 0x386, 0, 38, 
0x388, 0x38A, 0, 37, 0x38C, 0x38C, 0, 64, 0x38E, 0x38F, 0, 63, 0x391, 0x3A1, 0, 32, 
0x3A3, 0x3AB, 0, 32, 0x3AC, 0x3AC, -38, 0, 0x3AD, 0x3AF, -37, 0, 0x3B1, 0x3C1, -32, 0, 
0x3C2, 0x3C2, -31, 0, 0x3C3, 0x3CB, -32, 0, 0x3CC, 0x3CC, -64, 0, 0x3CD, 0x3CE, -63, 0, 
0x3CF, 0x3CF, 0, 8, 0x3D0, 0x3D0, -62, 0, 0x3D1, 0x3D1, -57, 0, 0x3D5, 0x3D5, -47, 0, 
0x3D6, 0x3D6, -54, 0, 0x3D7, 0x3D7, -8, 0, 0x3D8, 0x3EF, -3, -3, 0x3F0, 0x3F0, -86, 0, 
0x3F1, 0x3F1, -80, 0, 0x3F2, 0x3F2, 7, 0, 0x3F3, 0x3F3, -116, 0, 0x3F4, 0x3F4, 0, -60, 
0x3F5, 0x3F5, -96, 0, 0x3F7, 0x3F8, -3, -3, 0x3F9, 0x3F9, 0, -7, 0x3FA, 0x3FB, -3, -3, 
0x3FD, 0x3FF, 0, -130, 0x400, 0x40F, 0, 80, 0x410, 0x42F, 0, 32, 0x430, 0x44F, -32, 0, 
0x450, 0x45F, -80, 0, 0x460, 0x481, -3, -3, 0x48A, 0x4BF, -3, -3, 0x4C0, 0x4C0, 0, 15, 
0x4C1, 0x4CE, -3, -3, 0x4CF, 0x4CF, -15, 0, 0x4D0, 0x52F, -3, -3, 0x531, 0x556, 0, 48, 
0x561, 0x586, -48, 0, 0x10A0, 0x10C5, 0, 7264, 0x10C7, 0x10C7, 0, 7264, 0x10CD, 0x10CD, 0, 7264, 
0x10D0, 0x10FA, 3008, 0, 0x10FD, 0x10FF, 3008, 0, 0x13A0, 0x13EF, 0, 38864, 0x13F0, 0x13F5, 0, 8, 
0x13F8, 0x13FD, -8, 0, 0x1C80, 0x1C80, -6254, 0, 0x1C81, 0x1C81, -6253, 0, 0x1C82, 0x1C82, -6244, 0, 
0x1C83, 0x1C84, -6242, 0, 0x1C85, 0x1C85, -6243, 0, 0x1C86, 0x1C86, -6236, 0, 0x1C87, 0x1C87, -6181, 0, 
0x1C88, 0x1C88, 35266, 0, 0x1C90, 0x1CBA, 0, -3008, 0x1CBD, 0x1CBF, 0, -3008, 0x1D79, 0x1D79, 35332, 0, 
0x1D7D, 0x1D7D, 3814, 0, 0x1D8E, 0x1D8E, 35384, 0, 0x1E00, 0x1E95, -3, -3, 0x1E9B, 0x1E9B, -59, 0, 
0x1E9E, 0x1E9E, 0, -7615, 0x1EA0, 0x1EFF, -3, -3, 0x1F00, 0x1F07, 8, 0, 0x1F08, 0x1F0F, 0, -8, 
0x1F10, 0x1F15, 8, 0, 0x1F18, 0x1F1D, 0, -8, 0x1F20, 0x1F27, 8, 0, 0x1F28, 0x1F2F, 0, -8, 
0x1F30, 0x1F37, 8, 0, 0x1F38, 0x1F3F, 0, -8, 0x1F40, 0x1F45, 8, 0, 0x1F48, 0x1F4D, 0, -8, 
0x1F51, 0x1F51, 8, 0, 0x1F53, 0x1F53, 8, 0, 0x1F55, 0x1F55, 8, 0, 0x1F57, 0x1F57, 8, 0, 
0x1F59, 0x1F59, 0, -8, 0x1F5B, 0x1F5B, 0, -8, 0x1F5D, 0x1F5D, 0, -8, 0x1F5F, 0x1F5F, 0, -8, 
0x1F60, 0x1F67, 8, 0, 0x1F68, 0x1F6F, 0, -8, 0x1F70, 0x1F71, 74, 0, 0x1F72, 0x1F75, 86, 0, 
0x1F76, 0x1F77, 100, 0, 0x1F78, 0x1F79, 128, 0, 0x1F7A, 0x1F7B, 112, 0, 0x1F7C, 0x1F7D, 126, 0, 
0x1F80, 0x1F87, 8, 0, 0x1F88, 0x1F8F, 0, -8, 0x1F90, 0x1F97, 8, 0, 0x1F98, 0x1F9F, 0, -8, 
0x1FA0, 0x1FA7, 8, 0, 0x1FA8, 0x1FAF, 0, -8, 0x1FB0, 0x1FB1, 8, 0, 0x1FB3, 0x1FB3, 9, 0, 
0x1FB8, 0x1FB9, 0, -8, 0x1FBA, 0x1FBB, 0, -74, 0x1FBC, 0x1FBC, 0, -9, 0x1FBE, 0x1FBE, -7205, 0, 
0x1FC3, 0x1FC3, 9, 0, 0x1FC8, 0x1FCB, 0, -86, 0x1FCC, 0x1FCC, 0, -9, 0x1FD0, 0x1FD1, 8, 0, 
0x1FD8, 0x1FD9, 0, -8, 0x1FDA, 0x1FDB, 0, -100, 0x1FE0, 0x1FE1, 8, 0, 0x1FE5, 0x1FE5, 7, 0, 
0x1FE8, 0x1FE9, 0, -8, 0x1FEA, 0x1FEB, 0, -112, 0x1FEC, 0x1FEC, 0, -7, 0x1FF3, 0x1FF3, 9, 0, 
0x1FF8, 0x1FF9, 0, -128, 0x1FFA, 0x1FFB, 0, -126, 0x1FFC, 0x1FFC, 0, -9, 0x2126, 0x2126, 0, -7517, 
0x212A, 0x212A, 0, -8383, 0x212B, 0x212B, 0, -8262, 0x2132, 0x2132, 0, 28, 0x214E, 0x214E, -28, 0, 
0x2160, 0x216F, 0, 16, 0x2170, 0x217F, -16, 0, 0x2183, 0x2184, -3, -3, 0x24B6, 0x24CF, 0, 26, 
0x24D0, 0x24E9, -26, 0, 0x2C00, 0x2C2F, 0, 48, 0x2C30, 0x2C5F, -48, 0, 0x2C60, 0x2C61, -3, -3, 
0x2C62, 0x2C62, 0, -10743, 0x2C63, 0x2C63, 0, -3814, 0x2C64, 0x2C64, 0, -10727, 0x2C65, 0x2C65, -10795, 0, 
0x2C66, 0x2C66, -10792, 0, 0x2C67, 0x2C6C, -3, -3, 0x2C6D, 0x2C6D, 0, -10780, 0x2C6E, 0x2C6E, 0, -10749, 
0x2C6F, 0x2C6F, 0, -10783, 0x2C70, 0x2C70, 0, -10782, 0x2C72, 0x2C73, -3, -3, 0x2C75, 0x2C76, -3, -3, 
0x2C7E, 0x2C7F, 0, -10815, 0x2C80, 0x2CE3, -3, -3, 0x2CEB, 0x2CEE, -3, -3, 0x2CF2, 0x2CF3, -3, -3, 
0x2D00, 0x2D25, -7264, 0, 0x2D27, 0x2D27, -7264, 0, 0x2D2D, 0x2D2D, -7264, 0, 0xA640, 0xA66D, -3, -3, 
0xA680, 0xA69B, -3, -3, 0xA722, 0xA72F, -3, -3, 0xA732, 0xA76F, -3, -3, 0xA779, 0xA77C, -3, -3, 
0xA77D, 0xA77D, 0, -35332, 0xA77E, 0xA787, -3, -3, 0xA78B, 0xA78C, -3, -3, 0xA78D, 0xA78D, 0, -42280, 
0xA790, 0xA793, -3, -3, 0xA794, 0xA794, 48, 0, 0xA796, 0xA7A9, -3, -3, 0xA7AA, 0xA7AA, 0, -42308, 
0xA7AB, 0xA7AB, 0, -42319, 0xA7AC, 0xA7AC, 0, -42315, 0xA7AD, 0xA7AD, 0, -42305, 0xA7AE, 0xA7AE, 0, -42308, 
0xA7B0, 0xA7B0, 0, -42258, 0xA7B1, 0xA7B1, 0, -42282, 0xA7B2, 0xA7B2, 0, -42261, 0xA7B3, 0xA7B3, 0, 928, 
0xA7B4, 0xA7C3, -3, -3, 0xA7C4, 0xA7C4, 0, -48, 0xA7C5, 0xA7C5, 0, -42307, 0xA7C6, 0xA7C6, 0, -35384, 
0xA7C7, 0xA7CA, -3, -3, 0xA7D0, 0xA7D1, -3, -3, 0xA7D6, 0xA7D9, -3, -3, 0xA7F5, 0xA7F6, -3, -3, 
0xAB53, 0xAB53, -928, 0, 0xAB70, 0xABBF, -38864, 0, 0xFF21, 0xFF3A, 0, 32, 0xFF41, 0xFF5A, -32, 0, 
0x10400, 0x10427, 0, 40, 0x10428, 0x1044F, -40, 0, 0x104B0, 0x104D3, 0, 40, 0x104D8, 0x104FB, -40, 0, 
0x10570, 0x1057A, 0, 39, 0x1057C, 0x1058A, 0, 39, 0x1058C, 0x10592, 0, 39, 0x10594, 0x10595, 0, 39, 
0x10597, 0x105A1, -39, 0, 0x105A3, 0x105B1, -39, 0, 0x105B3, 0x105B9, -39, 0, 0x105BB, 0x105BC, -39, 0, 
0x10C80, 0x10CB2, 0, 64, 0x10CC0, 0x10CF2, -64, 0, 0x118A0, 0x118BF, 0, 32, 0x118C0, 0x118DF, -32, 0, 
0x16E40, 0x16E5F, 0, 32, 0x16E60, 0x16E7F, -32, 0, 0x1E900, 0x1E921, 0, 34, 0x1E922, 0x1E943, -34, 0}; // fixed array const
Array_fixed_int_123 _const_encoding__base64__index = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 63, 62, 62, 63, 
52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 
0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 63, 
0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51}; // fixed array const
time__Duration _const_time__nanosecond; // inited later
time__Duration _const_time__infinite; // inited later
Array_fixed_string_7 _const_time__long_days = {_SLIT("Monday"), _SLIT("Tuesday"), _SLIT("Wednesday"), _SLIT("Thursday"), _SLIT("Friday"), _SLIT("Saturday"), _SLIT("Sunday")}; // fixed array const
Array_int _const_orm__num64; // inited later
Array_int _const_orm__nums; // inited later
Array_int _const_orm__float; // inited later
int _const_orm__type_string; // inited later
Map_string_int _const_orm__type_idx; // inited later
orm__Primitive _const_orm__null_primitive; // inited later
Array_string _const_encoding__html__escape_seq; // inited later
Array_string _const_encoding__html__escape_quote_seq; // inited later
const u32 _const_crypto__sha256__init0 = 1779033703; // precomputed2
const u32 _const_crypto__sha256__init1 = 3144134277; // precomputed2
const u32 _const_crypto__sha256__init2 = 1013904242; // precomputed2
const u32 _const_crypto__sha256__init3 = 2773480762; // precomputed2
const u32 _const_crypto__sha256__init4 = 1359893119; // precomputed2
const u32 _const_crypto__sha256__init5 = 2600822924; // precomputed2
const u32 _const_crypto__sha256__init6 = 528734635; // precomputed2
const u32 _const_crypto__sha256__init7 = 1541459225; // precomputed2
const u32 _const_crypto__sha256__init0_224 = 3238371032; // precomputed2
const u32 _const_crypto__sha256__init1_224 = 914150663; // precomputed2
const u32 _const_crypto__sha256__init2_224 = 812702999; // precomputed2
const u32 _const_crypto__sha256__init3_224 = 4144912697; // precomputed2
const u32 _const_crypto__sha256__init4_224 = 4290775857; // precomputed2
const u32 _const_crypto__sha256__init5_224 = 1750603025; // precomputed2
const u32 _const_crypto__sha256__init6_224 = 1694076839; // precomputed2
const u32 _const_crypto__sha256__init7_224 = 3204075428; // precomputed2
Array_int _const_crypto__sha256___k; // inited later
const u64 _const_rand__wyrand__wyp0 = 11562461410679940143U; // precomputed2
const u64 _const_rand__wyrand__wyp1 = 16646288086500911323U; // precomputed2
rand__PRNG* default_rng; // global 6

Array_fixed_u8_16 _const_net__addr_ip6_any = {0}; // fixed array const
Array_fixed_u8_4 _const_net__addr_ip_any = {0}; // fixed array const
u32 _const_net__aoffset; // inited later
IError _const_net__err_port_out_of_range; // inited later
IError _const_net__err_no_udp_remote; // inited later
IError _const_net__err_timed_out; // inited later
int _const_net__msg_dontwait; // inited later
int _const_net__error_ewouldblock; // inited later
int _const_net__error_eagain; // inited later
mbedtls_ctr_drbg_context _const_net__mbedtls__ctr_drbg; // inited later
mbedtls_entropy_context _const_net__mbedtls__entropy; // inited later
i64 _const_net__mbedtls__mbedtls_client_read_timeout_ms; // inited later
i64 _const_net__mbedtls__mbedtls_server_read_timeout_ms; // inited later
const u8 _const_net__socks__socks_version5 = 5; // precomputed2
const u8 _const_net__socks__addr_type_ipv4 = 1; // precomputed2
const u8 _const_net__socks__addr_type_fqdn = 3; // precomputed2
const u8 _const_net__socks__no_auth = 0; // precomputed2
const u8 _const_net__socks__auth_user_password = 2; // precomputed2
Map_string_net__http__CommonHeader _const_net__http__common_header_map; // inited later
net__http__Header _const_veb__headers_close; // inited later
Map_string_string _const_veb__mime_types; // inited later
Array_string _const_veb__cors_safelisted_response_headers; // inited later
string _const_veb__veb_livereload_server_start; // inited later
time__Duration _const_time__microsecond; // inited later
Array_string _const_os__args; // inited later
time__Duration _const_net__infinite_timeout; // inited later
net__http__Response _const_veb__http_400; // inited later
net__http__Response _const_veb__http_408; // inited later
net__http__Response _const_veb__http_413; // inited later
net__http__Response _const_veb__http_500; // inited later
time__Duration _const_time__millisecond; // inited later
time__Duration _const_time__second; // inited later
time__Duration _const_time__minute; // inited later
i64 _const_net__tcp_default_read_timeout; // inited later
i64 _const_net__tcp_default_write_timeout; // inited later
time__Duration _const_time__hour; // inited later

// V interface table:
static IError I_None___to_Interface_IError(None__* x);
const int _IError_None___index = 0;
static IError I_voidptr_to_Interface_IError(voidptr* x);
const int _IError_voidptr_index = 1;
static IError I_Error_to_Interface_IError(Error* x);
const int _IError_Error_index = 2;
static IError I_MessageError_to_Interface_IError(MessageError* x);
const int _IError_MessageError_index = 3;
static IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x);
const int _IError_time__TimeParseError_index = 4;
static IError I_io__Eof_to_Interface_IError(io__Eof* x);
const int _IError_io__Eof_index = 5;
static IError I_io__NotExpected_to_Interface_IError(io__NotExpected* x);
const int _IError_io__NotExpected_index = 6;
static IError I_os__Eof_to_Interface_IError(os__Eof* x);
const int _IError_os__Eof_index = 7;
static IError I_os__NotExpected_to_Interface_IError(os__NotExpected* x);
const int _IError_os__NotExpected_index = 8;
static IError I_os__FileNotOpenedError_to_Interface_IError(os__FileNotOpenedError* x);
const int _IError_os__FileNotOpenedError_index = 9;
static IError I_os__SizeOfTypeIs0Error_to_Interface_IError(os__SizeOfTypeIs0Error* x);
const int _IError_os__SizeOfTypeIs0Error_index = 10;
static IError I_os__ExecutableNotFoundError_to_Interface_IError(os__ExecutableNotFoundError* x);
const int _IError_os__ExecutableNotFoundError_index = 11;
static IError I_db__sqlite__SQLError_to_Interface_IError(db__sqlite__SQLError* x);
const int _IError_db__sqlite__SQLError_index = 12;
static IError I_net__http__HeaderKeyError_to_Interface_IError(net__http__HeaderKeyError* x);
const int _IError_net__http__HeaderKeyError_index = 13;
static IError I_net__http__MultiplePathAttributesError_to_Interface_IError(net__http__MultiplePathAttributesError* x);
const int _IError_net__http__MultiplePathAttributesError_index = 14;
static IError I_net__http__UnexpectedExtraAttributeError_to_Interface_IError(net__http__UnexpectedExtraAttributeError* x);
const int _IError_net__http__UnexpectedExtraAttributeError_index = 15;
// ^^^ number of types for interface IError: 16

// Methods wrapper for interface "IError"
static inline int None___code_Interface_IError_method_wrapper(None__* err) {
	return Error_code(err->Error);
}
static inline string None___msg_Interface_IError_method_wrapper(None__* err) {
	return Error_msg(err->Error);
}
static inline int Error_code_Interface_IError_method_wrapper(Error* err) {
	return Error_code(*err);
}
static inline string Error_msg_Interface_IError_method_wrapper(Error* err) {
	return Error_msg(*err);
}
static inline int MessageError_code_Interface_IError_method_wrapper(MessageError* err) {
	return MessageError_code(*err);
}
static inline string MessageError_msg_Interface_IError_method_wrapper(MessageError* err) {
	return MessageError_msg(*err);
}
static inline int time__TimeParseError_code_Interface_IError_method_wrapper(time__TimeParseError* err) {
	return Error_code(err->Error);
}
static inline string time__TimeParseError_msg_Interface_IError_method_wrapper(time__TimeParseError* err) {
	return time__TimeParseError_msg(*err);
}
static inline int io__Eof_code_Interface_IError_method_wrapper(io__Eof* err) {
	return Error_code(err->Error);
}
static inline string io__Eof_msg_Interface_IError_method_wrapper(io__Eof* err) {
	return Error_msg(err->Error);
}
static inline int io__NotExpected_code_Interface_IError_method_wrapper(io__NotExpected* err) {
	return io__NotExpected_code(*err);
}
static inline string io__NotExpected_msg_Interface_IError_method_wrapper(io__NotExpected* err) {
	return io__NotExpected_msg(*err);
}
static inline int os__Eof_code_Interface_IError_method_wrapper(os__Eof* err) {
	return Error_code(err->Error);
}
static inline string os__Eof_msg_Interface_IError_method_wrapper(os__Eof* err) {
	return Error_msg(err->Error);
}
static inline int os__NotExpected_code_Interface_IError_method_wrapper(os__NotExpected* err) {
	return os__NotExpected_code(*err);
}
static inline string os__NotExpected_msg_Interface_IError_method_wrapper(os__NotExpected* err) {
	return os__NotExpected_msg(*err);
}
static inline int os__FileNotOpenedError_code_Interface_IError_method_wrapper(os__FileNotOpenedError* err) {
	return Error_code(err->Error);
}
static inline string os__FileNotOpenedError_msg_Interface_IError_method_wrapper(os__FileNotOpenedError* err) {
	return os__FileNotOpenedError_msg(*err);
}
static inline int os__SizeOfTypeIs0Error_code_Interface_IError_method_wrapper(os__SizeOfTypeIs0Error* err) {
	return Error_code(err->Error);
}
static inline string os__SizeOfTypeIs0Error_msg_Interface_IError_method_wrapper(os__SizeOfTypeIs0Error* err) {
	return os__SizeOfTypeIs0Error_msg(*err);
}
static inline int os__ExecutableNotFoundError_code_Interface_IError_method_wrapper(os__ExecutableNotFoundError* err) {
	return Error_code(err->Error);
}
static inline string os__ExecutableNotFoundError_msg_Interface_IError_method_wrapper(os__ExecutableNotFoundError* err) {
	return os__ExecutableNotFoundError_msg(*err);
}
static inline int db__sqlite__SQLError_code_Interface_IError_method_wrapper(db__sqlite__SQLError* err) {
	return MessageError_code(err->MessageError);
}
static inline string db__sqlite__SQLError_msg_Interface_IError_method_wrapper(db__sqlite__SQLError* err) {
	return MessageError_msg(err->MessageError);
}
static inline int net__http__HeaderKeyError_code_Interface_IError_method_wrapper(net__http__HeaderKeyError* err) {
	return net__http__HeaderKeyError_code(*err);
}
static inline string net__http__HeaderKeyError_msg_Interface_IError_method_wrapper(net__http__HeaderKeyError* err) {
	return net__http__HeaderKeyError_msg(*err);
}
static inline int net__http__MultiplePathAttributesError_code_Interface_IError_method_wrapper(net__http__MultiplePathAttributesError* err) {
	return Error_code(err->Error);
}
static inline string net__http__MultiplePathAttributesError_msg_Interface_IError_method_wrapper(net__http__MultiplePathAttributesError* err) {
	return net__http__MultiplePathAttributesError_msg(*err);
}
static inline int net__http__UnexpectedExtraAttributeError_code_Interface_IError_method_wrapper(net__http__UnexpectedExtraAttributeError* err) {
	return Error_code(err->Error);
}
static inline string net__http__UnexpectedExtraAttributeError_msg_Interface_IError_method_wrapper(net__http__UnexpectedExtraAttributeError* err) {
	return net__http__UnexpectedExtraAttributeError_msg(*err);
}

struct _IError_interface_methods {
	int (*_method_code)(void* _);
	string (*_method_msg)(void* _);
};

struct _IError_interface_methods IError_name_table[16] = {
	{
		._method_code = (void*) None___code_Interface_IError_method_wrapper,
		._method_msg = (void*) None___msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) 0,
		._method_msg = (void*) 0,
	},
	{
		._method_code = (void*) Error_code_Interface_IError_method_wrapper,
		._method_msg = (void*) Error_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) MessageError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) MessageError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) time__TimeParseError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) time__TimeParseError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) io__Eof_code_Interface_IError_method_wrapper,
		._method_msg = (void*) io__Eof_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) io__NotExpected_code_Interface_IError_method_wrapper,
		._method_msg = (void*) io__NotExpected_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) os__Eof_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__Eof_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) os__NotExpected_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__NotExpected_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) os__FileNotOpenedError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__FileNotOpenedError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) os__SizeOfTypeIs0Error_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__SizeOfTypeIs0Error_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) os__ExecutableNotFoundError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__ExecutableNotFoundError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) db__sqlite__SQLError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) db__sqlite__SQLError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) net__http__HeaderKeyError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) net__http__HeaderKeyError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) net__http__MultiplePathAttributesError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) net__http__MultiplePathAttributesError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) net__http__UnexpectedExtraAttributeError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) net__http__UnexpectedExtraAttributeError_msg_Interface_IError_method_wrapper,
	},
};


// Casting functions for converting "None__" to interface "IError"
static inline IError I_None___to_Interface_IError(None__* x) {
return (IError) {
		._None__ = x,
		._typ = _IError_None___index,
	};
}

// Casting functions for converting "voidptr" to interface "IError"
static inline IError I_voidptr_to_Interface_IError(voidptr* x) {
return (IError) {
		._voidptr = x,
		._typ = _IError_voidptr_index,
	};
}

// Casting functions for converting "Error" to interface "IError"
static inline IError I_Error_to_Interface_IError(Error* x) {
return (IError) {
		._Error = x,
		._typ = _IError_Error_index,
	};
}

// Casting functions for converting "MessageError" to interface "IError"
static inline IError I_MessageError_to_Interface_IError(MessageError* x) {
return (IError) {
		._MessageError = x,
		._typ = _IError_MessageError_index,
	};
}

// Casting functions for converting "time__TimeParseError" to interface "IError"
static inline IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x) {
return (IError) {
		._time__TimeParseError = x,
		._typ = _IError_time__TimeParseError_index,
	};
}

// Casting functions for converting "io__Eof" to interface "IError"
static inline IError I_io__Eof_to_Interface_IError(io__Eof* x) {
return (IError) {
		._io__Eof = x,
		._typ = _IError_io__Eof_index,
	};
}

// Casting functions for converting "io__NotExpected" to interface "IError"
static inline IError I_io__NotExpected_to_Interface_IError(io__NotExpected* x) {
return (IError) {
		._io__NotExpected = x,
		._typ = _IError_io__NotExpected_index,
	};
}

// Casting functions for converting "os__Eof" to interface "IError"
static inline IError I_os__Eof_to_Interface_IError(os__Eof* x) {
return (IError) {
		._os__Eof = x,
		._typ = _IError_os__Eof_index,
	};
}

// Casting functions for converting "os__NotExpected" to interface "IError"
static inline IError I_os__NotExpected_to_Interface_IError(os__NotExpected* x) {
return (IError) {
		._os__NotExpected = x,
		._typ = _IError_os__NotExpected_index,
	};
}

// Casting functions for converting "os__FileNotOpenedError" to interface "IError"
static inline IError I_os__FileNotOpenedError_to_Interface_IError(os__FileNotOpenedError* x) {
return (IError) {
		._os__FileNotOpenedError = x,
		._typ = _IError_os__FileNotOpenedError_index,
	};
}

// Casting functions for converting "os__SizeOfTypeIs0Error" to interface "IError"
static inline IError I_os__SizeOfTypeIs0Error_to_Interface_IError(os__SizeOfTypeIs0Error* x) {
return (IError) {
		._os__SizeOfTypeIs0Error = x,
		._typ = _IError_os__SizeOfTypeIs0Error_index,
	};
}

// Casting functions for converting "os__ExecutableNotFoundError" to interface "IError"
static inline IError I_os__ExecutableNotFoundError_to_Interface_IError(os__ExecutableNotFoundError* x) {
return (IError) {
		._os__ExecutableNotFoundError = x,
		._typ = _IError_os__ExecutableNotFoundError_index,
	};
}

// Casting functions for converting "db__sqlite__SQLError" to interface "IError"
static inline IError I_db__sqlite__SQLError_to_Interface_IError(db__sqlite__SQLError* x) {
return (IError) {
		._db__sqlite__SQLError = x,
		._typ = _IError_db__sqlite__SQLError_index,
	};
}

// Casting functions for converting "net__http__HeaderKeyError" to interface "IError"
static inline IError I_net__http__HeaderKeyError_to_Interface_IError(net__http__HeaderKeyError* x) {
return (IError) {
		._net__http__HeaderKeyError = x,
		._typ = _IError_net__http__HeaderKeyError_index,
	};
}

// Casting functions for converting "net__http__MultiplePathAttributesError" to interface "IError"
static inline IError I_net__http__MultiplePathAttributesError_to_Interface_IError(net__http__MultiplePathAttributesError* x) {
return (IError) {
		._net__http__MultiplePathAttributesError = x,
		._typ = _IError_net__http__MultiplePathAttributesError_index,
	};
}

// Casting functions for converting "net__http__UnexpectedExtraAttributeError" to interface "IError"
static inline IError I_net__http__UnexpectedExtraAttributeError_to_Interface_IError(net__http__UnexpectedExtraAttributeError* x) {
return (IError) {
		._net__http__UnexpectedExtraAttributeError = x,
		._typ = _IError_net__http__UnexpectedExtraAttributeError_index,
	};
}

static veb__ControllerInterface I_veb__Controller_to_Interface_veb__ControllerInterface(veb__Controller* x);
const int _veb__ControllerInterface_veb__Controller_index = 0;
static veb__ControllerInterface I_voidptr_to_Interface_veb__ControllerInterface(voidptr* x);
const int _veb__ControllerInterface_voidptr_index = 1;
static veb__ControllerInterface I_veb__RequestParams_to_Interface_veb__ControllerInterface(veb__RequestParams* x);
const int _veb__ControllerInterface_veb__RequestParams_index = 2;
// ^^^ number of types for interface veb__ControllerInterface: 3


// Casting functions for converting "veb__Controller" to interface "veb__ControllerInterface"
static inline veb__ControllerInterface I_veb__Controller_to_Interface_veb__ControllerInterface(veb__Controller* x) {
return (veb__ControllerInterface) {
		._veb__Controller = x,
		._typ = _veb__ControllerInterface_veb__Controller_index,
		.controllers = (Array_veb__ControllerPath_ptr*)((char*)x + __offsetof_ptr(x, veb__Controller, controllers)),
	};
}

// Casting functions for converting "voidptr" to interface "veb__ControllerInterface"
static inline veb__ControllerInterface I_voidptr_to_Interface_veb__ControllerInterface(voidptr* x) {
return (veb__ControllerInterface) {
		._voidptr = x,
		._typ = _veb__ControllerInterface_voidptr_index,
		.controllers = (Array_veb__ControllerPath_ptr*)((char*)x),
	};
}

// Casting functions for converting "veb__RequestParams" to interface "veb__ControllerInterface"
static inline veb__ControllerInterface I_veb__RequestParams_to_Interface_veb__ControllerInterface(veb__RequestParams* x) {
return (veb__ControllerInterface) {
		._veb__RequestParams = x,
		._typ = _veb__ControllerInterface_veb__RequestParams_index,
		.controllers = (Array_veb__ControllerPath_ptr*)((char*)x + __offsetof_ptr(x, veb__RequestParams, controllers)),
	};
}

static veb__MiddlewareApp I_main__App_to_Interface_veb__MiddlewareApp(main__App* x);
const int _veb__MiddlewareApp_main__App_index = 0;
static veb__MiddlewareApp I_voidptr_to_Interface_veb__MiddlewareApp(voidptr* x);
const int _veb__MiddlewareApp_voidptr_index = 1;
static veb__MiddlewareApp I_veb__Middleware_T_main__Context_to_Interface_veb__MiddlewareApp(veb__Middleware_T_main__Context* x);
const int _veb__MiddlewareApp_veb__Middleware_T_main__Context_index = 2;
// ^^^ number of types for interface veb__MiddlewareApp: 3


// Casting functions for converting "main__App" to interface "veb__MiddlewareApp"
static inline veb__MiddlewareApp I_main__App_to_Interface_veb__MiddlewareApp(main__App* x) {
return (veb__MiddlewareApp) {
		._main__App = x,
		._typ = _veb__MiddlewareApp_main__App_index,
		.global_handlers = (Array_voidptr*)((char*)x + __offsetof_ptr(x, main__App, Middleware) + __offsetof_ptr(x, veb__Middleware_T_main__Context, global_handlers)),
		.global_handlers_after = (Array_voidptr*)((char*)x + __offsetof_ptr(x, main__App, Middleware) + __offsetof_ptr(x, veb__Middleware_T_main__Context, global_handlers_after)),
		.route_handlers = (Array_veb__RouteMiddleware*)((char*)x + __offsetof_ptr(x, main__App, Middleware) + __offsetof_ptr(x, veb__Middleware_T_main__Context, route_handlers)),
		.route_handlers_after = (Array_veb__RouteMiddleware*)((char*)x + __offsetof_ptr(x, main__App, Middleware) + __offsetof_ptr(x, veb__Middleware_T_main__Context, route_handlers_after)),
	};
}

// Casting functions for converting "voidptr" to interface "veb__MiddlewareApp"
static inline veb__MiddlewareApp I_voidptr_to_Interface_veb__MiddlewareApp(voidptr* x) {
return (veb__MiddlewareApp) {
		._voidptr = x,
		._typ = _veb__MiddlewareApp_voidptr_index,
		.global_handlers = (Array_voidptr*)((char*)x),
		.global_handlers_after = (Array_voidptr*)((char*)x),
		.route_handlers = (Array_veb__RouteMiddleware*)((char*)x),
		.route_handlers_after = (Array_veb__RouteMiddleware*)((char*)x),
	};
}

// Casting functions for converting "veb__Middleware_T_main__Context" to interface "veb__MiddlewareApp"
static inline veb__MiddlewareApp I_veb__Middleware_T_main__Context_to_Interface_veb__MiddlewareApp(veb__Middleware_T_main__Context* x) {
return (veb__MiddlewareApp) {
		._veb__Middleware_T_main__Context = x,
		._typ = _veb__MiddlewareApp_veb__Middleware_T_main__Context_index,
		.global_handlers = (Array_voidptr*)((char*)x + __offsetof_ptr(x, veb__Middleware_T_main__Context, global_handlers)),
		.global_handlers_after = (Array_voidptr*)((char*)x + __offsetof_ptr(x, veb__Middleware_T_main__Context, global_handlers_after)),
		.route_handlers = (Array_veb__RouteMiddleware*)((char*)x + __offsetof_ptr(x, veb__Middleware_T_main__Context, route_handlers)),
		.route_handlers_after = (Array_veb__RouteMiddleware*)((char*)x + __offsetof_ptr(x, veb__Middleware_T_main__Context, route_handlers_after)),
	};
}

// ^^^ number of types for interface veb__HasBeforeRequest: 0

// Methods wrapper for interface "veb__HasBeforeRequest"

struct _veb__HasBeforeRequest_interface_methods {
	void (*_method_before_request)(void* _);
};

struct _veb__HasBeforeRequest_interface_methods veb__HasBeforeRequest_name_table[1];


static veb__StaticApp I_main__App_to_Interface_veb__StaticApp(main__App* x);
const int _veb__StaticApp_main__App_index = 0;
static veb__StaticApp I_voidptr_to_Interface_veb__StaticApp(voidptr* x);
const int _veb__StaticApp_voidptr_index = 1;
static veb__StaticApp I_veb__StaticHandler_to_Interface_veb__StaticApp(veb__StaticHandler* x);
const int _veb__StaticApp_veb__StaticHandler_index = 2;
// ^^^ number of types for interface veb__StaticApp: 3


// Casting functions for converting "main__App" to interface "veb__StaticApp"
static inline veb__StaticApp I_main__App_to_Interface_veb__StaticApp(main__App* x) {
return (veb__StaticApp) {
		._main__App = x,
		._typ = _veb__StaticApp_main__App_index,
		.static_files = (Map_string_string*)((char*)x + __offsetof_ptr(x, main__App, StaticHandler) + __offsetof_ptr(x, veb__StaticHandler, static_files)),
		.static_mime_types = (Map_string_string*)((char*)x + __offsetof_ptr(x, main__App, StaticHandler) + __offsetof_ptr(x, veb__StaticHandler, static_mime_types)),
		.static_hosts = (Map_string_string*)((char*)x + __offsetof_ptr(x, main__App, StaticHandler) + __offsetof_ptr(x, veb__StaticHandler, static_hosts)),
	};
}

// Casting functions for converting "voidptr" to interface "veb__StaticApp"
static inline veb__StaticApp I_voidptr_to_Interface_veb__StaticApp(voidptr* x) {
return (veb__StaticApp) {
		._voidptr = x,
		._typ = _veb__StaticApp_voidptr_index,
		.static_files = (Map_string_string*)((char*)x),
		.static_mime_types = (Map_string_string*)((char*)x),
		.static_hosts = (Map_string_string*)((char*)x),
	};
}

// Casting functions for converting "veb__StaticHandler" to interface "veb__StaticApp"
static inline veb__StaticApp I_veb__StaticHandler_to_Interface_veb__StaticApp(veb__StaticHandler* x) {
return (veb__StaticApp) {
		._veb__StaticHandler = x,
		._typ = _veb__StaticApp_veb__StaticHandler_index,
		.static_files = (Map_string_string*)((char*)x + __offsetof_ptr(x, veb__StaticHandler, static_files)),
		.static_mime_types = (Map_string_string*)((char*)x + __offsetof_ptr(x, veb__StaticHandler, static_mime_types)),
		.static_hosts = (Map_string_string*)((char*)x + __offsetof_ptr(x, veb__StaticHandler, static_hosts)),
	};
}

// ^^^ number of types for interface veb__BeforeAcceptApp: 0

// Methods wrapper for interface "veb__BeforeAcceptApp"

struct _veb__BeforeAcceptApp_interface_methods {
	void (*_method_before_accept_loop)(void* _);
};

struct _veb__BeforeAcceptApp_interface_methods veb__BeforeAcceptApp_name_table[1];


static orm__Connection I_db__sqlite__DB_to_Interface_orm__Connection(db__sqlite__DB* x);
const int _orm__Connection_db__sqlite__DB_index = 0;
static orm__Connection I_voidptr_to_Interface_orm__Connection(voidptr* x);
const int _orm__Connection_voidptr_index = 1;
// ^^^ number of types for interface orm__Connection: 2

// Methods wrapper for interface "orm__Connection"
static inline _result_void db__sqlite__DB_create_Interface_orm__Connection_method_wrapper(db__sqlite__DB* db, string table, Array_orm__TableField fields) {
	return db__sqlite__DB_create(*db, table, fields);
}
static inline _result_void db__sqlite__DB_delete_Interface_orm__Connection_method_wrapper(db__sqlite__DB* db, string table, orm__QueryData where) {
	return db__sqlite__DB_delete(*db, table, where);
}
static inline _result_void db__sqlite__DB_drop_Interface_orm__Connection_method_wrapper(db__sqlite__DB* db, string table) {
	return db__sqlite__DB_drop(*db, table);
}
static inline _result_void db__sqlite__DB_insert_Interface_orm__Connection_method_wrapper(db__sqlite__DB* db, string table, orm__QueryData data) {
	return db__sqlite__DB_insert(*db, table, data);
}
static inline int db__sqlite__DB_last_id_Interface_orm__Connection_method_wrapper(db__sqlite__DB* db) {
	return db__sqlite__DB_last_id(*db);
}
static inline _result_Array_Array_orm__Primitive db__sqlite__DB_select_Interface_orm__Connection_method_wrapper(db__sqlite__DB* db, orm__SelectConfig config, orm__QueryData data, orm__QueryData where) {
	return db__sqlite__DB_select(*db, config, data, where);
}
static inline _result_void db__sqlite__DB_update_Interface_orm__Connection_method_wrapper(db__sqlite__DB* db, string table, orm__QueryData data, orm__QueryData where) {
	return db__sqlite__DB_update(*db, table, data, where);
}

struct _orm__Connection_interface_methods {
	_result_void (*_method_create)(void* _, string table, Array_orm__TableField fields);
	_result_void (*_method__v_delete)(void* _, string table, orm__QueryData where);
	_result_void (*_method_drop)(void* _, string table);
	_result_void (*_method_insert)(void* _, string table, orm__QueryData data);
	int (*_method_last_id)(void* _);
	_result_Array_Array_orm__Primitive (*_method_select)(void* _, orm__SelectConfig config, orm__QueryData data, orm__QueryData where);
	_result_void (*_method_update)(void* _, string table, orm__QueryData data, orm__QueryData where);
};

struct _orm__Connection_interface_methods orm__Connection_name_table[2] = {
	{
		._method_create = (void*) db__sqlite__DB_create_Interface_orm__Connection_method_wrapper,
		._method__v_delete = (void*) db__sqlite__DB_delete_Interface_orm__Connection_method_wrapper,
		._method_drop = (void*) db__sqlite__DB_drop_Interface_orm__Connection_method_wrapper,
		._method_insert = (void*) db__sqlite__DB_insert_Interface_orm__Connection_method_wrapper,
		._method_last_id = (void*) db__sqlite__DB_last_id_Interface_orm__Connection_method_wrapper,
		._method_select = (void*) db__sqlite__DB_select_Interface_orm__Connection_method_wrapper,
		._method_update = (void*) db__sqlite__DB_update_Interface_orm__Connection_method_wrapper,
	},
	{
		._method_create = (void*) 0,
		._method__v_delete = (void*) 0,
		._method_drop = (void*) 0,
		._method_insert = (void*) 0,
		._method_last_id = (void*) 0,
		._method_select = (void*) 0,
		._method_update = (void*) 0,
	},
};


// Casting functions for converting "db__sqlite__DB" to interface "orm__Connection"
static inline orm__Connection I_db__sqlite__DB_to_Interface_orm__Connection(db__sqlite__DB* x) {
return (orm__Connection) {
		._db__sqlite__DB = x,
		._typ = _orm__Connection_db__sqlite__DB_index,
	};
}

// Casting functions for converting "voidptr" to interface "orm__Connection"
static inline orm__Connection I_voidptr_to_Interface_orm__Connection(voidptr* x) {
return (orm__Connection) {
		._voidptr = x,
		._typ = _orm__Connection_voidptr_index,
	};
}

static net__http__Downloader I_voidptr_to_Interface_net__http__Downloader(voidptr* x);
const int _net__http__Downloader_voidptr_index = 0;
static net__http__Downloader I_net__http__TerminalStreamingDownloader_to_Interface_net__http__Downloader(net__http__TerminalStreamingDownloader* x);
const int _net__http__Downloader_net__http__TerminalStreamingDownloader_index = 1;
static net__http__Downloader I_net__http__SilentStreamingDownloader_to_Interface_net__http__Downloader(net__http__SilentStreamingDownloader* x);
const int _net__http__Downloader_net__http__SilentStreamingDownloader_index = 2;
// ^^^ number of types for interface net__http__Downloader: 3

// Methods wrapper for interface "net__http__Downloader"

struct _net__http__Downloader_interface_methods {
	_result_void (*_method_on_chunk)(void* _, net__http__Request* request, Array_u8 chunk, u64 already_received, u64 expected);
	_result_void (*_method_on_finish)(void* _, net__http__Request* request, net__http__Response* response);
	_result_void (*_method_on_start)(void* _, net__http__Request* request, string path);
};

struct _net__http__Downloader_interface_methods net__http__Downloader_name_table[3] = {
	{
		._method_on_chunk = (void*) 0,
		._method_on_finish = (void*) 0,
		._method_on_start = (void*) 0,
	},
	{
		._method_on_chunk = (void*) net__http__TerminalStreamingDownloader_on_chunk,
		._method_on_finish = (void*) net__http__TerminalStreamingDownloader_on_finish,
		._method_on_start = (void*) net__http__TerminalStreamingDownloader_on_start,
	},
	{
		._method_on_chunk = (void*) net__http__SilentStreamingDownloader_on_chunk,
		._method_on_finish = (void*) net__http__SilentStreamingDownloader_on_finish,
		._method_on_start = (void*) net__http__SilentStreamingDownloader_on_start,
	},
};


// Casting functions for converting "voidptr" to interface "net__http__Downloader"
static inline net__http__Downloader I_voidptr_to_Interface_net__http__Downloader(voidptr* x) {
return (net__http__Downloader) {
		._voidptr = x,
		._typ = _net__http__Downloader_voidptr_index,
	};
}

// Casting functions for converting "net__http__TerminalStreamingDownloader" to interface "net__http__Downloader"
static inline net__http__Downloader I_net__http__TerminalStreamingDownloader_to_Interface_net__http__Downloader(net__http__TerminalStreamingDownloader* x) {
return (net__http__Downloader) {
		._net__http__TerminalStreamingDownloader = x,
		._typ = _net__http__Downloader_net__http__TerminalStreamingDownloader_index,
	};
}

// Casting functions for converting "net__http__SilentStreamingDownloader" to interface "net__http__Downloader"
static inline net__http__Downloader I_net__http__SilentStreamingDownloader_to_Interface_net__http__Downloader(net__http__SilentStreamingDownloader* x) {
return (net__http__Downloader) {
		._net__http__SilentStreamingDownloader = x,
		._typ = _net__http__Downloader_net__http__SilentStreamingDownloader_index,
	};
}

static net__http__Handler I_net__http__DebugHandler_to_Interface_net__http__Handler(net__http__DebugHandler* x);
const int _net__http__Handler_net__http__DebugHandler_index = 0;
static net__http__Handler I_voidptr_to_Interface_net__http__Handler(voidptr* x);
const int _net__http__Handler_voidptr_index = 1;
// ^^^ number of types for interface net__http__Handler: 2

// Methods wrapper for interface "net__http__Handler"
static inline net__http__Response net__http__DebugHandler_handle_Interface_net__http__Handler_method_wrapper(net__http__DebugHandler* d, net__http__Request req) {
	return net__http__DebugHandler_handle(*d, req);
}

struct _net__http__Handler_interface_methods {
	net__http__Response (*_method_handle)(void* _, net__http__Request );
};

struct _net__http__Handler_interface_methods net__http__Handler_name_table[2] = {
	{
		._method_handle = (void*) net__http__DebugHandler_handle_Interface_net__http__Handler_method_wrapper,
	},
	{
		._method_handle = (void*) 0,
	},
};


// Casting functions for converting "net__http__DebugHandler" to interface "net__http__Handler"
static inline net__http__Handler I_net__http__DebugHandler_to_Interface_net__http__Handler(net__http__DebugHandler* x) {
return (net__http__Handler) {
		._net__http__DebugHandler = x,
		._typ = _net__http__Handler_net__http__DebugHandler_index,
	};
}

// Casting functions for converting "voidptr" to interface "net__http__Handler"
static inline net__http__Handler I_voidptr_to_Interface_net__http__Handler(voidptr* x) {
return (net__http__Handler) {
		._voidptr = x,
		._typ = _net__http__Handler_voidptr_index,
	};
}

static net__Connection I_net__TcpConn_to_Interface_net__Connection(net__TcpConn* x);
const int _net__Connection_net__TcpConn_index = 0;
static net__Connection I_voidptr_to_Interface_net__Connection(voidptr* x);
const int _net__Connection_voidptr_index = 1;
static net__Connection I_net__ssl__SSLConn_to_Interface_net__Connection(net__ssl__SSLConn* x);
const int _net__Connection_net__ssl__SSLConn_index = 2;
static net__Connection I_net__mbedtls__SSLConn_to_Interface_net__Connection(net__mbedtls__SSLConn* x);
const int _net__Connection_net__mbedtls__SSLConn_index = 3;
// ^^^ number of types for interface net__Connection: 4

// Methods wrapper for interface "net__Connection"
static inline _result_int net__TcpConn_read_Interface_net__Connection_method_wrapper(net__TcpConn* c, Array_u8* buf) {
	return net__TcpConn_read(*c, buf);
}

struct _net__Connection_interface_methods {
	_result_net__Addr (*_method_addr)(void* _);
	_result_void (*_method_close)(void* _);
	_result_net__Addr (*_method_peer_addr)(void* _);
	_result_int (*_method_read)(void* _, Array_u8* );
	_result_int (*_method_write)(void* _, Array_u8 );
};

struct _net__Connection_interface_methods net__Connection_name_table[4] = {
	{
		._method_addr = (void*) net__TcpConn_addr,
		._method_close = (void*) net__TcpConn_close,
		._method_peer_addr = (void*) net__TcpConn_peer_addr,
		._method_read = (void*) net__TcpConn_read_Interface_net__Connection_method_wrapper,
		._method_write = (void*) net__TcpConn_write,
	},
	{
		._method_addr = (void*) 0,
		._method_close = (void*) 0,
		._method_peer_addr = (void*) 0,
		._method_read = (void*) 0,
		._method_write = (void*) 0,
	},
	{
		._method_addr = (void*) net__mbedtls__SSLConn_addr,
		._method_close = (void*) net__mbedtls__SSLConn_close,
		._method_peer_addr = (void*) net__mbedtls__SSLConn_peer_addr,
		._method_read = (void*) net__mbedtls__SSLConn_read,
		._method_write = (void*) net__mbedtls__SSLConn_write,
	},
	{
		._method_addr = (void*) net__mbedtls__SSLConn_addr,
		._method_close = (void*) net__mbedtls__SSLConn_close,
		._method_peer_addr = (void*) net__mbedtls__SSLConn_peer_addr,
		._method_read = (void*) net__mbedtls__SSLConn_read,
		._method_write = (void*) net__mbedtls__SSLConn_write,
	},
};


// Casting functions for converting "net__TcpConn" to interface "net__Connection"
static inline net__Connection I_net__TcpConn_to_Interface_net__Connection(net__TcpConn* x) {
return (net__Connection) {
		._net__TcpConn = x,
		._typ = _net__Connection_net__TcpConn_index,
	};
}

// Casting functions for converting "voidptr" to interface "net__Connection"
static inline net__Connection I_voidptr_to_Interface_net__Connection(voidptr* x) {
return (net__Connection) {
		._voidptr = x,
		._typ = _net__Connection_voidptr_index,
	};
}

// Casting functions for converting "net__ssl__SSLConn" to interface "net__Connection"
static inline net__Connection I_net__ssl__SSLConn_to_Interface_net__Connection(net__ssl__SSLConn* x) {
return (net__Connection) {
		._net__ssl__SSLConn = x,
		._typ = _net__Connection_net__ssl__SSLConn_index,
	};
}

// Casting functions for converting "net__mbedtls__SSLConn" to interface "net__Connection"
static inline net__Connection I_net__mbedtls__SSLConn_to_Interface_net__Connection(net__mbedtls__SSLConn* x) {
return (net__Connection) {
		._net__mbedtls__SSLConn = x,
		._typ = _net__Connection_net__mbedtls__SSLConn_index,
	};
}

static net__Dialer I_net__TCPDialer_to_Interface_net__Dialer(net__TCPDialer* x);
const int _net__Dialer_net__TCPDialer_index = 0;
static net__Dialer I_voidptr_to_Interface_net__Dialer(voidptr* x);
const int _net__Dialer_voidptr_index = 1;
static net__Dialer I_net__ssl__SSLDialer_to_Interface_net__Dialer(net__ssl__SSLDialer* x);
const int _net__Dialer_net__ssl__SSLDialer_index = 2;
static net__Dialer I_net__socks__SOCKS5Dialer_to_Interface_net__Dialer(net__socks__SOCKS5Dialer* x);
const int _net__Dialer_net__socks__SOCKS5Dialer_index = 3;
// ^^^ number of types for interface net__Dialer: 4

// Methods wrapper for interface "net__Dialer"
static inline _result_net__Connection net__TCPDialer_dial_Interface_net__Dialer_method_wrapper(net__TCPDialer* t, string address) {
	return net__TCPDialer_dial(*t, address);
}
static inline _result_net__Connection net__ssl__SSLDialer_dial_Interface_net__Dialer_method_wrapper(net__ssl__SSLDialer* d, string address) {
	return net__ssl__SSLDialer_dial(*d, address);
}
static inline _result_net__Connection net__socks__SOCKS5Dialer_dial_Interface_net__Dialer_method_wrapper(net__socks__SOCKS5Dialer* sd, string address) {
	return net__socks__SOCKS5Dialer_dial(*sd, address);
}

struct _net__Dialer_interface_methods {
	_result_net__Connection (*_method_dial)(void* _, string address);
};

struct _net__Dialer_interface_methods net__Dialer_name_table[4] = {
	{
		._method_dial = (void*) net__TCPDialer_dial_Interface_net__Dialer_method_wrapper,
	},
	{
		._method_dial = (void*) 0,
	},
	{
		._method_dial = (void*) net__ssl__SSLDialer_dial_Interface_net__Dialer_method_wrapper,
	},
	{
		._method_dial = (void*) net__socks__SOCKS5Dialer_dial_Interface_net__Dialer_method_wrapper,
	},
};


// Casting functions for converting "net__TCPDialer" to interface "net__Dialer"
static inline net__Dialer I_net__TCPDialer_to_Interface_net__Dialer(net__TCPDialer* x) {
return (net__Dialer) {
		._net__TCPDialer = x,
		._typ = _net__Dialer_net__TCPDialer_index,
	};
}

// Casting functions for converting "voidptr" to interface "net__Dialer"
static inline net__Dialer I_voidptr_to_Interface_net__Dialer(voidptr* x) {
return (net__Dialer) {
		._voidptr = x,
		._typ = _net__Dialer_voidptr_index,
	};
}

// Casting functions for converting "net__ssl__SSLDialer" to interface "net__Dialer"
static inline net__Dialer I_net__ssl__SSLDialer_to_Interface_net__Dialer(net__ssl__SSLDialer* x) {
return (net__Dialer) {
		._net__ssl__SSLDialer = x,
		._typ = _net__Dialer_net__ssl__SSLDialer_index,
	};
}

// Casting functions for converting "net__socks__SOCKS5Dialer" to interface "net__Dialer"
static inline net__Dialer I_net__socks__SOCKS5Dialer_to_Interface_net__Dialer(net__socks__SOCKS5Dialer* x) {
return (net__Dialer) {
		._net__socks__SOCKS5Dialer = x,
		._typ = _net__Dialer_net__socks__SOCKS5Dialer_index,
	};
}

static io__Reader I_net__TcpConn_to_Interface_io__Reader(net__TcpConn* x);
const int _io__Reader_net__TcpConn_index = 0;
static io__Reader I_voidptr_to_Interface_io__Reader(voidptr* x);
const int _io__Reader_voidptr_index = 1;
static io__Reader I_os__File_to_Interface_io__Reader(os__File* x);
const int _io__Reader_os__File_index = 2;
static io__Reader I_net__ssl__SSLConn_to_Interface_io__Reader(net__ssl__SSLConn* x);
const int _io__Reader_net__ssl__SSLConn_index = 3;
static io__Reader I_io__BufferedReader_to_Interface_io__Reader(io__BufferedReader* x);
const int _io__Reader_io__BufferedReader_index = 4;
static io__Reader I_io__ReaderWriterImpl_to_Interface_io__Reader(io__ReaderWriterImpl* x);
const int _io__Reader_io__ReaderWriterImpl_index = 5;
static io__Reader I_net__mbedtls__SSLConn_to_Interface_io__Reader(net__mbedtls__SSLConn* x);
const int _io__Reader_net__mbedtls__SSLConn_index = 6;
// ^^^ number of types for interface io__Reader: 7

// Methods wrapper for interface "io__Reader"
static inline _result_int net__TcpConn_read_Interface_io__Reader_method_wrapper(net__TcpConn* c, Array_u8* buf) {
	return net__TcpConn_read(*c, buf);
}

struct _io__Reader_interface_methods {
	_result_int (*_method_read)(void* _, Array_u8* buf);
};

struct _io__Reader_interface_methods io__Reader_name_table[7] = {
	{
		._method_read = (void*) net__TcpConn_read_Interface_io__Reader_method_wrapper,
	},
	{
		._method_read = (void*) 0,
	},
	{
		._method_read = (void*) os__File_read,
	},
	{
		._method_read = (void*) net__mbedtls__SSLConn_read,
	},
	{
		._method_read = (void*) io__BufferedReader_read,
	},
	{
		._method_read = (void*) io__ReaderWriterImpl_read,
	},
	{
		._method_read = (void*) net__mbedtls__SSLConn_read,
	},
};


// Casting functions for converting "net__TcpConn" to interface "io__Reader"
static inline io__Reader I_net__TcpConn_to_Interface_io__Reader(net__TcpConn* x) {
return (io__Reader) {
		._net__TcpConn = x,
		._typ = _io__Reader_net__TcpConn_index,
	};
}

// Casting functions for converting "voidptr" to interface "io__Reader"
static inline io__Reader I_voidptr_to_Interface_io__Reader(voidptr* x) {
return (io__Reader) {
		._voidptr = x,
		._typ = _io__Reader_voidptr_index,
	};
}

// Casting functions for converting "os__File" to interface "io__Reader"
static inline io__Reader I_os__File_to_Interface_io__Reader(os__File* x) {
return (io__Reader) {
		._os__File = x,
		._typ = _io__Reader_os__File_index,
	};
}

// Casting functions for converting "net__ssl__SSLConn" to interface "io__Reader"
static inline io__Reader I_net__ssl__SSLConn_to_Interface_io__Reader(net__ssl__SSLConn* x) {
return (io__Reader) {
		._net__ssl__SSLConn = x,
		._typ = _io__Reader_net__ssl__SSLConn_index,
	};
}

// Casting functions for converting "io__BufferedReader" to interface "io__Reader"
static inline io__Reader I_io__BufferedReader_to_Interface_io__Reader(io__BufferedReader* x) {
return (io__Reader) {
		._io__BufferedReader = x,
		._typ = _io__Reader_io__BufferedReader_index,
	};
}

// Casting functions for converting "io__ReaderWriterImpl" to interface "io__Reader"
static inline io__Reader I_io__ReaderWriterImpl_to_Interface_io__Reader(io__ReaderWriterImpl* x) {
return (io__Reader) {
		._io__ReaderWriterImpl = x,
		._typ = _io__Reader_io__ReaderWriterImpl_index,
	};
}

// Casting functions for converting "net__mbedtls__SSLConn" to interface "io__Reader"
static inline io__Reader I_net__mbedtls__SSLConn_to_Interface_io__Reader(net__mbedtls__SSLConn* x) {
return (io__Reader) {
		._net__mbedtls__SSLConn = x,
		._typ = _io__Reader_net__mbedtls__SSLConn_index,
	};
}

static io__Writer I_io__MultiWriter_to_Interface_io__Writer(io__MultiWriter* x);
const int _io__Writer_io__MultiWriter_index = 0;
static io__Writer I_voidptr_to_Interface_io__Writer(voidptr* x);
const int _io__Writer_voidptr_index = 1;
static io__Writer I_net__TcpConn_to_Interface_io__Writer(net__TcpConn* x);
const int _io__Writer_net__TcpConn_index = 2;
static io__Writer I_os__File_to_Interface_io__Writer(os__File* x);
const int _io__Writer_os__File_index = 3;
static io__Writer I_net__ssl__SSLConn_to_Interface_io__Writer(net__ssl__SSLConn* x);
const int _io__Writer_net__ssl__SSLConn_index = 4;
static io__Writer I_net__UdpConn_to_Interface_io__Writer(net__UdpConn* x);
const int _io__Writer_net__UdpConn_index = 5;
static io__Writer I_io__BufferedWriter_to_Interface_io__Writer(io__BufferedWriter* x);
const int _io__Writer_io__BufferedWriter_index = 6;
static io__Writer I_io__ReaderWriterImpl_to_Interface_io__Writer(io__ReaderWriterImpl* x);
const int _io__Writer_io__ReaderWriterImpl_index = 7;
static io__Writer I_net__mbedtls__SSLConn_to_Interface_io__Writer(net__mbedtls__SSLConn* x);
const int _io__Writer_net__mbedtls__SSLConn_index = 8;
static io__Writer I_crypto__sha256__Digest_to_Interface_io__Writer(crypto__sha256__Digest* x);
const int _io__Writer_crypto__sha256__Digest_index = 9;
// ^^^ number of types for interface io__Writer: 10

// Methods wrapper for interface "io__Writer"

struct _io__Writer_interface_methods {
	_result_int (*_method_write)(void* _, Array_u8 buf);
};

struct _io__Writer_interface_methods io__Writer_name_table[10] = {
	{
		._method_write = (void*) io__MultiWriter_write,
	},
	{
		._method_write = (void*) 0,
	},
	{
		._method_write = (void*) net__TcpConn_write,
	},
	{
		._method_write = (void*) os__File_write,
	},
	{
		._method_write = (void*) net__mbedtls__SSLConn_write,
	},
	{
		._method_write = (void*) net__UdpConn_write,
	},
	{
		._method_write = (void*) io__BufferedWriter_write,
	},
	{
		._method_write = (void*) io__ReaderWriterImpl_write,
	},
	{
		._method_write = (void*) net__mbedtls__SSLConn_write,
	},
	{
		._method_write = (void*) crypto__sha256__Digest_write,
	},
};


// Casting functions for converting "io__MultiWriter" to interface "io__Writer"
static inline io__Writer I_io__MultiWriter_to_Interface_io__Writer(io__MultiWriter* x) {
return (io__Writer) {
		._io__MultiWriter = x,
		._typ = _io__Writer_io__MultiWriter_index,
	};
}

// Casting functions for converting "voidptr" to interface "io__Writer"
static inline io__Writer I_voidptr_to_Interface_io__Writer(voidptr* x) {
return (io__Writer) {
		._voidptr = x,
		._typ = _io__Writer_voidptr_index,
	};
}

// Casting functions for converting "net__TcpConn" to interface "io__Writer"
static inline io__Writer I_net__TcpConn_to_Interface_io__Writer(net__TcpConn* x) {
return (io__Writer) {
		._net__TcpConn = x,
		._typ = _io__Writer_net__TcpConn_index,
	};
}

// Casting functions for converting "os__File" to interface "io__Writer"
static inline io__Writer I_os__File_to_Interface_io__Writer(os__File* x) {
return (io__Writer) {
		._os__File = x,
		._typ = _io__Writer_os__File_index,
	};
}

// Casting functions for converting "net__ssl__SSLConn" to interface "io__Writer"
static inline io__Writer I_net__ssl__SSLConn_to_Interface_io__Writer(net__ssl__SSLConn* x) {
return (io__Writer) {
		._net__ssl__SSLConn = x,
		._typ = _io__Writer_net__ssl__SSLConn_index,
	};
}

// Casting functions for converting "net__UdpConn" to interface "io__Writer"
static inline io__Writer I_net__UdpConn_to_Interface_io__Writer(net__UdpConn* x) {
return (io__Writer) {
		._net__UdpConn = x,
		._typ = _io__Writer_net__UdpConn_index,
	};
}

// Casting functions for converting "io__BufferedWriter" to interface "io__Writer"
static inline io__Writer I_io__BufferedWriter_to_Interface_io__Writer(io__BufferedWriter* x) {
return (io__Writer) {
		._io__BufferedWriter = x,
		._typ = _io__Writer_io__BufferedWriter_index,
	};
}

// Casting functions for converting "io__ReaderWriterImpl" to interface "io__Writer"
static inline io__Writer I_io__ReaderWriterImpl_to_Interface_io__Writer(io__ReaderWriterImpl* x) {
return (io__Writer) {
		._io__ReaderWriterImpl = x,
		._typ = _io__Writer_io__ReaderWriterImpl_index,
	};
}

// Casting functions for converting "net__mbedtls__SSLConn" to interface "io__Writer"
static inline io__Writer I_net__mbedtls__SSLConn_to_Interface_io__Writer(net__mbedtls__SSLConn* x) {
return (io__Writer) {
		._net__mbedtls__SSLConn = x,
		._typ = _io__Writer_net__mbedtls__SSLConn_index,
	};
}

// Casting functions for converting "crypto__sha256__Digest" to interface "io__Writer"
static inline io__Writer I_crypto__sha256__Digest_to_Interface_io__Writer(crypto__sha256__Digest* x) {
return (io__Writer) {
		._crypto__sha256__Digest = x,
		._typ = _io__Writer_crypto__sha256__Digest_index,
	};
}

static io__RandomReader I_os__File_to_Interface_io__RandomReader(os__File* x);
const int _io__RandomReader_os__File_index = 0;
static io__RandomReader I_voidptr_to_Interface_io__RandomReader(voidptr* x);
const int _io__RandomReader_voidptr_index = 1;
// ^^^ number of types for interface io__RandomReader: 2

// Methods wrapper for interface "io__RandomReader"

struct _io__RandomReader_interface_methods {
	_result_int (*_method_read_from)(void* _, u64 pos, Array_u8* buf);
};

struct _io__RandomReader_interface_methods io__RandomReader_name_table[2] = {
	{
		._method_read_from = (void*) os__File_read_from,
	},
	{
		._method_read_from = (void*) 0,
	},
};


// Casting functions for converting "os__File" to interface "io__RandomReader"
static inline io__RandomReader I_os__File_to_Interface_io__RandomReader(os__File* x) {
return (io__RandomReader) {
		._os__File = x,
		._typ = _io__RandomReader_os__File_index,
	};
}

// Casting functions for converting "voidptr" to interface "io__RandomReader"
static inline io__RandomReader I_voidptr_to_Interface_io__RandomReader(voidptr* x) {
return (io__RandomReader) {
		._voidptr = x,
		._typ = _io__RandomReader_voidptr_index,
	};
}

static io__ReaderWriter I_io__ReaderWriterImpl_to_Interface_io__ReaderWriter(io__ReaderWriterImpl* x);
const int _io__ReaderWriter_io__ReaderWriterImpl_index = 0;
static io__ReaderWriter I_voidptr_to_Interface_io__ReaderWriter(voidptr* x);
const int _io__ReaderWriter_voidptr_index = 1;
// ^^^ number of types for interface io__ReaderWriter: 2

// Methods wrapper for interface "io__ReaderWriter"

struct _io__ReaderWriter_interface_methods {
	_result_int (*_method_read)(void* _, Array_u8* buf);
	_result_int (*_method_write)(void* _, Array_u8 buf);
};

struct _io__ReaderWriter_interface_methods io__ReaderWriter_name_table[2] = {
	{
		._method_read = (void*) io__ReaderWriterImpl_read,
		._method_write = (void*) io__ReaderWriterImpl_write,
	},
	{
		._method_read = (void*) 0,
		._method_write = (void*) 0,
	},
};


// Casting functions for converting "io__ReaderWriterImpl" to interface "io__ReaderWriter"
static inline io__ReaderWriter I_io__ReaderWriterImpl_to_Interface_io__ReaderWriter(io__ReaderWriterImpl* x) {
return (io__ReaderWriter) {
		._io__ReaderWriterImpl = x,
		._typ = _io__ReaderWriter_io__ReaderWriterImpl_index,
	};
}

// Casting functions for converting "voidptr" to interface "io__ReaderWriter"
static inline io__ReaderWriter I_voidptr_to_Interface_io__ReaderWriter(voidptr* x) {
return (io__ReaderWriter) {
		._voidptr = x,
		._typ = _io__ReaderWriter_voidptr_index,
	};
}

// ^^^ number of types for interface io__RandomWriter: 0

// Methods wrapper for interface "io__RandomWriter"

struct _io__RandomWriter_interface_methods {
	_result_int (*_method_write_to)(void* _, u64 pos, Array_u8 buf);
};

struct _io__RandomWriter_interface_methods io__RandomWriter_name_table[1];


static rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x);
const int _rand__PRNG_rand__wyrand__WyRandRNG_index = 0;
static rand__PRNG I_voidptr_to_Interface_rand__PRNG(voidptr* x);
const int _rand__PRNG_voidptr_index = 1;
// ^^^ number of types for interface rand__PRNG: 2

// Methods wrapper for interface "rand__PRNG"

struct _rand__PRNG_interface_methods {
	int (*_method_block_size)(void* _);
	void (*_method__v_free)(void* _);
	void (*_method_seed)(void* _, Array_u32 seed_data);
	u16 (*_method_u16)(void* _);
	u32 (*_method_u32)(void* _);
	u64 (*_method_u64)(void* _);
	u8 (*_method_u8)(void* _);
};

struct _rand__PRNG_interface_methods rand__PRNG_name_table[2] = {
	{
		._method_block_size = (void*) rand__wyrand__WyRandRNG_block_size,
		._method__v_free = (void*) rand__wyrand__WyRandRNG_free,
		._method_seed = (void*) rand__wyrand__WyRandRNG_seed,
		._method_u16 = (void*) rand__wyrand__WyRandRNG_u16,
		._method_u32 = (void*) rand__wyrand__WyRandRNG_u32,
		._method_u64 = (void*) rand__wyrand__WyRandRNG_u64,
		._method_u8 = (void*) rand__wyrand__WyRandRNG_u8,
	},
	{
		._method_block_size = (void*) 0,
		._method__v_free = (void*) 0,
		._method_seed = (void*) 0,
		._method_u16 = (void*) 0,
		._method_u32 = (void*) 0,
		._method_u64 = (void*) 0,
		._method_u8 = (void*) 0,
	},
};


// Casting functions for converting "rand__wyrand__WyRandRNG" to interface "rand__PRNG"
static inline rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x) {
return (rand__PRNG) {
		._rand__wyrand__WyRandRNG = x,
		._typ = _rand__PRNG_rand__wyrand__WyRandRNG_index,
	};
}

// Casting functions for converting "voidptr" to interface "rand__PRNG"
static inline rand__PRNG I_voidptr_to_Interface_rand__PRNG(voidptr* x) {
return (rand__PRNG) {
		._voidptr = x,
		._typ = _rand__PRNG_voidptr_index,
	};
}

static hash__Hash I_crypto__sha256__Digest_to_Interface_hash__Hash(crypto__sha256__Digest* x);
const int _hash__Hash_crypto__sha256__Digest_index = 0;
static hash__Hash I_voidptr_to_Interface_hash__Hash(voidptr* x);
const int _hash__Hash_voidptr_index = 1;
// ^^^ number of types for interface hash__Hash: 2

// Methods wrapper for interface "hash__Hash"

struct _hash__Hash_interface_methods {
	int (*_method_block_size)(void* _);
	void (*_method__v_free)(void* _);
	void (*_method_reset)(void* _);
	int (*_method_size)(void* _);
	Array_u8 (*_method_sum)(void* _, Array_u8 b);
	_result_int (*_method_write)(void* _, Array_u8 p);
};

struct _hash__Hash_interface_methods hash__Hash_name_table[2] = {
	{
		._method_block_size = (void*) crypto__sha256__Digest_block_size,
		._method__v_free = (void*) crypto__sha256__Digest_free,
		._method_reset = (void*) crypto__sha256__Digest_reset,
		._method_size = (void*) crypto__sha256__Digest_size,
		._method_sum = (void*) crypto__sha256__Digest_sum,
		._method_write = (void*) crypto__sha256__Digest_write,
	},
	{
		._method_block_size = (void*) 0,
		._method__v_free = (void*) 0,
		._method_reset = (void*) 0,
		._method_size = (void*) 0,
		._method_sum = (void*) 0,
		._method_write = (void*) 0,
	},
};


// Casting functions for converting "crypto__sha256__Digest" to interface "hash__Hash"
static inline hash__Hash I_crypto__sha256__Digest_to_Interface_hash__Hash(crypto__sha256__Digest* x) {
return (hash__Hash) {
		._crypto__sha256__Digest = x,
		._typ = _hash__Hash_crypto__sha256__Digest_index,
	};
}

// Casting functions for converting "voidptr" to interface "hash__Hash"
static inline hash__Hash I_voidptr_to_Interface_hash__Hash(voidptr* x) {
return (hash__Hash) {
		._voidptr = x,
		._typ = _hash__Hash_voidptr_index,
	};
}

// ^^^ number of types for interface hash__Hash32er: 0

// Methods wrapper for interface "hash__Hash32er"

struct _hash__Hash32er_interface_methods {
	u32 (*_method_sum32)(void* _);
};

struct _hash__Hash32er_interface_methods hash__Hash32er_name_table[1];


// ^^^ number of types for interface hash__Hash64er: 0

// Methods wrapper for interface "hash__Hash64er"

struct _hash__Hash64er_interface_methods {
	u64 (*_method_sum64)(void* _);
};

struct _hash__Hash64er_interface_methods hash__Hash64er_name_table[1];



// V channel code:

static inline net__TcpConn* __chan_net__TcpConn_ptr_popval(chan_net__TcpConn_ptr ch) {
	net__TcpConn* val;
	sync__Channel_try_pop_priv(ch, &val, false);
	return val;
}

static inline void __chan_net__TcpConn_ptr_pushval(chan_net__TcpConn_ptr ch, net__TcpConn* val) {
	sync__Channel_try_push_priv(ch, &val, false);
}

// V closure helpers
#include <sys/mman.h>

#ifdef _MSC_VER
	#define __RETURN_ADDRESS() ((char*)_ReturnAddress())
#elif defined(__TINYC__) && defined(_WIN32)
	#define __RETURN_ADDRESS() ((char*)__builtin_return_address(0))
#else
	#define __RETURN_ADDRESS() ((char*)__builtin_extract_return_addr(__builtin_return_address(0)))
#endif

static int _V_page_size = 0x4000; // 16K
#define ASSUMED_PAGE_SIZE 0x4000
#define _CLOSURE_SIZE (((2*sizeof(void*) > sizeof(__closure_thunk) ? 2*sizeof(void*) : sizeof(__closure_thunk)) + sizeof(void*) - 1) & ~(sizeof(void*) - 1))
// equal to `max(2*sizeof(void*), sizeof(__closure_thunk))`, rounded up to the next multiple of `sizeof(void*)`

// refer to https://godbolt.org/z/r7P3EYv6c for a complete assembly
#ifdef __V_amd64
static const char __closure_thunk[] = {
	0xF3, 0x44, 0x0F, 0x7E, 0x3D, 0xF7, 0xBF, 0xFF, 0xFF,  // movq  xmm15, QWORD PTR [rip - userdata]
	0xFF, 0x25, 0xF9, 0xBF, 0xFF, 0xFF                     // jmp  QWORD PTR [rip - fn]
};
static char __CLOSURE_GET_DATA_BYTES[] = {
	0x66, 0x4C, 0x0F, 0x7E, 0xF8,  // movq rax, xmm15
	0xC3                           // ret
};
#elif defined(__V_x86)
static char __closure_thunk[] = {
	0xe8, 0x00, 0x00, 0x00, 0x00,        // call here
	                                     // here:
	0x59,                                // pop  ecx
	0x66, 0x0F, 0x6E, 0xF9,              // movd xmm7, ecx
	0xff, 0xA1, 0xff, 0xbf, 0xff, 0xff,  // jmp  DWORD PTR [ecx - 0x4001] # <fn>
};

static char __CLOSURE_GET_DATA_BYTES[] = {
	0x66, 0x0F, 0x7E, 0xF8,              // movd eax, xmm7
	0x8B, 0x80, 0xFB, 0xBF, 0xFF, 0xFF,  // mov eax, DWORD PTR [eax - 0x4005]
	0xc3                                 // ret
};

#elif defined(__V_arm64)
static char __closure_thunk[] = {
	0x11, 0x00, 0xFE, 0x58,  // ldr x17, userdata
	0x30, 0x00, 0xFE, 0x58,  // ldr x16, fn
	0x00, 0x02, 0x1F, 0xD6   // br  x16
};
static char __CLOSURE_GET_DATA_BYTES[] = {
	0xE0, 0x03, 0x11, 0xAA,  // mov x0, x17
	0xC0, 0x03, 0x5F, 0xD6   // ret
};
#elif defined(__V_arm32)
static char __closure_thunk[] = {
	0x04, 0xC0, 0x4F, 0xE2,  // adr ip, here
                             // here:
	0x01, 0xC9, 0x4C, 0xE2,  // sub  ip, ip, #0x4000
	0x90, 0xCA, 0x07, 0xEE,  // vmov s15, ip
	0x00, 0xC0, 0x9C, 0xE5,  // ldr  ip, [ip, 0]
	0x1C, 0xFF, 0x2F, 0xE1   // bx   ip
};
static char __CLOSURE_GET_DATA_BYTES[] = {
	0x90, 0x0A, 0x17, 0xEE,  // vmov r0, s15
	0x04, 0x00, 0x10, 0xE5,  // ldr r0, [r0, #-4]
	0x1E, 0xFF, 0x2F, 0xE1   // bx lr
};
#elif defined (__V_rv64)
static char __closure_thunk[] = {
	0x97, 0xCF, 0xFF, 0xFF,  // auipc t6, 0xffffc
	0x03, 0xBF, 0x8F, 0x00,  // ld    t5, 8(t6)
	0x67, 0x00, 0x0F, 0x00   // jr    t5
};
static char __CLOSURE_GET_DATA_BYTES[] = {
	0x03, 0xb5, 0x0f, 0x00,  // ld    a0, 0(t6)
	0x67, 0x80, 0x00, 0x00   // ret
};
#elif defined (__V_rv32)
static char __closure_thunk[] = {
	0x97, 0xCF, 0xFF, 0xFF,  // auipc t6, 0xffffc
	0x03, 0xAF, 0x4F, 0x00,  // lw    t5, 4(t6)
	0x67, 0x00, 0x0F, 0x00   // jr    t5
};
static char __CLOSURE_GET_DATA_BYTES[] = {
	0x03, 0xA5, 0x0F, 0x00,  // lw    a0, 0(t6)
	0x67, 0x80, 0x00, 0x00   // ret
};
#endif

static void*(*__CLOSURE_GET_DATA)(void) = 0;

static inline void __closure_set_data(char* closure, void* data) {
	void** p = (void**)(closure - ASSUMED_PAGE_SIZE);
	p[0] = data;
}

static inline void __closure_set_function(char* closure, void* f) {
	void** p = (void**)(closure - ASSUMED_PAGE_SIZE);
	p[1] = f;
}

#ifdef _WIN32
#include <synchapi.h>
static SRWLOCK _closure_mtx;
#define _closure_mtx_init() InitializeSRWLock(&_closure_mtx)
#define _closure_mtx_lock() AcquireSRWLockExclusive(&_closure_mtx)
#define _closure_mtx_unlock() ReleaseSRWLockExclusive(&_closure_mtx)
#else
static pthread_mutex_t _closure_mtx;
#define _closure_mtx_init() pthread_mutex_init(&_closure_mtx, 0)
#define _closure_mtx_lock() pthread_mutex_lock(&_closure_mtx)
#define _closure_mtx_unlock() pthread_mutex_unlock(&_closure_mtx)
#endif


// end of V out (header)

// V closure helpers

	static char* _closure_ptr = 0;
	static int _closure_cap = 0;

static void __closure_alloc(void) {
#ifdef _WIN32
	char* p = VirtualAlloc(NULL, _V_page_size * 2, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (p == NULL) return;
#else
	char* p = mmap(0, _V_page_size * 2, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
	if (p == MAP_FAILED) return;
#endif
	char* x = p + _V_page_size;
	int remaining = _V_page_size / _CLOSURE_SIZE;
	_closure_ptr = x;
	_closure_cap = remaining;
	while (remaining > 0) {
		memcpy(x, __closure_thunk, sizeof(__closure_thunk));
		remaining--;
		x += _CLOSURE_SIZE;
	}
#ifdef _WIN32
	DWORD _tmp;
	VirtualProtect(_closure_ptr, _V_page_size, PAGE_EXECUTE_READ, &_tmp);
#else
	mprotect(_closure_ptr, _V_page_size, PROT_READ | PROT_EXEC);
#endif
}

#ifdef _WIN32
void __closure_init() {
	SYSTEM_INFO si;
	GetNativeSystemInfo(&si);
	uint32_t page_size = si.dwPageSize * (((ASSUMED_PAGE_SIZE - 1) / si.dwPageSize) + 1);
	_V_page_size = page_size;
	__closure_alloc();
	DWORD _tmp;
	VirtualProtect(_closure_ptr, page_size, PAGE_READWRITE, &_tmp);
	memcpy(_closure_ptr, __CLOSURE_GET_DATA_BYTES, sizeof(__CLOSURE_GET_DATA_BYTES));
	VirtualProtect(_closure_ptr, page_size, PAGE_EXECUTE_READ, &_tmp);
	__CLOSURE_GET_DATA = (void*)_closure_ptr;
	_closure_ptr += _CLOSURE_SIZE;
	_closure_cap--;
}
#else
static void __closure_init() {
	uint32_t page_size = sysconf(_SC_PAGESIZE);
	page_size = page_size * (((ASSUMED_PAGE_SIZE - 1) / page_size) + 1);
	_V_page_size = page_size;
	__closure_alloc();
	mprotect(_closure_ptr, page_size, PROT_READ | PROT_WRITE);
	memcpy(_closure_ptr, __CLOSURE_GET_DATA_BYTES, sizeof(__CLOSURE_GET_DATA_BYTES));
	mprotect(_closure_ptr, page_size, PROT_READ | PROT_EXEC);
	__CLOSURE_GET_DATA = (void*)_closure_ptr;
	_closure_ptr += _CLOSURE_SIZE;
	_closure_cap--;
}
#endif

static void* __closure_create(void* fn, void* data) {
	_closure_mtx_lock();
	if (_closure_cap == 0) {
		__closure_alloc();
	}
	_closure_cap--;
	void* closure = _closure_ptr;
	_closure_ptr += _CLOSURE_SIZE;
	__closure_set_data(closure, data);
	__closure_set_function(closure, fn);
	_closure_mtx_unlock();
	return closure;
}


// V gowrappers waiter fns:
void* picoev__update_date_string_thread_wrapper(thread_arg_picoev__update_date_string *arg);

// V auto str functions:
static string sql_db__Personal_str(sql_db__Personal it) { return indent_sql_db__Personal_str(it, 0);}
static string net__TcpSocket_str(net__TcpSocket it) { return indent_net__TcpSocket_str(it, 0);}
static string Array_net__http__Method_str(Array_net__http__Method a) { return indent_Array_net__http__Method_str(a, 0);}
static string indent_Array_net__http__Method_str(Array_net__http__Method a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		net__http__Method it = *(net__http__Method*)array_get(a, i);
		strings__Builder_write_string(&sb, _SLIT(""));
		string x = net__http__Method_str(it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_sql_db__PersonalFlag_str(Array_sql_db__PersonalFlag a) { return indent_Array_sql_db__PersonalFlag_str(a, 0);}
static string indent_Array_sql_db__PersonalFlag_str(Array_sql_db__PersonalFlag a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		sql_db__PersonalFlag it = *(sql_db__PersonalFlag*)array_get(a, i);
		string x = indent_sql_db__PersonalFlag_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string net__Socket_str(net__Socket it) { return indent_net__Socket_str(it, 0);}
static string sql_db__PersonalFlag_str(sql_db__PersonalFlag it) { return indent_sql_db__PersonalFlag_str(it, 0);}

// V auto functions:
string indent_sql_db__Personal_str(sql_db__Personal it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t1 = indent_Array_sql_db__PersonalFlag_str(it.challenge, indent_count + 1);
	string res = str_intp( 27, _MOV((StrIntpData[]){
		{_SLIT("sql_db.Personal{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    pid: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.pid}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    id: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.id}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    email: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.email}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    passwd: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.passwd}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    whoami: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.whoami}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    challenge: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t1}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t1);
	string_free(&indents);
	return res;
}

string indent_net__TcpSocket_str(net__TcpSocket it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t1 = indent_net__Socket_str(it.Socket, indent_count + 1);
	string res = str_intp( 7, _MOV((StrIntpData[]){
		{_SLIT("net.TcpSocket{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    Socket: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t1}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t1);
	string_free(&indents);
	return res;
}

string indent_net__Socket_str(net__Socket it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string res = str_intp( 7, _MOV((StrIntpData[]){
		{_SLIT("net.Socket{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    handle: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.handle}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&indents);
	return res;
}

string indent_sql_db__PersonalFlag_str(sql_db__PersonalFlag it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string res = str_intp( 15, _MOV((StrIntpData[]){
		{_SLIT("sql_db.PersonalFlag{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    parents_id: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.parents_id}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    parents_challenge: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.parents_challenge}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    complete: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.complete}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&indents);
	return res;
}

orm__Primitive orm__Null_to_sumtype_orm__Primitive(orm__Null* x) {
	orm__Null* ptr = memdup(x, sizeof(orm__Null));
	return (orm__Primitive){ ._orm__Null = ptr, ._typ = 144};
}

orm__Primitive bool_to_sumtype_orm__Primitive(bool* x) {
	bool* ptr = memdup(x, sizeof(bool));
	return (orm__Primitive){ ._bool = ptr, ._typ = 19};
}

orm__Primitive f32_to_sumtype_orm__Primitive(f32* x) {
	f32* ptr = memdup(x, sizeof(f32));
	return (orm__Primitive){ ._f32 = ptr, ._typ = 16};
}

orm__Primitive f64_to_sumtype_orm__Primitive(f64* x) {
	f64* ptr = memdup(x, sizeof(f64));
	return (orm__Primitive){ ._f64 = ptr, ._typ = 17};
}

orm__Primitive i8_to_sumtype_orm__Primitive(i8* x) {
	i8* ptr = memdup(x, sizeof(i8));
	return (orm__Primitive){ ._i8 = ptr, ._typ = 5};
}

orm__Primitive i16_to_sumtype_orm__Primitive(i16* x) {
	i16* ptr = memdup(x, sizeof(i16));
	return (orm__Primitive){ ._i16 = ptr, ._typ = 6};
}

orm__Primitive int_to_sumtype_orm__Primitive(int* x) {
	int* ptr = memdup(x, sizeof(int));
	return (orm__Primitive){ ._int = ptr, ._typ = 8};
}

orm__Primitive i64_to_sumtype_orm__Primitive(i64* x) {
	i64* ptr = memdup(x, sizeof(i64));
	return (orm__Primitive){ ._i64 = ptr, ._typ = 9};
}

orm__Primitive u8_to_sumtype_orm__Primitive(u8* x) {
	u8* ptr = memdup(x, sizeof(u8));
	return (orm__Primitive){ ._u8 = ptr, ._typ = 11};
}

orm__Primitive u16_to_sumtype_orm__Primitive(u16* x) {
	u16* ptr = memdup(x, sizeof(u16));
	return (orm__Primitive){ ._u16 = ptr, ._typ = 12};
}

orm__Primitive u32_to_sumtype_orm__Primitive(u32* x) {
	u32* ptr = memdup(x, sizeof(u32));
	return (orm__Primitive){ ._u32 = ptr, ._typ = 13};
}

orm__Primitive u64_to_sumtype_orm__Primitive(u64* x) {
	u64* ptr = memdup(x, sizeof(u64));
	return (orm__Primitive){ ._u64 = ptr, ._typ = 14};
}

orm__Primitive string_to_sumtype_orm__Primitive(string* x) {
	string* ptr = memdup(x, sizeof(string));
	return (orm__Primitive){ ._string = ptr, ._typ = 21};
}

orm__Primitive time__Time_to_sumtype_orm__Primitive(time__Time* x) {
	time__Time* ptr = memdup(x, sizeof(time__Time));
	return (orm__Primitive){ ._time__Time = ptr, ._typ = 142};
}

orm__Primitive orm__InfixType_to_sumtype_orm__Primitive(orm__InfixType* x) {
	orm__InfixType* ptr = memdup(x, sizeof(orm__InfixType));
	return (orm__Primitive){ ._orm__InfixType = ptr, ._typ = 143};
}

static bool Array_u8_contains(Array_u8 a, u8 v) {
	for (int i = 0; i < a.len; ++i) {
		if (((u8*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_int_contains(Array_int a, int v) {
	for (int i = 0; i < a.len; ++i) {
		if (((int*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_string_contains(Array_string a, string v) {
	for (int i = 0; i < a.len; ++i) {
		if (fast_string_eq(((string*)a.data)[i], v)) {
			return true;
		}
	}
	return false;
}

static bool Array_sql_db__PostFlag_contains(Array_sql_db__PostFlag a, sql_db__PostFlag v) {
	for (int i = 0; i < a.len; ++i) {
		if (sql_db__PostFlag_struct_eq(((sql_db__PostFlag*)a.data)[i], v)) {
			return true;
		}
	}
	return false;
}

static bool Array_net__http__Method_contains(Array_net__http__Method a, net__http__Method v) {
	for (int i = 0; i < a.len; ++i) {
		if (((net__http__Method*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

inline bool Array_string_arr_eq(Array_string a, Array_string b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!string__eq(*((string*)((byte*)a.data+(i*a.element_size))), *((string*)((byte*)b.data+(i*b.element_size))))) {
			return false;
		}
	}
	return true;
}

inline bool sql_db__PostFlag_struct_eq(sql_db__PostFlag a, sql_db__PostFlag b) {
	return a.parents_challenge == b.parents_challenge
		&& ((a.flag.len == b.flag.len && a.flag.len == 0) || fast_string_eq(a.flag, b.flag));
}


// V json forward decls:
_result_Array_main__Rank json__decode_Array_main__Rank(cJSON* root);
cJSON* json__encode_Array_main__Rank(Array_main__Rank val);

_result_main__Rank json__decode_main__Rank(cJSON* root);
cJSON* json__encode_main__Rank(main__Rank val);

_result_Array_bool json__decode_Array_bool(cJSON* root);
cJSON* json__encode_Array_bool(Array_bool val);


// V gowrappers:
void* picoev__update_date_string_thread_wrapper(thread_arg_picoev__update_date_string *arg) {
	arg->fn(arg->arg1);
	_v_free(arg);
	return 0;
}

_result_Array_main__Rank json__decode_Array_main__Rank(cJSON* root) {
	Array_main__Rank res = __new_array(0, 0, sizeof(main__Rank));
	if (!root) {
		const char *error_ptr = cJSON_GetErrorPtr();
		if (error_ptr != NULL) {
			const int error_pos = (int)cJSON_GetErrorPos();
			int maxcontext_chars = 30;
			byte *buf = vcalloc_noscan(maxcontext_chars + 10);
			if (error_pos > 0) {
				int backlines = 1;
				int backchars = error_pos < maxcontext_chars-7 ? (int)error_pos : maxcontext_chars-7 ;
				char *prevline_ptr = (char*)error_ptr;
				while(backchars--){
					char prevc = *(prevline_ptr - 1);
					if(0==prevc){
						break;
					}
					if(10==prevc && !backlines--){
						break;
					}
					prevline_ptr--;
					if(123==prevc) {
						break; // stop at `{` too
					}
				}
				int maxchars = vstrlen_char(prevline_ptr);
				vmemcpy(buf, prevline_ptr, (maxchars < maxcontext_chars ? maxchars : maxcontext_chars));
			}
			string msg;
			msg = _SLIT("failed to decode JSON string");
			if (buf[0] != '\0') {
				msg = string__plus(msg, _SLIT(": "));
			}
			return (_result_Array_main__Rank){.is_error = true,.err = _v_error(string__plus(msg, tos2(buf))),.data = {0}};
		}
	}


	if(root && !cJSON_IsArray(root) && !cJSON_IsNull(root)) {
		return (_result_Array_main__Rank){.is_error = true, .err = _v_error(string__plus(_SLIT("Json element is not an array: "), json__json_print(root))), .data = {0}};
	}
	res = __new_array(0, 0, sizeof(main__Rank));
	const cJSON *jsval = NULL;
	
	cJSON_ArrayForEach(jsval, root)
	{
		
		_result_main__Rank val2 = json__decode_main__Rank ((cJSON *)jsval);
		if(val2.is_error) {
			array_free(&res);
			return *(_result_Array_main__Rank*)&val2;
		}
		main__Rank val = *(main__Rank*)val2.data;

		array_push((array*)&res, &val);
		
	}

	_result_Array_main__Rank ret;
	_result_ok(&res, (_result*)&ret, sizeof(res));
	return ret;
}


cJSON* json__encode_Array_main__Rank(Array_main__Rank val) {
	cJSON *o;

	o = cJSON_CreateArray();
	for (int i = 0; i < val.len; i++){
		cJSON_AddItemToArray(o, json__encode_main__Rank( ((main__Rank*)val.data)[i] ));
	}

	return o;
}


_result_main__Rank json__decode_main__Rank(cJSON* root) {
	main__Rank res = (main__Rank){.team_id = (string){.str=(byteptr)"", .is_lit=1},.score = 0,.challenge = __new_array_noscan(0, 0, sizeof(bool)),};
	if (!root) {
		const char *error_ptr = cJSON_GetErrorPtr();
		if (error_ptr != NULL) {
			const int error_pos = (int)cJSON_GetErrorPos();
			int maxcontext_chars = 30;
			byte *buf = vcalloc_noscan(maxcontext_chars + 10);
			if (error_pos > 0) {
				int backlines = 1;
				int backchars = error_pos < maxcontext_chars-7 ? (int)error_pos : maxcontext_chars-7 ;
				char *prevline_ptr = (char*)error_ptr;
				while(backchars--){
					char prevc = *(prevline_ptr - 1);
					if(0==prevc){
						break;
					}
					if(10==prevc && !backlines--){
						break;
					}
					prevline_ptr--;
					if(123==prevc) {
						break; // stop at `{` too
					}
				}
				int maxchars = vstrlen_char(prevline_ptr);
				vmemcpy(buf, prevline_ptr, (maxchars < maxcontext_chars ? maxchars : maxcontext_chars));
			}
			string msg;
			msg = _SLIT("failed to decode JSON string");
			if (buf[0] != '\0') {
				msg = string__plus(msg, _SLIT(": "));
			}
			return (_result_main__Rank){.is_error = true,.err = _v_error(string__plus(msg, tos2(buf))),.data = {0}};
		}
	}

	cJSON *jsonroot__t1 = js_get(root, "team_id");
	if (jsonroot__t1) {
		if (!(cJSON_IsNull(jsonroot__t1) || cJSON_IsString(jsonroot__t1))) {
			return (_result_main__Rank){ .is_error = true, .err = _v_error(string__plus(_SLIT("type mismatch for field 'team_id', expecting `string` type, got: "), json__json_print(jsonroot__t1))), .data = {0} };
		}
		res.team_id = json__decode_string(jsonroot__t1);
	}
	cJSON *jsonroot__t2 = js_get(root, "score");
	if (jsonroot__t2) {
		if (!(cJSON_IsNull(jsonroot__t2) || cJSON_IsNumber(jsonroot__t2) || (cJSON_IsString(jsonroot__t2) && strlen(jsonroot__t2->valuestring)))) {
			return (_result_main__Rank){ .is_error = true, .err = _v_error(string__plus(_SLIT("type mismatch for field 'score', expecting `int` type, got: "), json__json_print(jsonroot__t2))), .data = {0} };
		}
		res.score = json__decode_int(jsonroot__t2);
	}
	cJSON *jsonroot__t3 = js_get(root, "challenge");
	_result_Array_bool _t3 = {0};
	if (jsonroot__t3) {
		_t3 = json__decode_Array_bool(jsonroot__t3);
		if (_t3.is_error) {
			return (_result_main__Rank){ .is_error = true, .err = _t3.err, .data = {0} };
		}
	}
	if (jsonroot__t3) {
		res.challenge = *(Array_bool*) _t3.data;
	}
	_result_main__Rank ret;
	_result_ok(&res, (_result*)&ret, sizeof(res));
	return ret;
}


cJSON* json__encode_main__Rank(main__Rank val) {
	cJSON *o;
	o = cJSON_CreateObject();
		cJSON_AddItemToObject(o, "team_id", json__encode_string(val.team_id));
		cJSON_AddItemToObject(o, "score", json__encode_int(val.score));
		cJSON_AddItemToObject(o, "challenge", json__encode_Array_bool(val.challenge));
	return o;
}


_result_Array_bool json__decode_Array_bool(cJSON* root) {
	Array_bool res = __new_array_noscan(0, 0, sizeof(bool));
	if (!root) {
		const char *error_ptr = cJSON_GetErrorPtr();
		if (error_ptr != NULL) {
			const int error_pos = (int)cJSON_GetErrorPos();
			int maxcontext_chars = 30;
			byte *buf = vcalloc_noscan(maxcontext_chars + 10);
			if (error_pos > 0) {
				int backlines = 1;
				int backchars = error_pos < maxcontext_chars-7 ? (int)error_pos : maxcontext_chars-7 ;
				char *prevline_ptr = (char*)error_ptr;
				while(backchars--){
					char prevc = *(prevline_ptr - 1);
					if(0==prevc){
						break;
					}
					if(10==prevc && !backlines--){
						break;
					}
					prevline_ptr--;
					if(123==prevc) {
						break; // stop at `{` too
					}
				}
				int maxchars = vstrlen_char(prevline_ptr);
				vmemcpy(buf, prevline_ptr, (maxchars < maxcontext_chars ? maxchars : maxcontext_chars));
			}
			string msg;
			msg = _SLIT("failed to decode JSON string");
			if (buf[0] != '\0') {
				msg = string__plus(msg, _SLIT(": "));
			}
			return (_result_Array_bool){.is_error = true,.err = _v_error(string__plus(msg, tos2(buf))),.data = {0}};
		}
	}


	if(root && !cJSON_IsArray(root) && !cJSON_IsNull(root)) {
		return (_result_Array_bool){.is_error = true, .err = _v_error(string__plus(_SLIT("Json element is not an array: "), json__json_print(root))), .data = {0}};
	}
	res = __new_array_noscan(0, 0, sizeof(bool));
	const cJSON *jsval = NULL;
	
	cJSON_ArrayForEach(jsval, root)
	{
		bool val = json__decode_bool((cJSON *)jsval); 
		array_push_noscan((array*)&res, &val);
		
	}

	_result_Array_bool ret;
	_result_ok(&res, (_result*)&ret, sizeof(res));
	return ret;
}


cJSON* json__encode_Array_bool(Array_bool val) {
	cJSON *o;

	o = cJSON_CreateArray();
	for (int i = 0; i < val.len; i++){
		cJSON_AddItemToArray(o, json__encode_bool( ((bool*)val.data)[i] ));
	}

	return o;
}


// V anon functions:
VV_LOCAL_SYMBOL int anon_fn_2d57aea9634ebb26_voidptr_c__mbedtls_ssl_context_char_int__int_6734(voidptr p_info, mbedtls_ssl_context* ssl, char* name, int lng) {
	struct _V_anon_fn_2d57aea9634ebb26_voidptr_c__mbedtls_ssl_context_char_int__int_6734_Ctx* _V_closure_ctx = __CLOSURE_GET_DATA();
	string host = char_vstring_literal_with_len(name, lng);
	_result_net__mbedtls__SSLCerts_ptr _t1;
	if (_t1 = _V_closure_ctx->get_cert_callback(_V_closure_ctx->l, host), !_t1.is_error) {
		net__mbedtls__SSLCerts* certs = *(net__mbedtls__SSLCerts**)_t1.data;
		return mbedtls_ssl_set_hs_own_cert(ssl, &certs->client_cert, &certs->client_key);
	} else {
		IError err = _t1.err;
		return -1;
	}
	return 0;
}

VV_LOCAL_SYMBOL bool anon_fn_ccb961b82e6b9984_mut_t__bool_9654_T_main__Context(main__Context* ctx) {
	struct _V_anon_fn_ccb961b82e6b9984_mut_t__bool_9654_T_main__Context_Ctx* _V_closure_ctx = __CLOSURE_GET_DATA();
	if (ctx->Context.req.method == net__http__Method__options) {
		veb__CorsOptions_set_headers(&_V_closure_ctx->options, (voidptr)&ctx->Context);
		veb__Context_text(&ctx->Context, _SLIT("ok"));
		return false;
	} else {
		if (veb__CorsOptions_validate_request(&_V_closure_ctx->options, (voidptr)&ctx->Context) == false) {
			return false;
		}
		return true;
	}
	return 0;
}


// >> typeof() support for sum types / interfaces
static char * v_typeof_interface_IError(int sidx) {
	if (sidx == _IError_None___index) return "None__";
	if (sidx == _IError_voidptr_index) return "voidptr";
	if (sidx == _IError_Error_index) return "Error";
	if (sidx == _IError_MessageError_index) return "MessageError";
	if (sidx == _IError_time__TimeParseError_index) return "time.TimeParseError";
	if (sidx == _IError_io__Eof_index) return "io.Eof";
	if (sidx == _IError_io__NotExpected_index) return "io.NotExpected";
	if (sidx == _IError_os__Eof_index) return "os.Eof";
	if (sidx == _IError_os__NotExpected_index) return "os.NotExpected";
	if (sidx == _IError_os__FileNotOpenedError_index) return "os.FileNotOpenedError";
	if (sidx == _IError_os__SizeOfTypeIs0Error_index) return "os.SizeOfTypeIs0Error";
	if (sidx == _IError_os__ExecutableNotFoundError_index) return "os.ExecutableNotFoundError";
	if (sidx == _IError_db__sqlite__SQLError_index) return "db.sqlite.SQLError";
	if (sidx == _IError_net__http__HeaderKeyError_index) return "net.http.HeaderKeyError";
	if (sidx == _IError_net__http__MultiplePathAttributesError_index) return "net.http.MultiplePathAttributesError";
	if (sidx == _IError_net__http__UnexpectedExtraAttributeError_index) return "net.http.UnexpectedExtraAttributeError";
	return "unknown IError";
}

int v_typeof_interface_idx_IError(int sidx) {
	if (sidx == _IError_None___index) return 82;
	if (sidx == _IError_voidptr_index) return 2;
	if (sidx == _IError_Error_index) return 83;
	if (sidx == _IError_MessageError_index) return 85;
	if (sidx == _IError_time__TimeParseError_index) return 292;
	if (sidx == _IError_io__Eof_index) return 246;
	if (sidx == _IError_io__NotExpected_index) return 434;
	if (sidx == _IError_os__Eof_index) return 375;
	if (sidx == _IError_os__NotExpected_index) return 376;
	if (sidx == _IError_os__FileNotOpenedError_index) return 377;
	if (sidx == _IError_os__SizeOfTypeIs0Error_index) return 378;
	if (sidx == _IError_os__ExecutableNotFoundError_index) return 397;
	if (sidx == _IError_db__sqlite__SQLError_index) return 150;
	if (sidx == _IError_net__http__HeaderKeyError_index) return 316;
	if (sidx == _IError_net__http__MultiplePathAttributesError_index) return 229;
	if (sidx == _IError_net__http__UnexpectedExtraAttributeError_index) return 230;
	return 30;
}
char * v_typeof_sumtype_orm__Primitive(int sidx) {
	switch(sidx) {
		case 136: return "orm.Primitive";
		case 143: return "orm.InfixType";
		case 144: return "orm.Null";
		case 19: return "bool";
		case 16: return "f32";
		case 17: return "f64";
		case 6: return "i16";
		case 9: return "i64";
		case 5: return "i8";
		case 8: return "int";
		case 21: return "string";
		case 142: return "time.Time";
		case 12: return "u16";
		case 13: return "u32";
		case 14: return "u64";
		case 11: return "u8";
		default: return "unknown orm.Primitive";
	}
}

int v_typeof_sumtype_idx_orm__Primitive(int sidx) {
	switch(sidx) {
		case 136: return 136;
		case 143: return 143;
		case 144: return 144;
		case 19: return 19;
		case 16: return 16;
		case 17: return 17;
		case 6: return 6;
		case 9: return 9;
		case 5: return 5;
		case 8: return 8;
		case 21: return 21;
		case 142: return 142;
		case 12: return 12;
		case 13: return 13;
		case 14: return 14;
		case 11: return 11;
		default: return 136;
	}
}
static char * v_typeof_interface_veb__ControllerInterface(int sidx) {
	if (sidx == _veb__ControllerInterface_veb__Controller_index) return "veb.Controller";
	if (sidx == _veb__ControllerInterface_voidptr_index) return "voidptr";
	if (sidx == _veb__ControllerInterface_veb__RequestParams_index) return "veb.RequestParams";
	return "unknown veb.ControllerInterface";
}

int v_typeof_interface_idx_veb__ControllerInterface(int sidx) {
	if (sidx == _veb__ControllerInterface_veb__Controller_index) return 210;
	if (sidx == _veb__ControllerInterface_voidptr_index) return 2;
	if (sidx == _veb__ControllerInterface_veb__RequestParams_index) return 243;
	return 208;
}
static char * v_typeof_interface_veb__MiddlewareApp(int sidx) {
	if (sidx == _veb__MiddlewareApp_main__App_index) return "App";
	if (sidx == _veb__MiddlewareApp_voidptr_index) return "voidptr";
	if (sidx == _veb__MiddlewareApp_veb__Middleware_T_main__Context_index) return "veb.Middleware[Context]";
	return "unknown veb.MiddlewareApp";
}

int v_typeof_interface_idx_veb__MiddlewareApp(int sidx) {
	if (sidx == _veb__MiddlewareApp_main__App_index) return 112;
	if (sidx == _veb__MiddlewareApp_voidptr_index) return 2;
	if (sidx == _veb__MiddlewareApp_veb__Middleware_T_main__Context_index) return 109;
	return 217;
}
static char * v_typeof_interface_veb__HasBeforeRequest(int sidx) {
	return "unknown veb.HasBeforeRequest";
}

int v_typeof_interface_idx_veb__HasBeforeRequest(int sidx) {
	return 224;
}
static char * v_typeof_interface_veb__StaticApp(int sidx) {
	if (sidx == _veb__StaticApp_main__App_index) return "App";
	if (sidx == _veb__StaticApp_voidptr_index) return "voidptr";
	if (sidx == _veb__StaticApp_veb__StaticHandler_index) return "veb.StaticHandler";
	return "unknown veb.StaticApp";
}

int v_typeof_interface_idx_veb__StaticApp(int sidx) {
	if (sidx == _veb__StaticApp_main__App_index) return 112;
	if (sidx == _veb__StaticApp_voidptr_index) return 2;
	if (sidx == _veb__StaticApp_veb__StaticHandler_index) return 108;
	return 233;
}
static char * v_typeof_interface_veb__BeforeAcceptApp(int sidx) {
	return "unknown veb.BeforeAcceptApp";
}

int v_typeof_interface_idx_veb__BeforeAcceptApp(int sidx) {
	return 244;
}
static char * v_typeof_interface_orm__Connection(int sidx) {
	if (sidx == _orm__Connection_db__sqlite__DB_index) return "db.sqlite.DB";
	if (sidx == _orm__Connection_voidptr_index) return "voidptr";
	return "unknown orm.Connection";
}

int v_typeof_interface_idx_orm__Connection(int sidx) {
	if (sidx == _orm__Connection_db__sqlite__DB_index) return 111;
	if (sidx == _orm__Connection_voidptr_index) return 2;
	return 279;
}
static char * v_typeof_interface_net__http__Downloader(int sidx) {
	if (sidx == _net__http__Downloader_voidptr_index) return "voidptr";
	if (sidx == _net__http__Downloader_net__http__TerminalStreamingDownloader_index) return "net.http.TerminalStreamingDownloader";
	if (sidx == _net__http__Downloader_net__http__SilentStreamingDownloader_index) return "net.http.SilentStreamingDownloader";
	return "unknown net.http.Downloader";
}

int v_typeof_interface_idx_net__http__Downloader(int sidx) {
	if (sidx == _net__http__Downloader_voidptr_index) return 2;
	if (sidx == _net__http__Downloader_net__http__TerminalStreamingDownloader_index) return 304;
	if (sidx == _net__http__Downloader_net__http__SilentStreamingDownloader_index) return 306;
	return 302;
}
static char * v_typeof_interface_net__http__Handler(int sidx) {
	if (sidx == _net__http__Handler_net__http__DebugHandler_index) return "net.http.DebugHandler";
	if (sidx == _net__http__Handler_voidptr_index) return "voidptr";
	return "unknown net.http.Handler";
}

int v_typeof_interface_idx_net__http__Handler(int sidx) {
	if (sidx == _net__http__Handler_net__http__DebugHandler_index) return 334;
	if (sidx == _net__http__Handler_voidptr_index) return 2;
	return 333;
}
static char * v_typeof_interface_net__Connection(int sidx) {
	if (sidx == _net__Connection_net__TcpConn_index) return "net.TcpConn";
	if (sidx == _net__Connection_voidptr_index) return "voidptr";
	if (sidx == _net__Connection_net__ssl__SSLConn_index) return "net.ssl.SSLConn";
	if (sidx == _net__Connection_net__mbedtls__SSLConn_index) return "net.mbedtls.SSLConn";
	return "unknown net.Connection";
}

int v_typeof_interface_idx_net__Connection(int sidx) {
	if (sidx == _net__Connection_net__TcpConn_index) return 195;
	if (sidx == _net__Connection_voidptr_index) return 2;
	if (sidx == _net__Connection_net__ssl__SSLConn_index) return 297;
	if (sidx == _net__Connection_net__mbedtls__SSLConn_index) return 464;
	return 362;
}
static char * v_typeof_interface_net__Dialer(int sidx) {
	if (sidx == _net__Dialer_net__TCPDialer_index) return "net.TCPDialer";
	if (sidx == _net__Dialer_voidptr_index) return "voidptr";
	if (sidx == _net__Dialer_net__ssl__SSLDialer_index) return "net.ssl.SSLDialer";
	if (sidx == _net__Dialer_net__socks__SOCKS5Dialer_index) return "net.socks.SOCKS5Dialer";
	return "unknown net.Dialer";
}

int v_typeof_interface_idx_net__Dialer(int sidx) {
	if (sidx == _net__Dialer_net__TCPDialer_index) return 366;
	if (sidx == _net__Dialer_voidptr_index) return 2;
	if (sidx == _net__Dialer_net__ssl__SSLDialer_index) return 463;
	if (sidx == _net__Dialer_net__socks__SOCKS5Dialer_index) return 494;
	return 363;
}
static char * v_typeof_interface_io__Reader(int sidx) {
	if (sidx == _io__Reader_net__TcpConn_index) return "net.TcpConn";
	if (sidx == _io__Reader_voidptr_index) return "voidptr";
	if (sidx == _io__Reader_os__File_index) return "os.File";
	if (sidx == _io__Reader_net__ssl__SSLConn_index) return "net.ssl.SSLConn";
	if (sidx == _io__Reader_io__BufferedReader_index) return "io.BufferedReader";
	if (sidx == _io__Reader_io__ReaderWriterImpl_index) return "io.ReaderWriterImpl";
	if (sidx == _io__Reader_net__mbedtls__SSLConn_index) return "net.mbedtls.SSLConn";
	return "unknown io.Reader";
}

int v_typeof_interface_idx_io__Reader(int sidx) {
	if (sidx == _io__Reader_net__TcpConn_index) return 195;
	if (sidx == _io__Reader_voidptr_index) return 2;
	if (sidx == _io__Reader_os__File_index) return 237;
	if (sidx == _io__Reader_net__ssl__SSLConn_index) return 297;
	if (sidx == _io__Reader_io__BufferedReader_index) return 325;
	if (sidx == _io__Reader_io__ReaderWriterImpl_index) return 444;
	if (sidx == _io__Reader_net__mbedtls__SSLConn_index) return 464;
	return 431;
}
static char * v_typeof_interface_io__Writer(int sidx) {
	if (sidx == _io__Writer_io__MultiWriter_index) return "io.MultiWriter";
	if (sidx == _io__Writer_voidptr_index) return "voidptr";
	if (sidx == _io__Writer_net__TcpConn_index) return "net.TcpConn";
	if (sidx == _io__Writer_os__File_index) return "os.File";
	if (sidx == _io__Writer_net__ssl__SSLConn_index) return "net.ssl.SSLConn";
	if (sidx == _io__Writer_net__UdpConn_index) return "net.UdpConn";
	if (sidx == _io__Writer_io__BufferedWriter_index) return "io.BufferedWriter";
	if (sidx == _io__Writer_io__ReaderWriterImpl_index) return "io.ReaderWriterImpl";
	if (sidx == _io__Writer_net__mbedtls__SSLConn_index) return "net.mbedtls.SSLConn";
	if (sidx == _io__Writer_crypto__sha256__Digest_index) return "crypto.sha256.Digest";
	return "unknown io.Writer";
}

int v_typeof_interface_idx_io__Writer(int sidx) {
	if (sidx == _io__Writer_io__MultiWriter_index) return 440;
	if (sidx == _io__Writer_voidptr_index) return 2;
	if (sidx == _io__Writer_net__TcpConn_index) return 195;
	if (sidx == _io__Writer_os__File_index) return 237;
	if (sidx == _io__Writer_net__ssl__SSLConn_index) return 297;
	if (sidx == _io__Writer_net__UdpConn_index) return 371;
	if (sidx == _io__Writer_io__BufferedWriter_index) return 436;
	if (sidx == _io__Writer_io__ReaderWriterImpl_index) return 444;
	if (sidx == _io__Writer_net__mbedtls__SSLConn_index) return 464;
	if (sidx == _io__Writer_crypto__sha256__Digest_index) return 539;
	return 435;
}
static char * v_typeof_interface_io__RandomReader(int sidx) {
	if (sidx == _io__RandomReader_os__File_index) return "os.File";
	if (sidx == _io__RandomReader_voidptr_index) return "voidptr";
	return "unknown io.RandomReader";
}

int v_typeof_interface_idx_io__RandomReader(int sidx) {
	if (sidx == _io__RandomReader_os__File_index) return 237;
	if (sidx == _io__RandomReader_voidptr_index) return 2;
	return 442;
}
static char * v_typeof_interface_io__ReaderWriter(int sidx) {
	if (sidx == _io__ReaderWriter_io__ReaderWriterImpl_index) return "io.ReaderWriterImpl";
	if (sidx == _io__ReaderWriter_voidptr_index) return "voidptr";
	return "unknown io.ReaderWriter";
}

int v_typeof_interface_idx_io__ReaderWriter(int sidx) {
	if (sidx == _io__ReaderWriter_io__ReaderWriterImpl_index) return 444;
	if (sidx == _io__ReaderWriter_voidptr_index) return 2;
	return 443;
}
static char * v_typeof_interface_io__RandomWriter(int sidx) {
	return "unknown io.RandomWriter";
}

int v_typeof_interface_idx_io__RandomWriter(int sidx) {
	return 445;
}
static char * v_typeof_interface_rand__PRNG(int sidx) {
	if (sidx == _rand__PRNG_rand__wyrand__WyRandRNG_index) return "rand.wyrand.WyRandRNG";
	if (sidx == _rand__PRNG_voidptr_index) return "voidptr";
	return "unknown rand.PRNG";
}

int v_typeof_interface_idx_rand__PRNG(int sidx) {
	if (sidx == _rand__PRNG_rand__wyrand__WyRandRNG_index) return 501;
	if (sidx == _rand__PRNG_voidptr_index) return 2;
	return 495;
}
static char * v_typeof_interface_hash__Hash(int sidx) {
	if (sidx == _hash__Hash_crypto__sha256__Digest_index) return "crypto.sha256.Digest";
	if (sidx == _hash__Hash_voidptr_index) return "voidptr";
	return "unknown hash.Hash";
}

int v_typeof_interface_idx_hash__Hash(int sidx) {
	if (sidx == _hash__Hash_crypto__sha256__Digest_index) return 539;
	if (sidx == _hash__Hash_voidptr_index) return 2;
	return 561;
}
static char * v_typeof_interface_hash__Hash32er(int sidx) {
	return "unknown hash.Hash32er";
}

int v_typeof_interface_idx_hash__Hash32er(int sidx) {
	return 562;
}
static char * v_typeof_interface_hash__Hash64er(int sidx) {
	return "unknown hash.Hash64er";
}

int v_typeof_interface_idx_hash__Hash64er(int sidx) {
	return 563;
}
// << typeof() support for sum types

strings__Builder strings__new_builder(int initial_size) {
	strings__Builder res = ((__new_array_with_default_noscan(0, initial_size, sizeof(u8), 0)));
	ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	return res;
}
Array_u8 strings__Builder_reuse_as_plain_u8_array(strings__Builder* b) {
	ArrayFlags_clear(&b->flags, ArrayFlags__noslices);
	return *b;
}
void strings__Builder_write_ptr(strings__Builder* b, u8* ptr, int len) {
	if (len == 0) {
		return;
	}
	array_push_many(b, ptr, len);
}
void strings__Builder_write_rune(strings__Builder* b, rune r) {
	Array_fixed_u8_5 buffer = {0};
	string res = utf32_to_str_no_malloc(((u32)(r)), &buffer[0]);
	if (res.len == 0) {
		return;
	}
	array_push_many(b, res.str, res.len);
}
void strings__Builder_write_runes(strings__Builder* b, Array_rune runes) {
	Array_fixed_u8_5 buffer = {0};
	for (int _t1 = 0; _t1 < runes.len; ++_t1) {
		rune r = ((rune*)runes.data)[_t1];
		string res = utf32_to_str_no_malloc(((u32)(r)), &buffer[0]);
		if (res.len == 0) {
			continue;
		}
		array_push_many(b, res.str, res.len);
	}
}
inline void strings__Builder_write_u8(strings__Builder* b, u8 data) {
	array_push_noscan((array*)b, _MOV((u8[]){ data }));
}
inline void strings__Builder_write_byte(strings__Builder* b, u8 data) {
	array_push_noscan((array*)b, _MOV((u8[]){ data }));
}
void strings__Builder_write_decimal(strings__Builder* b, i64 n) {
	if (n == 0) {
		strings__Builder_write_u8(b, 0x30);
		return;
	}
	Array_fixed_u8_25 buf = {0};
	i64 x = (n < 0 ? (-n) : (n));
	int i = 24;
	for (;;) {
		if (!(x != 0)) break;
		i64 nextx = (i64)(x / 10);
		i64 r = (i64)(x % 10);
		buf[i] = (u8)(((u8)(r)) + 0x30);
		x = nextx;
		i--;
	}
	if (n < 0) {
		buf[i] = '-';
		i--;
	}
	strings__Builder_write_ptr(b, &buf[(int)(i + 1)], (int)(24 - i));
}
_result_int strings__Builder_write(strings__Builder* b, Array_u8 data) {
	if (data.len == 0) {
		_result_int _t1 = {0};
		_result_ok(&(int[]) { 0 }, (_result*)(&_t1), sizeof(int));
		return _t1;
	}
	_PUSH_MANY_noscan(b, (data), _t2, strings__Builder);
	_result_int _t3 = {0};
	_result_ok(&(int[]) { data.len }, (_result*)(&_t3), sizeof(int));
	return _t3;
}
void strings__Builder_drain_builder(strings__Builder* b, strings__Builder* other, int other_new_cap) {
	if (other->len > 0) {
		_PUSH_MANY_noscan(b, (*other), _t1, strings__Builder);
	}
	strings__Builder_free(other);
	*other = strings__new_builder(other_new_cap);
}
inline u8 strings__Builder_byte_at(strings__Builder* b, int n) {
	return (*(u8*)array_get(*(((Array_u8*)(b))), n));
}
inline void strings__Builder_write_string(strings__Builder* b, string s) {
	if (s.len == 0) {
		return;
	}
	array_push_many(b, s.str, s.len);
}
inline void strings__Builder_write_string2(strings__Builder* b, string s1, string s2) {
	if (s1.len != 0) {
		array_push_many(b, s1.str, s1.len);
	}
	if (s2.len != 0) {
		array_push_many(b, s2.str, s2.len);
	}
}
void strings__Builder_go_back(strings__Builder* b, int n) {
	array_trim(b, (int)(b->len - n));
}
inline string strings__Builder_spart(strings__Builder* b, int start_pos, int n) {
	{ // Unsafe block
		u8* x = malloc_noscan((int)(n + 1));
		vmemcpy(x, ((u8*)(b->data)) + start_pos, n);
		x[n] = 0;
		return tos(x, n);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strings__Builder_cut_last(strings__Builder* b, int n) {
	int cut_pos = (int)(b->len - n);
	string res = strings__Builder_spart(b, cut_pos, n);
	array_trim(b, cut_pos);
	return res;
}
string strings__Builder_cut_to(strings__Builder* b, int pos) {
	if (pos > b->len) {
		return _SLIT("");
	}
	return strings__Builder_cut_last(b, (int)(b->len - pos));
}
void strings__Builder_go_back_to(strings__Builder* b, int pos) {
	array_trim(b, pos);
}
inline void strings__Builder_writeln(strings__Builder* b, string s) {
	if ((s).len != 0) {
		array_push_many(b, s.str, s.len);
	}
	array_push_noscan((array*)b, _MOV((u8[]){ ((u8)('\n')) }));
}
inline void strings__Builder_writeln2(strings__Builder* b, string s1, string s2) {
	if ((s1).len != 0) {
		array_push_many(b, s1.str, s1.len);
	}
	array_push_noscan((array*)b, _MOV((u8[]){ ((u8)('\n')) }));
	if ((s2).len != 0) {
		array_push_many(b, s2.str, s2.len);
	}
	array_push_noscan((array*)b, _MOV((u8[]){ ((u8)('\n')) }));
}
string strings__Builder_last_n(strings__Builder* b, int n) {
	if (n > b->len) {
		return _SLIT("");
	}
	return strings__Builder_spart(b, (int)(b->len - n), n);
}
string strings__Builder_after(strings__Builder* b, int n) {
	if (n >= b->len) {
		return _SLIT("");
	}
	return strings__Builder_spart(b, n, (int)(b->len - n));
}
string strings__Builder_str(strings__Builder* b) {
	array_push_noscan((array*)b, _MOV((u8[]){ ((u8)(0)) }));
	u8* bcopy = ((u8*)(memdup_noscan(b->data, b->len)));
	string s = u8_vstring_with_len(bcopy, (int)(b->len - 1));
	array_clear(b);
	return s;
}
void strings__Builder_ensure_cap(strings__Builder* b, int n) {
	if (n <= b->cap) {
		return;
	}
	u8* new_data = vcalloc((int)(n * b->element_size));
	if (b->data != ((void*)0)) {
		vmemcpy(new_data, b->data, (int)(b->len * b->element_size));
		if (ArrayFlags_has(&b->flags, ArrayFlags__noslices)) {
			_v_free(b->data);
		}
	}
	{ // Unsafe block
		b->data = new_data;
		b->offset = 0;
		b->cap = n;
	}
}
void strings__Builder_grow_len(strings__Builder* b, int n) {
	if (n <= 0) {
		return;
	}
	int new_len = (int)(b->len + n);
	strings__Builder_ensure_cap(b, new_len);
	{ // Unsafe block
		b->len = new_len;
	}
}
void strings__Builder_free(strings__Builder* b) {
	if (b->data != 0) {
		_v_free(b->data);
		{ // Unsafe block
			b->data = ((void*)0);
		}
	}
}
int math__bits__trailing_zeros_32(u32 x) {
	if (x == 0U) {
		return 32;
	}
	return ((int)(_const_math__bits__de_bruijn32tab[((u32)(((x & -x)) * _const_math__bits__de_bruijn32) >> (27))]));
}
int math__bits__trailing_zeros_64(u64 x) {
	if (x == 0U) {
		return 64;
	}
	return ((int)(_const_math__bits__de_bruijn64tab[((u64)(((x & -x)) * _const_math__bits__de_bruijn64) >> (58))]));
}
inline u32 math__bits__rotate_left_32(u32 x, int k) {
	u32 s = (((u32)(k)) & ((u32)(_const_math__bits__n32 - ((u32)(1U)))));
	return (((x << s)) | ((x >> ((u32)(_const_math__bits__n32 - s)))));
}
int math__bits__len_32(u32 x) {
	u32 y = x;
	int n = 0;
	if (y >= (65536)) {
		y >>= 16U;
		n = 16;
	}
	if (y >= (256)) {
		y >>= 8U;
		n += 8;
	}
	return (int)(n + ((int)(_const_math__bits__len_8_tab[y])));
}
multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y) {
	u64 x0 = (x & _const_math__bits__mask32);
	u64 x1 = (x >> 32U);
	u64 y0 = (y & _const_math__bits__mask32);
	u64 y1 = (y >> 32U);
	u64 w0 = (u64)(x0 * y0);
	u64 t = (u64)((u64)(x1 * y0) + ((w0 >> 32U)));
	u64 w1 = (t & _const_math__bits__mask32);
	u64 w2 = (t >> 32U);
	w1 += (u64)(x0 * y1);
	u64 hi = (u64)((u64)((u64)(x1 * y1) + w2) + ((w1 >> 32U)));
	u64 lo = (u64)(x * y);
	return (multi_return_u64_u64){.arg0=hi, .arg1=lo};
}
_result_u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	multi_return_u64_int mr_730 = strconv__common_parse_uint2(s, _base, _bit_size);
	u64 result = mr_730.arg0;
	int err = mr_730.arg1;
	if (err != 0 && (error_on_non_digit || error_on_high_digit)) {
		switch (err) {
			case -1: {
					return (_result_u64){ .is_error=true, .err=_v_error(str_intp(3, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: wrong base "), 0xfe07, {.d_i32 = _base}}, {_SLIT(" for "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			case -2: {
					return (_result_u64){ .is_error=true, .err=_v_error(str_intp(3, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: wrong bit size "), 0xfe07, {.d_i32 = _bit_size}}, {_SLIT(" for "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			case -3: {
					return (_result_u64){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: integer overflow "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			default: {
					return (_result_u64){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: syntax error "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		
	}
	_result_u64 _t5 = {0};
	_result_ok(&(u64[]) { result }, (_result*)(&_t5), sizeof(u64));
	return _t5;
}
multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size) {
	if ((s).len == 0) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=1};
	}
	int bit_size = _bit_size;
	int base = _base;
	int start_index = 0;
	if (base == 0) {
		base = 10;
		if (s.str[ 0] == '0') {
			u8 ch = (s.str[ 1] | 32);
			if (s.len >= 3) {
				if (ch == 'b') {
					base = 2;
					start_index += 2;
				} else if (ch == 'o') {
					base = 8;
					start_index += 2;
				} else if (ch == 'x') {
					base = 16;
					start_index += 2;
				}
				if (s.str[ start_index] == '_') {
					start_index++;
				}
			} else if (s.len >= 2 && (s.str[ 1] >= '0' && s.str[ 1] <= '9')) {
				base = 10;
				start_index++;
			} else {
				base = 8;
				start_index++;
			}
		}
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	} else if (bit_size < 0 || bit_size > 64) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=-2};
	}
	u64 cutoff = (u64)((u64)(_const_max_u64 / ((u64)(base))) + ((u64)(1U)));
	u64 max_val = (bit_size == 64 ? (_const_max_u64) : ((u64)(((((u64)(1U)) << ((u64)(bit_size)))) - ((u64)(1U)))));
	int basem1 = (int)(base - 1);
	u64 n = ((u64)(0U));
	for (int i = start_index; i < s.len; ++i) {
		u8 c = s.str[ i];
		if (c == '_') {
			if (i == start_index || i >= ((int)(s.len - 1))) {
				return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=1};
			}
			if (s.str[ (int)(i - 1)] == '_' || s.str[ (int)(i + 1)] == '_') {
				return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=1};
			}
			continue;
		}
		int sub_count = 0;
		c -= 48;
		if (c >= 17) {
			sub_count++;
			c -= 7;
			if (c >= 42) {
				sub_count++;
				c -= 32;
			}
		}
		if (c > basem1 || (sub_count == 0 && c > 9)) {
			return (multi_return_u64_int){.arg0=n, .arg1=(int)(i + 1)};
		}
		if (n >= cutoff) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n *= ((u64)(base));
		u64 n1 = (u64)(n + ((u64)(c)));
		if (n1 < n || n1 > max_val) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n = n1;
	}
	return (multi_return_u64_int){.arg0=n, .arg1=0};
}
_result_i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	if ((_s).len == 0) {
		_result_i64 _t1 = {0};
		_result_ok(&(i64[]) { ((i64)(0)) }, (_result*)(&_t1), sizeof(i64));
		return _t1;
	}
	int bit_size = _bit_size;
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	}
	string s = _s;
	bool neg = false;
	if (s.str[ 0] == '+') {
		{ // Unsafe block
			s = tos(s.str + 1, (int)(s.len - 1));
		}
	} else if (s.str[ 0] == '-') {
		neg = true;
		{ // Unsafe block
			s = tos(s.str + 1, (int)(s.len - 1));
		}
	}
	_result_u64 _t2 = strconv__common_parse_uint(s, base, bit_size, error_on_non_digit, error_on_high_digit);
	if (_t2.is_error) {
		_result_i64 _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	u64 un = (*(u64*)_t2.data);
	if (un == 0U) {
		_result_i64 _t4 = {0};
		_result_ok(&(i64[]) { ((i64)(0)) }, (_result*)(&_t4), sizeof(i64));
		return _t4;
	}
	u64 cutoff = (((u64)(1U)) << ((u64)((int)(bit_size - 1))));
	if (!neg && un >= cutoff) {
		_result_i64 _t5 = {0};
		_result_ok(&(i64[]) { ((i64)((u64)(cutoff - ((u64)(1U))))) }, (_result*)(&_t5), sizeof(i64));
		return _t5;
	}
	if (neg && un > cutoff) {
		_result_i64 _t6 = {0};
		_result_ok(&(i64[]) { -((i64)(cutoff)) }, (_result*)(&_t6), sizeof(i64));
		return _t6;
	}
	_result_i64 _t8; /* if prepend */
	if (neg) {
		_result_ok(&(i64[]) { -((i64)(un)) }, (_result*)(&_t8), sizeof(i64));
	} else {
		_result_ok(&(i64[]) { ((i64)(un)) }, (_result*)(&_t8), sizeof(i64));
	}
	return _t8;
}
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = (int)(i_n_digit + 1);
	int pad_digit = (int)(i_pad_digit + 1);
	u32 out = d.m;
	int out_len = strconv__dec_digits(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = (int)(pad_digit - out_len);
	}
	Array_u8 buf = __new_array_with_default_noscan(((int)((int)((int)((int)(out_len + 5) + 1) + 1))), 0, sizeof(u8), 0);
	int i = 0;
	if (neg) {
		if (buf.data != 0) {
			((u8*)buf.data)[i] = '-';
		}
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (u32)(_const_strconv__ten_pow_table_32[(int)((int)(out_len - n_digit) - 1)] * 5U);
		out /= _const_strconv__ten_pow_table_32[(int)(out_len - n_digit)];
		out_len = n_digit;
	}
	int y = (int)(i + out_len);
	int x = 0;
	for (;;) {
		if (!(x < ((int)((int)(out_len - disp) - 1)))) break;
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u32)(out % 10U))));
		out /= 10U;
		i++;
		x++;
	}
	if (i_n_digit == 0) {
		{ // Unsafe block
			((u8*)buf.data)[i] = 0;
			return tos(((u8*)(&((u8*)buf.data)[0])), i);
		}
	}
	if (out_len >= 1) {
		((u8*)buf.data)[(int)(y - x)] = '.';
		x++;
		i++;
	}
	if ((int)(y - x) >= 0) {
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u32)(out % 10U))));
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		((u8*)buf.data)[i] = '0';
		i++;
		fw_zeros--;
	}
	((u8*)buf.data)[i] = 'e';
	i++;
	int exp = (int)((int)(d.e + out_len_original) - 1);
	if (exp < 0) {
		((u8*)buf.data)[i] = '-';
		i++;
		exp = -exp;
	} else {
		((u8*)buf.data)[i] = '+';
		i++;
	}
	int d1 = (int)(exp % 10);
	int d0 = (int)(exp / 10);
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d0)));
	i++;
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d1)));
	i++;
	((u8*)buf.data)[i] = 0;
	return tos(((u8*)(&((u8*)buf.data)[0])), i);
}
VV_LOCAL_SYMBOL multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp) {
	strconv__Dec32 d = ((strconv__Dec32){.m = 0,.e = 0,});
	u32 e = (u32)(exp - 127U);
	if (e > _const_strconv__mantbits32) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	u32 shift = (u32)(_const_strconv__mantbits32 - e);
	u32 mant = (i_mant | 0x00800000U);
	d.m = (mant >> shift);
	if (((d.m << shift)) != mant) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!(((u32)(d.m % 10U)) == 0U)) break;
		d.m /= 10U;
		d.e++;
	}
	return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=true};
}
VV_LOCAL_SYMBOL strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp) {
	int e2 = 0;
	u32 m2 = ((u32)(0U));
	if (exp == 0U) {
		e2 = (int)((int)(-126 - ((int)(_const_strconv__mantbits32))) - 2);
		m2 = mant;
	} else {
		e2 = (int)((int)((int)(((int)(exp)) - 127) - ((int)(_const_strconv__mantbits32))) - 2);
		m2 = (((((u32)(1U)) << _const_strconv__mantbits32)) | mant);
	}
	bool even = ((m2 & 1U)) == 0U;
	bool accept_bounds = even;
	u32 mv = ((u32)((u32)(4 * m2)));
	u32 mp = ((u32)((u32)((u32)(4 * m2) + 2U)));
	u32 mm_shift = strconv__bool_to_u32(mant != 0U || exp <= 1U);
	u32 mm = ((u32)((u32)((u32)((u32)(4 * m2) - 1U) - mm_shift)));
	u32 vr = ((u32)(0U));
	u32 vp = ((u32)(0U));
	u32 vm = ((u32)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	u8 last_removed_digit = ((u8)(0));
	if (e2 >= 0) {
		u32 q = strconv__log10_pow2(e2);
		e10 = ((int)(q));
		int k = (int)((int)(59 + strconv__pow5_bits(((int)(q)))) - 1);
		int i = (int)((int)(-e2 + ((int)(q))) + k);
		vr = strconv__mul_pow5_invdiv_pow2(mv, q, i);
		vp = strconv__mul_pow5_invdiv_pow2(mp, q, i);
		vm = strconv__mul_pow5_invdiv_pow2(mm, q, i);
		if (q != 0U && (u32)(((u32)(vp - 1U)) / 10U) <= (u32)(vm / 10U)) {
			int l = (int)((int)(59 + strconv__pow5_bits(((int)((u32)(q - 1U))))) - 1);
			last_removed_digit = ((u8)((u32)(strconv__mul_pow5_invdiv_pow2(mv, (u32)(q - 1U), (int)((int)(-e2 + ((int)((u32)(q - 1U)))) + l)) % 10U)));
		}
		if (q <= 9U) {
			if ((u32)(mv % 5U) == 0U) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mm, q);
			} else if (strconv__multiple_of_power_of_five_32(mp, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__log10_pow5(-e2);
		e10 = (int)(((int)(q)) + e2);
		int i = (int)(-e2 - ((int)(q)));
		int k = (int)(strconv__pow5_bits(i) - 61);
		int j = (int)(((int)(q)) - k);
		vr = strconv__mul_pow5_div_pow2(mv, ((u32)(i)), j);
		vp = strconv__mul_pow5_div_pow2(mp, ((u32)(i)), j);
		vm = strconv__mul_pow5_div_pow2(mm, ((u32)(i)), j);
		if (q != 0U && ((u32)(((u32)(vp - 1U)) / 10U)) <= (u32)(vm / 10U)) {
			j = (int)((int)(((int)(q)) - 1) - ((int)(strconv__pow5_bits((int)(i + 1)) - 61)));
			last_removed_digit = ((u8)((u32)(strconv__mul_pow5_div_pow2(mv, ((u32)((int)(i + 1))), j) % 10U)));
		}
		if (q <= 1U) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = mm_shift == 1U;
			} else {
				vp--;
			}
		} else if (q < 31U) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_32(mv, (u32)(q - 1U));
		}
	}
	int removed = 0;
	u32 out = ((u32)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			if (!((u32)(vp / 10U) > (u32)(vm / 10U))) break;
			vm_is_trailing_zeros = vm_is_trailing_zeros && ((u32)(vm % 10U)) == 0U;
			vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
			last_removed_digit = ((u8)((u32)(vr % 10U)));
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				if (!((u32)(vm % 10U) == 0U)) break;
				vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
				last_removed_digit = ((u8)((u32)(vr % 10U)));
				vr /= 10U;
				vp /= 10U;
				vm /= 10U;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && last_removed_digit == 5 && ((u32)(vr % 2U)) == 0U) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		for (;;) {
			if (!((u32)(vp / 10U) > (u32)(vm / 10U))) break;
			last_removed_digit = ((u8)((u32)(vr % 10U)));
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		out = (u32)(vr + strconv__bool_to_u32(vr == vm || last_removed_digit >= 5));
	}
	return ((strconv__Dec32){.m = out,.e = (int)(e10 + removed),});
}
string strconv__f32_to_str(f32 f, int n_digit) {
	strconv__Uf32 u1 = ((strconv__Uf32){0});
	u1.f = f;
	u32 u = u1.u;
	bool neg = ((u >> ((u32)(_const_strconv__mantbits32 + _const_strconv__expbits32)))) != 0U;
	u32 mant = (u & ((u32)(((((u32)(1U)) << _const_strconv__mantbits32)) - ((u32)(1U)))));
	u32 exp = (((u >> _const_strconv__mantbits32)) & ((u32)(((((u32)(1U)) << _const_strconv__expbits32)) - ((u32)(1U)))));
	if (exp == 255U || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec32_bool mr_8566 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_8566.arg0;
	bool ok = mr_8566.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, 0);
}
VV_LOCAL_SYMBOL string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = (i_n_digit < 1 ? (1) : ((int)(i_n_digit + 1)));
	int pad_digit = (int)(i_pad_digit + 1);
	u64 out = d.m;
	int d_exp = d.e;
	int out_len = strconv__dec_digits(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = (int)(pad_digit - out_len);
	}
	Array_u8 buf = __new_array_with_default_noscan(((int)((int)((int)((int)(out_len + 6) + 1) + 1) + fw_zeros)), 0, sizeof(u8), 0);
	int i = 0;
	if (neg) {
		((u8*)buf.data)[i] = '-';
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (u64)(_const_strconv__ten_pow_table_64[(int)((int)(out_len - n_digit) - 1)] * 5U);
		out /= _const_strconv__ten_pow_table_64[(int)(out_len - n_digit)];
		u64 out_div = (u64)(d.m / _const_strconv__ten_pow_table_64[(int)(out_len - n_digit)]);
		if (out_div < out && strconv__dec_digits(out_div) < strconv__dec_digits(out)) {
			d_exp++;
			n_digit++;
		}
		out_len = n_digit;
	}
	int y = (int)(i + out_len);
	int x = 0;
	for (;;) {
		if (!(x < ((int)((int)(out_len - disp) - 1)))) break;
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u64)(out % 10U))));
		out /= 10U;
		i++;
		x++;
	}
	if (out_len >= 1) {
		((u8*)buf.data)[(int)(y - x)] = '.';
		x++;
		i++;
	}
	if ((int)(y - x) >= 0) {
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u64)(out % 10U))));
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		((u8*)buf.data)[i] = '0';
		i++;
		fw_zeros--;
	}
	((u8*)buf.data)[i] = 'e';
	i++;
	int exp = (int)((int)(d_exp + out_len_original) - 1);
	if (exp < 0) {
		((u8*)buf.data)[i] = '-';
		i++;
		exp = -exp;
	} else {
		((u8*)buf.data)[i] = '+';
		i++;
	}
	int d2 = (int)(exp % 10);
	exp /= 10;
	int d1 = (int)(exp % 10);
	int d0 = (int)(exp / 10);
	if (d0 > 0) {
		((u8*)buf.data)[i] = (rune)('0' + ((u8)(d0)));
		i++;
	}
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d1)));
	i++;
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d2)));
	i++;
	((u8*)buf.data)[i] = 0;
	return tos(((u8*)(&((u8*)buf.data)[0])), i);
}
VV_LOCAL_SYMBOL multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp) {
	strconv__Dec64 d = ((strconv__Dec64){.m = 0,.e = 0,});
	u64 e = (u64)(exp - 1023U);
	if (e > _const_strconv__mantbits64) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	u64 shift = (u64)(_const_strconv__mantbits64 - e);
	u64 mant = (i_mant | ((u64)(0x0010000000000000U)));
	d.m = (mant >> shift);
	if (((d.m << shift)) != mant) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!(((u64)(d.m % 10U)) == 0U)) break;
		d.m /= 10U;
		d.e++;
	}
	return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=true};
}
VV_LOCAL_SYMBOL strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp) {
	int e2 = 0;
	u64 m2 = ((u64)(0U));
	if (exp == 0U) {
		e2 = (int)((int)(-1022 - ((int)(_const_strconv__mantbits64))) - 2);
		m2 = mant;
	} else {
		e2 = (int)((int)((int)(((int)(exp)) - 1023) - ((int)(_const_strconv__mantbits64))) - 2);
		m2 = (((((u64)(1U)) << _const_strconv__mantbits64)) | mant);
	}
	bool even = ((m2 & 1U)) == 0U;
	bool accept_bounds = even;
	u64 mv = ((u64)((u64)(4 * m2)));
	u64 mm_shift = strconv__bool_to_u64(mant != 0U || exp <= 1U);
	u64 vr = ((u64)(0U));
	u64 vp = ((u64)(0U));
	u64 vm = ((u64)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	if (e2 >= 0) {
		u32 q = (u32)(strconv__log10_pow2(e2) - strconv__bool_to_u32(e2 > 3));
		e10 = ((int)(q));
		int k = (int)((int)(122 + strconv__pow5_bits(((int)(q)))) - 1);
		int i = (int)((int)(-e2 + ((int)(q))) + k);
		strconv__Uint128 mul = *(((strconv__Uint128*)(&_const_strconv__pow5_inv_split_64_x[v_fixed_index((u32)(q * 2U), 584)])));
		vr = strconv__mul_shift_64((u64)(((u64)(4U)) * m2), mul, i);
		vp = strconv__mul_shift_64((u64)((u64)(((u64)(4U)) * m2) + ((u64)(2U))), mul, i);
		vm = strconv__mul_shift_64((u64)((u64)((u64)(((u64)(4U)) * m2) - ((u64)(1U))) - mm_shift), mul, i);
		if (q <= 21U) {
			if ((u64)(mv % 5U) == 0U) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_64(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_64((u64)((u64)(mv - 1U) - mm_shift), q);
			} else if (strconv__multiple_of_power_of_five_64((u64)(mv + 2U), q)) {
				vp--;
			}
		}
	} else {
		u32 q = (u32)(strconv__log10_pow5(-e2) - strconv__bool_to_u32(-e2 > 1));
		e10 = (int)(((int)(q)) + e2);
		int i = (int)(-e2 - ((int)(q)));
		int k = (int)(strconv__pow5_bits(i) - 121);
		int j = (int)(((int)(q)) - k);
		strconv__Uint128 mul = *(((strconv__Uint128*)(&_const_strconv__pow5_split_64_x[v_fixed_index((int)(i * 2), 652)])));
		vr = strconv__mul_shift_64((u64)(((u64)(4U)) * m2), mul, j);
		vp = strconv__mul_shift_64((u64)((u64)(((u64)(4U)) * m2) + ((u64)(2U))), mul, j);
		vm = strconv__mul_shift_64((u64)((u64)((u64)(((u64)(4U)) * m2) - ((u64)(1U))) - mm_shift), mul, j);
		if (q <= 1U) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = (mm_shift == 1U);
			} else {
				vp--;
			}
		} else if (q < 63U) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_64(mv, (u32)(q - 1U));
		}
	}
	int removed = 0;
	u8 last_removed_digit = ((u8)(0));
	u64 out = ((u64)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			u64 vp_div_10 = (u64)(vp / 10U);
			u64 vm_div_10 = (u64)(vm / 10U);
			if (vp_div_10 <= vm_div_10) {
				break;
			}
			u64 vm_mod_10 = (u64)(vm % 10U);
			u64 vr_div_10 = (u64)(vr / 10U);
			u64 vr_mod_10 = (u64)(vr % 10U);
			vm_is_trailing_zeros = vm_is_trailing_zeros && vm_mod_10 == 0U;
			vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
			last_removed_digit = ((u8)(vr_mod_10));
			vr = vr_div_10;
			vp = vp_div_10;
			vm = vm_div_10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				u64 vm_div_10 = (u64)(vm / 10U);
				u64 vm_mod_10 = (u64)(vm % 10U);
				if (vm_mod_10 != 0U) {
					break;
				}
				u64 vp_div_10 = (u64)(vp / 10U);
				u64 vr_div_10 = (u64)(vr / 10U);
				u64 vr_mod_10 = (u64)(vr % 10U);
				vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
				last_removed_digit = ((u8)(vr_mod_10));
				vr = vr_div_10;
				vp = vp_div_10;
				vm = vm_div_10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && last_removed_digit == 5 && ((u64)(vr % 2U)) == 0U) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		bool round_up = false;
		for (;;) {
			if (!((u64)(vp / 100U) > (u64)(vm / 100U))) break;
			round_up = ((u64)(vr % 100U)) >= 50U;
			vr /= 100U;
			vp /= 100U;
			vm /= 100U;
			removed += 2;
		}
		for (;;) {
			if (!((u64)(vp / 10U) > (u64)(vm / 10U))) break;
			round_up = ((u64)(vr % 10U)) >= 5U;
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		out = (u64)(vr + strconv__bool_to_u64(vr == vm || round_up));
	}
	return ((strconv__Dec64){.m = out,.e = (int)(e10 + removed),});
}
string strconv__f64_to_str(f64 f, int n_digit) {
	strconv__Uf64 u1 = ((strconv__Uf64){0});
	u1.f = f;
	u64 u = u1.u;
	bool neg = ((u >> ((u32)(_const_strconv__mantbits64 + _const_strconv__expbits64)))) != 0U;
	u64 mant = (u & ((u64)(((((u64)(1U)) << _const_strconv__mantbits64)) - ((u64)(1U)))));
	u64 exp = (((u >> _const_strconv__mantbits64)) & ((u64)(((((u64)(1U)) << _const_strconv__expbits64)) - ((u64)(1U)))));
	if (exp == 2047U || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec64_bool mr_9551 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_9551.arg0;
	bool ok = mr_9551.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, 0);
}
string strconv__f64_to_str_pad(f64 f, int n_digit) {
	strconv__Uf64 u1 = ((strconv__Uf64){0});
	u1.f = f;
	u64 u = u1.u;
	bool neg = ((u >> ((u32)(_const_strconv__mantbits64 + _const_strconv__expbits64)))) != 0U;
	u64 mant = (u & ((u64)(((((u64)(1U)) << _const_strconv__mantbits64)) - ((u64)(1U)))));
	u64 exp = (((u >> _const_strconv__mantbits64)) & ((u64)(((((u64)(1U)) << _const_strconv__expbits64)) - ((u64)(1U)))));
	if (exp == 2047U || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec64_bool mr_10332 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_10332.arg0;
	bool ok = mr_10332.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, n_digit);
}
void strconv__format_str_sb(string s, strconv__BF_param p, strings__Builder* sb) {
	if (p.len0 <= 0) {
		strings__Builder_write_string(sb, s);
		return;
	}
	int dif = (int)(p.len0 - utf8_str_visible_length(s));
	if (dif <= 0) {
		strings__Builder_write_string(sb, s);
		return;
	}
	if (p.align == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(sb, p.pad_ch);
		}
	}
	strings__Builder_write_string(sb, s);
	if (p.align == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(sb, p.pad_ch);
		}
	}
}
void strconv__format_dec_sb(u64 d, strconv__BF_param p, strings__Builder* res) {
	int n_char = strconv__dec_digits(d);
	int sign_len = (!p.positive || p.sign_flag ? (1) : (0));
	int number_len = (int)(sign_len + n_char);
	int dif = (int)(p.len0 - number_len);
	bool sign_written = false;
	if (p.align == strconv__Align_text__right) {
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_u8(res, '+');
					sign_written = true;
				}
			} else {
				strings__Builder_write_u8(res, '-');
				sign_written = true;
			}
		}
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(res, p.pad_ch);
		}
	}
	if (!sign_written) {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_u8(res, '+');
			}
		} else {
			strings__Builder_write_u8(res, '-');
		}
	}
	Array_fixed_u8_32 buf = {0};
	int i = 20;
	u64 n = d;
	u64 d_i = ((u64)(0U));
	if (n > 0U) {
		for (;;) {
			if (!(n > 0U)) break;
			u64 n1 = (u64)(n / 100U);
			d_i = (((u64)(n - ((u64)(n1 * 100U)))) << 1U);
			n = n1;
			{ // Unsafe block
				buf[i] = _const_strconv__digit_pairs.str[d_i];
			}
			i--;
			d_i++;
			{ // Unsafe block
				buf[i] = _const_strconv__digit_pairs.str[d_i];
			}
			i--;
		}
		i++;
		if (d_i < 20U) {
			i++;
		}
		strings__Builder_write_ptr(res, &buf[i], n_char);
	} else {
		strings__Builder_write_u8(res, '0');
	}
	if (p.align == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(res, p.pad_ch);
		}
	}
	return;
}
string strconv__f64_to_str_lnd1(f64 f, int dec_digit) {
	{ // Unsafe block
		string s = strconv__f64_to_str((f64)(f + _const_strconv__dec_round[dec_digit]), 18);
		if (s.len > 2 && (s.str[ 0] == 'n' || s.str[ 1] == 'i')) {
			return s;
		}
		bool m_sgn_flag = false;
		int sgn = 1;
		Array_fixed_u8_26 b = {0};
		int d_pos = 1;
		int i = 0;
		int i1 = 0;
		int exp = 0;
		int exp_sgn = 1;
		int dot_res_sp = -1;
		for (int _t2 = 0; _t2 < s.len; ++_t2) {
			u8 c = s.str[_t2];

			if (c == ('-')) {
				sgn = -1;
				i++;
			}
			else if (c == ('+')) {
				sgn = 1;
				i++;
			}
			else if ((c >= '0' && c <= '9')) {
				b[i1] = c;
				i1++;
				i++;
			}
			else if (c == ('.')) {
				if (sgn > 0) {
					d_pos = i;
				} else {
					d_pos = (int)(i - 1);
				}
				i++;
			}
			else if (c == ('e')) {
				i++;
				break;
			}
			else {
				string_free(&s);
				return _SLIT("[Float conversion error!!]");
			}
		}
		b[i1] = 0;
		if (s.str[ i] == '-') {
			exp_sgn = -1;
			i++;
		} else if (s.str[ i] == '+') {
			exp_sgn = 1;
			i++;
		}
		int c = i;
		for (;;) {
			if (!(c < s.len)) break;
			exp = (int)((int)(exp * 10) + ((int)((rune)(s.str[ c] - '0'))));
			c++;
		}
		Array_u8 res = __new_array_with_default_noscan((int)(exp + 40), 0, sizeof(u8), &(u8[]){0});
		int r_i = 0;
		string_free(&s);
		if (sgn == 1) {
			if (m_sgn_flag) {
				((u8*)res.data)[r_i] = '+';
				r_i++;
			}
		} else {
			((u8*)res.data)[r_i] = '-';
			r_i++;
		}
		i = 0;
		if (exp_sgn >= 0) {
			for (;;) {
				if (!(b[i] != 0)) break;
				((u8*)res.data)[r_i] = b[i];
				r_i++;
				i++;
				if (i >= d_pos && exp >= 0) {
					if (exp == 0) {
						dot_res_sp = r_i;
						((u8*)res.data)[r_i] = '.';
						r_i++;
					}
					exp--;
				}
			}
			for (;;) {
				if (!(exp >= 0)) break;
				((u8*)res.data)[r_i] = '0';
				r_i++;
				exp--;
			}
		} else {
			bool dot_p = true;
			for (;;) {
				if (!(exp > 0)) break;
				((u8*)res.data)[r_i] = '0';
				r_i++;
				exp--;
				if (dot_p) {
					dot_res_sp = r_i;
					((u8*)res.data)[r_i] = '.';
					r_i++;
					dot_p = false;
				}
			}
			for (;;) {
				if (!(b[i] != 0)) break;
				((u8*)res.data)[r_i] = b[i];
				r_i++;
				i++;
			}
		}
		if (dec_digit <= 0) {
			if (dot_res_sp < 0) {
				dot_res_sp = (int)(i + 1);
			}
			string tmp_res = string_clone(tos(res.data, dot_res_sp));
			array_free(&res);
			return tmp_res;
		}
		if (dot_res_sp >= 0) {
			r_i = (int)((int)(dot_res_sp + dec_digit) + 1);
			((u8*)res.data)[r_i] = 0;
			for (int c1 = 1; c1 < (int)(dec_digit + 1); ++c1) {
				if (((u8*)res.data)[(int)(r_i - c1)] == 0) {
					((u8*)res.data)[(int)(r_i - c1)] = '0';
				}
			}
			string tmp_res = string_clone(tos(res.data, r_i));
			array_free(&res);
			return tmp_res;
		} else {
			if (dec_digit > 0) {
				int c1 = 0;
				((u8*)res.data)[r_i] = '.';
				r_i++;
				for (;;) {
					if (!(c1 < dec_digit)) break;
					((u8*)res.data)[r_i] = '0';
					r_i++;
					c1++;
				}
				((u8*)res.data)[r_i] = 0;
			}
			string tmp_res = string_clone(tos(res.data, r_i));
			array_free(&res);
			return tmp_res;
		}
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strconv__format_fl(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string fs = strconv__f64_to_str_lnd1((f >= ((f64)(0.0)) ? (f) : (-f)), p.len1);
		if (fs.str[ 0] == '[') {
			return fs;
		}
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros(fs);
			string_free(&tmp);
		}
		Array_fixed_u8_512 buf = {0};
		Array_fixed_u8_512 out = {0};
		int buf_i = 0;
		int out_i = 0;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					out[out_i] = '+';
					out_i++;
					sign_len_diff = -1;
				}
			} else {
				out[out_i] = '-';
				out_i++;
				sign_len_diff = -1;
			}
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					buf[buf_i] = '+';
					buf_i++;
				}
			} else {
				buf[buf_i] = '-';
				buf_i++;
			}
		}
		vmemcpy(&buf[buf_i], fs.str, fs.len);
		buf_i += fs.len;
		int dif = (int)((int)(p.len0 - buf_i) + sign_len_diff);
		if (p.align == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		vmemcpy(&out[out_i], &buf[0], buf_i);
		out_i += buf_i;
		if (p.align == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		out[out_i] = 0;
		string tmp = fs;
		fs = tos_clone(&out[0]);
		string_free(&tmp);
		return fs;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strconv__format_es(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string fs = strconv__f64_to_str_pad((f > 0 ? (f) : (-f)), p.len1);
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros(fs);
			string_free(&tmp);
		}
		Array_fixed_u8_512 buf = {0};
		Array_fixed_u8_512 out = {0};
		int buf_i = 0;
		int out_i = 0;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					out[out_i] = '+';
					out_i++;
					sign_len_diff = -1;
				}
			} else {
				out[out_i] = '-';
				out_i++;
				sign_len_diff = -1;
			}
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					buf[buf_i] = '+';
					buf_i++;
				}
			} else {
				buf[buf_i] = '-';
				buf_i++;
			}
		}
		vmemcpy(&buf[buf_i], fs.str, fs.len);
		buf_i += fs.len;
		int dif = (int)((int)(p.len0 - buf_i) + sign_len_diff);
		if (p.align == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		vmemcpy(&out[out_i], &buf[0], buf_i);
		out_i += buf_i;
		if (p.align == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		out[out_i] = 0;
		string tmp = fs;
		fs = tos_clone(&out[0]);
		string_free(&tmp);
		return fs;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strconv__remove_tail_zeros(string s) {
	{ // Unsafe block
		u8* buf = malloc_noscan((int)(s.len + 1));
		int i_d = 0;
		int i_s = 0;
		for (;;) {
			if (!(i_s < s.len && !(s.str[ i_s] == '-' || s.str[ i_s] == '+') && (s.str[ i_s] > '9' || s.str[ i_s] < '0'))) break;
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		if (i_s < s.len && (s.str[ i_s] == '-' || s.str[ i_s] == '+')) {
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		for (;;) {
			if (!(i_s < s.len && s.str[ i_s] >= '0' && s.str[ i_s] <= '9')) break;
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		if (i_s < s.len && s.str[ i_s] == '.') {
			int i_s1 = (int)(i_s + 1);
			int sum = 0;
			int i_s2 = i_s1;
			for (;;) {
				if (!(i_s1 < s.len && s.str[ i_s1] >= '0' && s.str[ i_s1] <= '9')) break;
				sum += (u8)(s.str[ i_s1] - ((u8)('0')));
				if (s.str[ i_s1] != '0') {
					i_s2 = i_s1;
				}
				i_s1++;
			}
			if (sum > 0) {
				for (int c_i = i_s; c_i < (int)(i_s2 + 1); ++c_i) {
					buf[i_d] = s.str[ c_i];
					i_d++;
				}
			}
			i_s = i_s1;
		}
		if (i_s < s.len && s.str[ i_s] != '.') {
			for (;;) {
				buf[i_d] = s.str[ i_s];
				i_s++;
				i_d++;
				if (i_s >= s.len) {
					break;
				}
			}
		}
		buf[i_d] = 0;
		return tos(buf, i_d);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string strconv__ftoa_64(f64 f) {
	return strconv__f64_to_str(f, 17);
}
inline string strconv__ftoa_32(f32 f) {
	return strconv__f32_to_str(f, 8);
}
string strconv__format_int(i64 n, int radix) {
	{ // Unsafe block
		if (radix < 2 || radix > 36) {
			panic_n(_SLIT("invalid radix, it should be => 2 and <= 36, actual:"), radix);
			VUNREACHABLE();
		}
		if (n == 0) {
			return _SLIT("0");
		}
		i64 n_copy = n;
		bool have_minus = false;
		if (n < 0) {
			have_minus = true;
			n_copy = -n_copy;
		}
		string res = _SLIT("");
		for (;;) {
			if (!(n_copy != 0)) break;
			string tmp_0 = res;
			int bdx = ((int)((i64)(n_copy % radix)));
			string tmp_1 = u8_ascii_str(_const_strconv__base_digits.str[ bdx]);
			res = string__plus(tmp_1, res);
			string_free(&tmp_0);
			string_free(&tmp_1);
			n_copy /= radix;
		}
		if (have_minus) {
			string final_res = string__plus(_SLIT("-"), res);
			string_free(&res);
			return final_res;
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strconv__format_uint(u64 n, int radix) {
	{ // Unsafe block
		if (radix < 2 || radix > 36) {
			panic_n(_SLIT("invalid radix, it should be => 2 and <= 36, actual:"), radix);
			VUNREACHABLE();
		}
		if (n == 0U) {
			return _SLIT("0");
		}
		u64 n_copy = n;
		string res = _SLIT("");
		u64 uradix = ((u64)(radix));
		for (;;) {
			if (!(n_copy != 0U)) break;
			string tmp_0 = res;
			string tmp_1 = u8_ascii_str(_const_strconv__base_digits.str[ (u64)(n_copy % uradix)]);
			res = string__plus(tmp_1, res);
			string_free(&tmp_0);
			string_free(&tmp_1);
			n_copy /= uradix;
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strconv__f32_to_str_l(f32 f) {
	string s = strconv__f32_to_str(f, 6);
	string res = strconv__fxx_to_str_l_parse(s);
	string_free(&s);
	return res;
}
string strconv__f32_to_str_l_with_dot(f32 f) {
	string s = strconv__f32_to_str(f, 6);
	string res = strconv__fxx_to_str_l_parse_with_dot(s);
	string_free(&s);
	return res;
}
string strconv__f64_to_str_l(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	string res = strconv__fxx_to_str_l_parse(s);
	string_free(&s);
	return res;
}
string strconv__f64_to_str_l_with_dot(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	string res = strconv__fxx_to_str_l_parse_with_dot(s);
	string_free(&s);
	return res;
}
string strconv__fxx_to_str_l_parse(string s) {
	if (s.len > 2 && (s.str[ 0] == 'n' || s.str[ 1] == 'i')) {
		return string_clone(s);
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_u8_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		u8 c = s.str[_t2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[i1] = c;
			i1++;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = (int)(i - 1);
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return _SLIT("Float conversion error!!");
		}
	}
	b[i1] = 0;
	if (s.str[ i] == '-') {
		exp_sgn = -1;
		i++;
	} else if (s.str[ i] == '+') {
		exp_sgn = 1;
		i++;
	}
	int c = i;
	for (;;) {
		if (!(c < s.len)) break;
		exp = (int)((int)(exp * 10) + ((int)((rune)(s.str[ c] - '0'))));
		c++;
	}
	Array_u8 res = __new_array_with_default_noscan((int)(exp + 32), 0, sizeof(u8), &(u8[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			((u8*)res.data)[r_i] = '+';
			r_i++;
		}
	} else {
		((u8*)res.data)[r_i] = '-';
		r_i++;
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					((u8*)res.data)[r_i] = '.';
					r_i++;
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
			if (dot_p) {
				((u8*)res.data)[r_i] = '.';
				r_i++;
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
		}
	}
	if (r_i > 1 && ((u8*)res.data)[(int)(r_i - 1)] == '.') {
		((u8*)res.data)[r_i] = '0';
		r_i++;
	} else if (!(Array_u8_contains(res, '.'))) {
		((u8*)res.data)[r_i] = '.';
		r_i++;
		((u8*)res.data)[r_i] = '0';
		r_i++;
	}
	((u8*)res.data)[r_i] = 0;
	return tos(res.data, r_i);
}
string strconv__fxx_to_str_l_parse_with_dot(string s) {
	if (s.len > 2 && (s.str[ 0] == 'n' || s.str[ 1] == 'i')) {
		return string_clone(s);
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_u8_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		u8 c = s.str[_t2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[i1] = c;
			i1++;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = (int)(i - 1);
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return _SLIT("Float conversion error!!");
		}
	}
	b[i1] = 0;
	if (s.str[ i] == '-') {
		exp_sgn = -1;
		i++;
	} else if (s.str[ i] == '+') {
		exp_sgn = 1;
		i++;
	}
	int c = i;
	for (;;) {
		if (!(c < s.len)) break;
		exp = (int)((int)(exp * 10) + ((int)((rune)(s.str[ c] - '0'))));
		c++;
	}
	Array_u8 res = __new_array_with_default_noscan((int)(exp + 32), 0, sizeof(u8), &(u8[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			((u8*)res.data)[r_i] = '+';
			r_i++;
		}
	} else {
		((u8*)res.data)[r_i] = '-';
		r_i++;
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					((u8*)res.data)[r_i] = '.';
					r_i++;
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
			if (dot_p) {
				((u8*)res.data)[r_i] = '.';
				r_i++;
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
		}
	}
	if (r_i > 1 && ((u8*)res.data)[(int)(r_i - 1)] == '.') {
		((u8*)res.data)[r_i] = '0';
		r_i++;
	} else if (!(Array_u8_contains(res, '.'))) {
		((u8*)res.data)[r_i] = '.';
		r_i++;
		((u8*)res.data)[r_i] = '0';
		r_i++;
	}
	((u8*)res.data)[r_i] = 0;
	return tos(res.data, r_i);
}
inline VV_LOCAL_SYMBOL u32 strconv__bool_to_u32(bool b) {
	if (b) {
		return ((u32)(1U));
	}
	return ((u32)(0U));
}
inline VV_LOCAL_SYMBOL u64 strconv__bool_to_u64(bool b) {
	if (b) {
		return ((u64)(1U));
	}
	return ((u64)(0U));
}
VV_LOCAL_SYMBOL string strconv__get_string_special(bool neg, bool expZero, bool mantZero) {
	if (!mantZero) {
		return _SLIT("nan");
	}
	if (!expZero) {
		if (neg) {
			return _SLIT("-inf");
		} else {
			return _SLIT("+inf");
		}
	}
	if (neg) {
		return _SLIT("-0e+00");
	}
	return _SLIT("0e+00");
}
VV_LOCAL_SYMBOL u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift) {
	multi_return_u64_u64 mr_750 = math__bits__mul_64(((u64)(m)), mul);
	u64 hi = mr_750.arg0;
	u64 lo = mr_750.arg1;
	u64 shifted_sum = (u64)(((lo >> ((u64)(ishift)))) + ((hi << ((u64)((int)(64 - ishift))))));
	;
	return ((u32)(shifted_sum));
}
inline VV_LOCAL_SYMBOL u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j) {
	;
	return strconv__mul_shift_32(m, _const_strconv__pow5_inv_split_32[q], j);
}
inline VV_LOCAL_SYMBOL u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j) {
	;
	return strconv__mul_shift_32(m, _const_strconv__pow5_split_32[i], j);
}
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_32(u32 i_v) {
	u32 v = i_v;
	for (u32 n = ((u32)(0U)); true; n++) {
		u32 q = (u32)(v / 5U);
		u32 r = (u32)(v % 5U);
		if (r != 0U) {
			return n;
		}
		v = q;
	}
	return v;
}
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_32(u32 v, u32 p) {
	return strconv__pow5_factor_32(v) >= p;
}
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_32(u32 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_32(v))) >= p;
}
VV_LOCAL_SYMBOL u32 strconv__log10_pow2(int e) {
	;
	;
	return (((u32)(((u32)(e)) * 78913U)) >> 18U);
}
VV_LOCAL_SYMBOL u32 strconv__log10_pow5(int e) {
	;
	;
	return (((u32)(((u32)(e)) * 732923U)) >> 20U);
}
VV_LOCAL_SYMBOL int strconv__pow5_bits(int e) {
	;
	;
	return ((int)((u32)(((((u32)(((u32)(e)) * 1217359U)) >> 19U)) + 1U)));
}
VV_LOCAL_SYMBOL u64 strconv__shift_right_128(strconv__Uint128 v, int shift) {
	;
	return (((v.hi << ((u64)((int)(64 - shift))))) | ((v.lo >> ((u32)(shift)))));
}
VV_LOCAL_SYMBOL u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift) {
	multi_return_u64_u64 mr_3253 = math__bits__mul_64(m, mul.hi);
	u64 hihi = mr_3253.arg0;
	u64 hilo = mr_3253.arg1;
	multi_return_u64_u64 mr_3288 = math__bits__mul_64(m, mul.lo);
	u64 lohi = mr_3288.arg0;
	strconv__Uint128 sum = ((strconv__Uint128){.lo = (u64)(lohi + hilo),.hi = hihi,});
	if (sum.lo < lohi) {
		sum.hi++;
	}
	return strconv__shift_right_128(sum, (int)(shift - 64));
}
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_64(u64 v_i) {
	u64 v = v_i;
	for (u32 n = ((u32)(0U)); true; n++) {
		u64 q = (u64)(v / 5U);
		u64 r = (u64)(v % 5U);
		if (r != 0U) {
			return n;
		}
		v = q;
	}
	return ((u32)(0U));
}
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_64(u64 v, u32 p) {
	return strconv__pow5_factor_64(v) >= p;
}
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_64(u64 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_64(v))) >= p;
}
int strconv__dec_digits(u64 n) {
	if (n <= 9999999999U) {
		if (n <= 99999U) {
			if (n <= 99U) {
				if (n <= 9U) {
					return 1;
				} else {
					return 2;
				}
			} else {
				if (n <= 999U) {
					return 3;
				} else {
					if (n <= 9999U) {
						return 4;
					} else {
						return 5;
					}
				}
			}
		} else {
			if (n <= 9999999U) {
				if (n <= 999999U) {
					return 6;
				} else {
					return 7;
				}
			} else {
				if (n <= 99999999U) {
					return 8;
				} else {
					if (n <= 999999999U) {
						return 9;
					}
					return 10;
				}
			}
		}
	} else {
		if (n <= 999999999999999U) {
			if (n <= 999999999999U) {
				if (n <= 99999999999U) {
					return 11;
				} else {
					return 12;
				}
			} else {
				if (n <= 9999999999999U) {
					return 13;
				} else {
					if (n <= 99999999999999U) {
						return 14;
					} else {
						return 15;
					}
				}
			}
		} else {
			if (n <= 99999999999999999U) {
				if (n <= 9999999999999999U) {
					return 16;
				} else {
					return 17;
				}
			} else {
				if (n <= 999999999999999999U) {
					return 18;
				} else {
					if (n <= 9999999999999999999U) {
						return 19;
					}
					return 20;
				}
			}
		}
	}
	return 0;
}
VV_LOCAL_SYMBOL array __new_array(int mylen, int cap, int elm_size) {
	panic_on_negative_len(mylen);
	panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = vcalloc((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	return arr;
}
VV_LOCAL_SYMBOL array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val) {
	panic_on_negative_len(mylen);
	panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = 0,.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u64 total_size = (u64)(((u64)(cap_)) * ((u64)(elm_size)));
	if (cap_ > 0 && mylen == 0) {
		arr.data = _v_malloc(__at_least_one(total_size));
	} else {
		arr.data = vcalloc(total_size);
	}
	if (val != 0) {
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			if (eptr != ((void*)0)) {
				if (arr.element_size == 1) {
					u8 byte_value = *(((u8*)(val)));
					for (int i = 0; i < arr.len; ++i) {
						eptr[i] = byte_value;
					}
				} else {
					for (int _t1 = 0; _t1 < arr.len; ++_t1) {
						vmemcpy(eptr, val, arr.element_size);
						eptr += arr.element_size;
					}
				}
			}
		}
	}
	return arr;
}
VV_LOCAL_SYMBOL array __new_array_with_multi_default(int mylen, int cap, int elm_size, voidptr val) {
	panic_on_negative_len(mylen);
	panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = 0,.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u64 total_size = (u64)(((u64)(cap_)) * ((u64)(elm_size)));
	arr.data = vcalloc(__at_least_one(total_size));
	if (val != 0) {
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			if (eptr != ((void*)0)) {
				for (int i = 0; i < arr.len; ++i) {
					vmemcpy(eptr, ((charptr)(val)) + (int)(i * arr.element_size), arr.element_size);
					eptr += arr.element_size;
				}
			}
		}
	}
	return arr;
}
VV_LOCAL_SYMBOL array __new_array_with_array_default(int mylen, int cap, int elm_size, array val, int depth) {
	panic_on_negative_len(mylen);
	panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = _v_malloc(__at_least_one((u64)(((u64)(cap_)) * ((u64)(elm_size))))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u8* eptr = ((u8*)(arr.data));
	{ // Unsafe block
		if (eptr != ((void*)0)) {
			for (int _t1 = 0; _t1 < arr.len; ++_t1) {
				array val_clone = array_clone_to_depth(&val, depth);
				vmemcpy(eptr, &val_clone, arr.element_size);
				eptr += arr.element_size;
			}
		}
	}
	return arr;
}
VV_LOCAL_SYMBOL array __new_array_with_map_default(int mylen, int cap, int elm_size, map val) {
	panic_on_negative_len(mylen);
	panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = _v_malloc(__at_least_one((u64)(((u64)(cap_)) * ((u64)(elm_size))))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u8* eptr = ((u8*)(arr.data));
	{ // Unsafe block
		if (eptr != ((void*)0)) {
			for (int _t1 = 0; _t1 < arr.len; ++_t1) {
				map val_clone = map_clone(&val);
				vmemcpy(eptr, &val_clone, arr.element_size);
				eptr += arr.element_size;
			}
		}
	}
	return arr;
}
VV_LOCAL_SYMBOL array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array) {
	panic_on_negative_len(len);
	panic_on_negative_cap(cap);
	int cap_ = (cap < len ? (len) : (cap));
	array arr = ((array){.data = vcalloc((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = len,.cap = cap_,.flags = 0,.element_size = elm_size,});
	vmemcpy(arr.data, c_array, (u64)(((u64)(len)) * ((u64)(elm_size))));
	return arr;
}
VV_LOCAL_SYMBOL void array_ensure_cap(array* a, int required) {
	if (required <= a->cap) {
		return;
	}
	if (ArrayFlags_has(&a->flags, ArrayFlags__nogrow)) {
		panic_n(_SLIT("array.ensure_cap: array with the flag `.nogrow` cannot grow in size, array required new size:"), required);
		VUNREACHABLE();
	}
	i64 cap = (a->cap > 0 ? (((i64)(a->cap))) : (((i64)(2))));
	for (;;) {
		if (!(required > cap)) break;
		cap *= 2;
	}
	if (cap > _const_max_int) {
		if (a->cap < _const_max_int) {
			cap = _const_max_int;
		} else {
			panic_n(_SLIT("array.ensure_cap: array needs to grow to cap (which is > 2^31):"), cap);
			VUNREACHABLE();
		}
	}
	u64 new_size = (u64)(((u64)(cap)) * ((u64)(a->element_size)));
	u8* new_data = _v_malloc(__at_least_one(new_size));
	if (a->data != ((void*)0)) {
		vmemcpy(new_data, a->data, (u64)(((u64)(a->len)) * ((u64)(a->element_size))));
		if (ArrayFlags_has(&a->flags, ArrayFlags__noslices)) {
			_v_free(a->data);
		}
	}
	a->data = new_data;
	a->offset = 0;
	a->cap = ((int)(cap));
}
VV_LOCAL_SYMBOL void array_insert_many(array* a, int i, voidptr val, int size) {
	if (i < 0 || i > a->len) {
		panic_n2(_SLIT("array.insert_many: index out of range (i,a.len):"), i, a->len);
		VUNREACHABLE();
	}
	i64 new_len = (i64)(((i64)(a->len)) + ((i64)(size)));
	if (new_len > _const_max_int) {
		panic_n(_SLIT("array.insert_many: max_int will be exceeded by a.len:"), new_len);
		VUNREACHABLE();
	}
	array_ensure_cap(a, ((int)(new_len)));
	int elem_size = a->element_size;
	{ // Unsafe block
		voidptr iptr = array_get_unsafe(*a, i);
		vmemmove(array_get_unsafe(*a, (int)(i + size)), iptr, (u64)(((u64)((int)(a->len - i))) * ((u64)(elem_size))));
		vmemcpy(iptr, val, (u64)(((u64)(size)) * ((u64)(elem_size))));
	}
	a->len = ((int)(new_len));
}
VV_LOCAL_SYMBOL void array_prepend_many(array* a, voidptr val, int size) {
	array_insert_many(a, 0, val, size);
}
void array_delete(array* a, int i) {
	array_delete_many(a, i, 1);
}
void array_delete_many(array* a, int i, int size) {
	if (i < 0 || (i64)(((i64)(i)) + ((i64)(size))) > ((i64)(a->len))) {
		if (size > 1) {
			panic_n3(_SLIT("array.delete: index out of range (i,i+size,a.len):"), i, (int)(i + size), a->len);
			VUNREACHABLE();
		} else {
			panic_n2(_SLIT("array.delete: index out of range (i,a.len):"), i, a->len);
			VUNREACHABLE();
		}
	}
	if (ArrayFlags_all(&a->flags, (ArrayFlags__noshrink | ArrayFlags__noslices))) {
		vmemmove(((u8*)(a->data)) + (u64)(((u64)(i)) * ((u64)(a->element_size))), ((u8*)(a->data)) + (u64)(((u64)((int)(i + size))) * ((u64)(a->element_size))), (u64)(((u64)((int)((int)(a->len - i) - size))) * ((u64)(a->element_size))));
		a->len -= size;
		return;
	}
	voidptr old_data = a->data;
	int new_size = (int)(a->len - size);
	int new_cap = (new_size == 0 ? (1) : (new_size));
	a->data = vcalloc((u64)(((u64)(new_cap)) * ((u64)(a->element_size))));
	vmemcpy(a->data, old_data, (u64)(((u64)(i)) * ((u64)(a->element_size))));
	vmemcpy(((u8*)(a->data)) + (u64)(((u64)(i)) * ((u64)(a->element_size))), ((u8*)(old_data)) + (u64)(((u64)((int)(i + size))) * ((u64)(a->element_size))), (u64)(((u64)((int)((int)(a->len - i) - size))) * ((u64)(a->element_size))));
	if (ArrayFlags_has(&a->flags, ArrayFlags__noslices)) {
		_v_free(old_data);
	}
	a->len = new_size;
	a->cap = new_cap;
}
void array_clear(array* a) {
	a->len = 0;
}
void array_trim(array* a, int index) {
	if (index < a->len) {
		a->len = index;
	}
}
inline VV_LOCAL_SYMBOL voidptr array_get_unsafe(array a, int i) {
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)(i)) * ((u64)(a.element_size)));
	}
	return 0;
}
VV_LOCAL_SYMBOL voidptr array_get(array a, int i) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a.len) {
			panic_n2(_SLIT("array.get: index out of range (i,a.len):"), i, a.len);
			VUNREACHABLE();
		}
	}
	#endif
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)(i)) * ((u64)(a.element_size)));
	}
	return 0;
}
VV_LOCAL_SYMBOL voidptr array_get_with_check(array a, int i) {
	if (i < 0 || i >= a.len) {
		return 0;
	}
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)(i)) * ((u64)(a.element_size)));
	}
	return 0;
}
voidptr array_first(array a) {
	if (a.len == 0) {
		_v_panic(_SLIT("array.first: array is empty"));
		VUNREACHABLE();
	}
	return a.data;
}
VV_LOCAL_SYMBOL array array_slice(array a, int start, int _end) {
	int end = (_end == _const_max_int ? (a.len) : (_end));
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end) {
			_v_panic(string__plus(string__plus(string__plus(_SLIT("array.slice: invalid slice index (start>end):"), i64_str(((i64)(start)))), _SLIT(", ")), i64_str(((i64)(end)))));
			VUNREACHABLE();
		}
		if (end > a.len) {
			_v_panic(string__plus(string__plus(string__plus(string__plus(_SLIT("array.slice: slice bounds out of range ("), i64_str(((i64)(end)))), _SLIT(" >= ")), i64_str(((i64)(a.len)))), _SLIT(")")));
			VUNREACHABLE();
		}
		if (start < 0) {
			_v_panic(string__plus(_SLIT("array.slice: slice bounds out of range (start<0):"), int_str(start)));
			VUNREACHABLE();
		}
	}
	#endif
	u64 offset = (u64)(((u64)(start)) * ((u64)(a.element_size)));
	u8* data = ((u8*)(a.data)) + offset;
	int l = (int)(end - start);
	array res = ((array){.data = data,.offset = (int)(a.offset + ((int)(offset))),.len = l,.cap = l,.flags = 0,.element_size = a.element_size,});
	return res;
}
VV_LOCAL_SYMBOL array array_slice_ni(array a, int _start, int _end) {
	int end = (_end == _const_max_int ? (a.len) : (_end));
	int start = _start;
	if (start < 0) {
		start = (int)(a.len + start);
		if (start < 0) {
			start = 0;
		}
	}
	if (end < 0) {
		end = (int)(a.len + end);
		if (end < 0) {
			end = 0;
		}
	}
	if (end >= a.len) {
		end = a.len;
	}
	if (start >= a.len || start > end) {
		array res = ((array){.data = a.data,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = a.element_size,});
		return res;
	}
	u64 offset = (u64)(((u64)(start)) * ((u64)(a.element_size)));
	u8* data = ((u8*)(a.data)) + offset;
	int l = (int)(end - start);
	array res = ((array){.data = data,.offset = (int)(a.offset + ((int)(offset))),.len = l,.cap = l,.flags = 0,.element_size = a.element_size,});
	return res;
}
VV_LOCAL_SYMBOL array array_clone_static_to_depth(array a, int depth) {
	return array_clone_to_depth(&a, depth);
}
array array_clone(array* a) {
	return array_clone_to_depth(a, 0);
}
array array_clone_to_depth(array* a, int depth) {
	u64 source_capacity_in_bytes = (u64)(((u64)(a->cap)) * ((u64)(a->element_size)));
	array arr = ((array){.data = vcalloc(source_capacity_in_bytes),.offset = 0,.len = a->len,.cap = a->cap,.flags = 0,.element_size = a->element_size,});
	if (depth > 0 && _us32_eq(sizeof(array),a->element_size) && a->len >= 0 && a->cap >= a->len) {
		array ar = ((array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,});
		int asize = ((int)(sizeof(array)));
		for (int i = 0; i < a->len; ++i) {
			vmemcpy(&ar, array_get_unsafe(*a, i), asize);
			array ar_clone = array_clone_to_depth(&ar, (int)(depth - 1));
			array_set_unsafe(&arr, i, &ar_clone);
		}
		return arr;
	} else {
		if (a->data != 0 && source_capacity_in_bytes > 0U) {
			vmemcpy(((u8*)(arr.data)), a->data, source_capacity_in_bytes);
		}
		return arr;
	}
	return (array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,};
}
inline VV_LOCAL_SYMBOL void array_set_unsafe(array* a, int i, voidptr val) {
	vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(i))), val, a->element_size);
}
VV_LOCAL_SYMBOL void array_set(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a->len) {
			panic_n2(_SLIT("array.set: index out of range (i,a.len):"), i, a->len);
			VUNREACHABLE();
		}
	}
	#endif
	vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(i))), val, a->element_size);
}
VV_LOCAL_SYMBOL void array_push(array* a, voidptr val) {
	if (a->len < 0) {
		_v_panic(_SLIT("array.push: negative len"));
		VUNREACHABLE();
	}
	if (a->len >= _const_max_int) {
		_v_panic(_SLIT("array.push: len bigger than max_int"));
		VUNREACHABLE();
	}
	if (a->len >= a->cap) {
		array_ensure_cap(a, (int)(a->len + 1));
	}
	vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(a->len))), val, a->element_size);
	a->len++;
}
void array_push_many(array* a, voidptr val, int size) {
	if (size <= 0 || val == ((void*)0)) {
		return;
	}
	i64 new_len = (i64)(((i64)(a->len)) + ((i64)(size)));
	if (new_len > _const_max_int) {
		_v_panic(_SLIT("array.push_many: new len exceeds max_int"));
		VUNREACHABLE();
	}
	if (new_len >= a->cap) {
		array_ensure_cap(a, ((int)(new_len)));
	}
	if (a->data == val && a->data != 0) {
		array copy = array_clone(a);
		vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(a->len))), copy.data, (u64)(((u64)(a->element_size)) * ((u64)(size))));
	} else {
		if (a->data != 0 && val != 0) {
			vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(a->len))), val, (u64)(((u64)(a->element_size)) * ((u64)(size))));
		}
	}
	a->len = ((int)(new_len));
}
void array_free(array* a) {
	if (ArrayFlags_has(&a->flags, ArrayFlags__nofree)) {
		return;
	}
	u8* mblock_ptr = ((u8*)((u64)(((u64)(a->data)) - ((u64)(a->offset)))));
	if (mblock_ptr != ((void*)0)) {
		_v_free(mblock_ptr);
	}
	{ // Unsafe block
		a->data = ((void*)0);
		a->offset = 0;
	}
}
array array_filter(array a, bool (*predicate)(voidptr ));
array array_map(array a, voidptr (*callback)(voidptr ));
void array_sort(array* a, int (*callback)(voidptr , voidptr ));
void Array_string_free(Array_string* a) {
	for (int _t1 = 0; _t1 < a->len; ++_t1) {
		string* s = ((string*)a->data) + _t1;
		string_free(s);
	}
	array_free((((array*)(a))));
}
string Array_string_str(Array_string a) {
	int sb_len = 4;
	if (a.len > 0) {
		sb_len += ((string*)a.data)[0].len;
		sb_len *= a.len;
	}
	sb_len += 2;
	strings__Builder sb = strings__new_builder(sb_len);
	strings__Builder_write_u8(&sb, '[');
	for (int i = 0; i < a.len; ++i) {
		string val = ((string*)a.data)[i];
		strings__Builder_write_u8(&sb, '\'');
		strings__Builder_write_string(&sb, val);
		strings__Builder_write_u8(&sb, '\'');
		if (i < (int)(a.len - 1)) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_u8(&sb, ']');
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
string Array_u8_hex(Array_u8 b) {
	if (b.len == 0) {
		return _SLIT("");
	}
	return data_to_hex_string(((u8*)(b.data)), b.len);
}
int copy(Array_u8* dst, Array_u8 src) {
	int min = (dst->len < src.len ? (dst->len) : (src.len));
	if (min > 0) {
		vmemmove(((u8*)(dst->data)), src.data, min);
	}
	return min;
}
Array_u8 voidptr_vbytes(voidptr data, int len) {
	array res = ((array){.data = data,.offset = 0,.len = len,.cap = len,.flags = 0,.element_size = 1,});
	return res;
}
Array_u8 u8_vbytes(u8* data, int len) {
	return voidptr_vbytes(((voidptr)(data)), len);
}
void u8_free(u8* data) {
	_v_free(data);
}
inline VV_LOCAL_SYMBOL void panic_on_negative_len(int len) {
	if (len < 0) {
		panic_n(_SLIT("negative .len:"), len);
		VUNREACHABLE();
	}
}
inline VV_LOCAL_SYMBOL void panic_on_negative_cap(int cap) {
	if (cap < 0) {
		panic_n(_SLIT("negative .cap:"), cap);
		VUNREACHABLE();
	}
}
VV_LOCAL_SYMBOL array __new_array_noscan(int mylen, int cap, int elm_size) {
	panic_on_negative_len(mylen);
	panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	return arr;
}
VV_LOCAL_SYMBOL array __new_array_with_default_noscan(int mylen, int cap, int elm_size, voidptr val) {
	panic_on_negative_len(mylen);
	panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	if (val != 0 && arr.data != ((void*)0)) {
		if (elm_size == 1) {
			u8 byte_value = *(((u8*)(val)));
			u8* dptr = ((u8*)(arr.data));
			for (int i = 0; i < arr.len; ++i) {
				{ // Unsafe block
					dptr[i] = byte_value;
				}
			}
		} else {
			for (int i = 0; i < arr.len; ++i) {
				array_set_unsafe(&arr, i, val);
			}
		}
	}
	return arr;
}
VV_LOCAL_SYMBOL array __new_array_with_multi_default_noscan(int mylen, int cap, int elm_size, voidptr val) {
	panic_on_negative_len(mylen);
	panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	if (val != 0 && arr.data != ((void*)0)) {
		for (int i = 0; i < arr.len; ++i) {
			array_set_unsafe(&arr, i, ((charptr)(val)) + (int)(i * elm_size));
		}
	}
	return arr;
}
VV_LOCAL_SYMBOL array __new_array_with_array_default_noscan(int mylen, int cap, int elm_size, array val) {
	panic_on_negative_len(mylen);
	panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	for (int i = 0; i < arr.len; ++i) {
		array val_clone = array_clone(&val);
		array_set_unsafe(&arr, i, &val_clone);
	}
	return arr;
}
VV_LOCAL_SYMBOL array new_array_from_c_array_noscan(int len, int cap, int elm_size, voidptr c_array) {
	panic_on_negative_len(len);
	panic_on_negative_cap(cap);
	int cap_ = (cap < len ? (len) : (cap));
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = len,.cap = cap_,.flags = 0,.element_size = elm_size,});
	vmemcpy(arr.data, c_array, (u64)(((u64)(len)) * ((u64)(elm_size))));
	return arr;
}
VV_LOCAL_SYMBOL void array_ensure_cap_noscan(array* a, int required) {
	if (required <= a->cap) {
		return;
	}
	if (ArrayFlags_has(&a->flags, ArrayFlags__nogrow)) {
		panic_n(_SLIT("array.ensure_cap_noscan: array with the flag `.nogrow` cannot grow in size, array required new size:"), required);
		VUNREACHABLE();
	}
	i64 cap = (a->cap > 0 ? (((i64)(a->cap))) : (((i64)(2))));
	for (;;) {
		if (!(required > cap)) break;
		cap *= 2;
	}
	if (cap > _const_max_int) {
		if (a->cap < _const_max_int) {
			cap = _const_max_int;
		} else {
			panic_n(_SLIT("array.ensure_cap_noscan: array needs to grow to cap (which is > 2^31):"), cap);
			VUNREACHABLE();
		}
	}
	u64 new_size = (u64)(((u64)(cap)) * ((u64)(a->element_size)));
	u8* new_data = vcalloc_noscan(new_size);
	if (a->data != ((void*)0)) {
		vmemcpy(new_data, a->data, (u64)(((u64)(a->len)) * ((u64)(a->element_size))));
	}
	a->data = new_data;
	a->offset = 0;
	a->cap = ((int)(cap));
}
VV_LOCAL_SYMBOL array array_repeat_to_depth_noscan(array a, int count, int depth) {
	if (count < 0) {
		panic_n(_SLIT("array.repeat: count is negative:"), count);
		VUNREACHABLE();
	}
	u64 size = (u64)((u64)(((u64)(count)) * ((u64)(a.len))) * ((u64)(a.element_size)));
	if (size == 0U) {
		size = ((u64)(a.element_size));
	}
	array arr = ((array){.data = (depth > 0 ? (vcalloc(size)) : (vcalloc_noscan(size))),.offset = 0,.len = (int)(count * a.len),.cap = (int)(count * a.len),.flags = 0,.element_size = a.element_size,});
	if (a.len > 0) {
		u64 a_total_size = (u64)(((u64)(a.len)) * ((u64)(a.element_size)));
		u64 arr_step_size = (u64)(((u64)(a.len)) * ((u64)(arr.element_size)));
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			for (int _t1 = 0; _t1 < count; ++_t1) {
				if (depth > 0) {
					array ary_clone = array_clone_to_depth_noscan(&a, depth);
					vmemcpy(eptr, ((u8*)(ary_clone.data)), a_total_size);
				} else {
					vmemcpy(eptr, ((u8*)(a.data)), a_total_size);
				}
				eptr += arr_step_size;
			}
		}
	}
	return arr;
}
VV_LOCAL_SYMBOL void array_insert_noscan(array* a, int i, voidptr val) {
	if (i < 0 || i > a->len) {
		panic_n2(_SLIT("array.insert_noscan: index out of range (i,a.len):"), i, a->len);
		VUNREACHABLE();
	}
	if (a->len == _const_max_int) {
		_v_panic(_SLIT("array.insert_noscan: a.len reached max_int"));
		VUNREACHABLE();
	}
	array_ensure_cap_noscan(a, (int)(a->len + 1));
	{ // Unsafe block
		vmemmove(array_get_unsafe(*a, (int)(i + 1)), array_get_unsafe(*a, i), (u64)(((u64)((int)(a->len - i))) * ((u64)(a->element_size))));
		array_set_unsafe(a, i, val);
	}
	a->len++;
}
VV_LOCAL_SYMBOL void array_insert_many_noscan(array* a, int i, voidptr val, int size) {
	if (i < 0 || i > a->len) {
		panic_n2(_SLIT("array.insert_many: index out of range (i, a.len):"), i, a->len);
		VUNREACHABLE();
	}
	i64 new_len = (i64)(((i64)(a->len)) + ((i64)(size)));
	if (new_len > _const_max_int) {
		panic_n(_SLIT("array.insert_many_noscan: max_int will be exceeded by a.len:"), new_len);
		VUNREACHABLE();
	}
	array_ensure_cap_noscan(a, (int)(a->len + size));
	int elem_size = a->element_size;
	{ // Unsafe block
		voidptr iptr = array_get_unsafe(*a, i);
		vmemmove(array_get_unsafe(*a, (int)(i + size)), iptr, (u64)(((u64)((int)(a->len - i))) * ((u64)(elem_size))));
		vmemcpy(iptr, val, (u64)(((u64)(size)) * ((u64)(elem_size))));
	}
	a->len += size;
}
VV_LOCAL_SYMBOL void array_prepend_noscan(array* a, voidptr val) {
	array_insert_noscan(a, 0, val);
}
VV_LOCAL_SYMBOL void array_prepend_many_noscan(array* a, voidptr val, int size) {
	array_insert_many_noscan(a, 0, val, size);
}
VV_LOCAL_SYMBOL voidptr array_pop_noscan(array* a) {
	if (a->len == 0) {
		_v_panic(_SLIT("array.pop: array is empty"));
		VUNREACHABLE();
	}
	int new_len = (int)(a->len - 1);
	u8* last_elem = ((u8*)(a->data)) + (u64)(((u64)(new_len)) * ((u64)(a->element_size)));
	a->len = new_len;
	return memdup_noscan(last_elem, a->element_size);
}
VV_LOCAL_SYMBOL array array_clone_static_to_depth_noscan(array a, int depth) {
	return array_clone_to_depth_noscan(&a, depth);
}
VV_LOCAL_SYMBOL array array_clone_to_depth_noscan(array* a, int depth) {
	u64 size = (u64)(((u64)(a->cap)) * ((u64)(a->element_size)));
	if (size == 0U) {
		size++;
	}
	array arr = ((array){.data = (depth == 0 ? (vcalloc_noscan(size)) : (vcalloc(size))),.offset = 0,.len = a->len,.cap = a->cap,.flags = 0,.element_size = a->element_size,});
	if (depth > 0) {
		for (int i = 0; i < a->len; ++i) {
			array ar = ((array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,});
			vmemcpy(&ar, array_get_unsafe(*a, i), ((int)(sizeof(array))));
			array ar_clone = array_clone_to_depth_noscan(&ar, (int)(depth - 1));
			array_set_unsafe(&arr, i, &ar_clone);
		}
		return arr;
	} else {
		if (a->data != 0) {
			vmemcpy(((u8*)(arr.data)), a->data, (u64)(((u64)(a->cap)) * ((u64)(a->element_size))));
		}
		return arr;
	}
	return (array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,};
}
VV_LOCAL_SYMBOL void array_push_noscan(array* a, voidptr val) {
	if (a->len < 0) {
		_v_panic(_SLIT("array.push_noscan: negative len"));
		VUNREACHABLE();
	}
	if (a->len >= _const_max_int) {
		_v_panic(_SLIT("array.push_noscan: len bigger than max_int"));
		VUNREACHABLE();
	}
	if (a->len >= a->cap) {
		array_ensure_cap_noscan(a, (int)(a->len + 1));
	}
	vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(a->len))), val, a->element_size);
	a->len++;
}
VV_LOCAL_SYMBOL void array_push_many_noscan(array* a, voidptr val, int size) {
	if (size == 0 || val == ((void*)0)) {
		return;
	}
	i64 new_len = (i64)(((i64)(a->len)) + ((i64)(size)));
	if (new_len > _const_max_int) {
		_v_panic(_SLIT("array.push_many_noscan: new len exceeds max_int"));
		VUNREACHABLE();
	}
	if (a->data == val && a->data != 0) {
		array copy = array_clone(a);
		array_ensure_cap_noscan(a, (int)(a->len + size));
		vmemcpy(array_get_unsafe(*a, a->len), copy.data, (u64)(((u64)(a->element_size)) * ((u64)(size))));
	} else {
		array_ensure_cap_noscan(a, (int)(a->len + size));
		if (a->data != 0 && val != 0) {
			vmemcpy(array_get_unsafe(*a, a->len), val, (u64)(((u64)(a->element_size)) * ((u64)(size))));
		}
	}
	a->len = ((int)(new_len));
}
VV_LOCAL_SYMBOL array array_reverse_noscan(array a) {
	if (a.len < 2) {
		return a;
	}
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(a.cap)) * ((u64)(a.element_size)))),.offset = 0,.len = a.len,.cap = a.cap,.flags = 0,.element_size = a.element_size,});
	for (int i = 0; i < a.len; ++i) {
		array_set_unsafe(&arr, i, array_get_unsafe(a, (int)((int)(a.len - 1) - i)));
	}
	return arr;
}
VV_LOCAL_SYMBOL void array_grow_cap_noscan(array* a, int amount) {
	i64 new_cap = (i64)(((i64)(amount)) + ((i64)(a->cap)));
	if (new_cap > _const_max_int) {
		panic_n(_SLIT("array.grow_cap: max_int will be exceeded by new cap:"), new_cap);
		VUNREACHABLE();
	}
	array_ensure_cap_noscan(a, ((int)(new_cap)));
}
VV_LOCAL_SYMBOL void array_grow_len_noscan(array* a, int amount) {
	i64 new_len = (i64)(((i64)(amount)) + ((i64)(a->len)));
	if (new_len > _const_max_int) {
		panic_n(_SLIT("array.grow_len: max_int will be exceeded by new len:"), new_len);
		VUNREACHABLE();
	}
	array_ensure_cap_noscan(a, ((int)(new_len)));
	a->len = ((int)(new_len));
}
void print_backtrace(void) {
	#if !defined(CUSTOM_DEFINE_no_backtrace)
	{
		#if defined(_VFREESTANDING)
		{
		}
		#elif defined(_VNATIVE)
		{
		}
		#elif defined(__TINYC__)
		{
			tcc_backtrace("Backtrace");
		}
		#elif defined(CUSTOM_DEFINE_use_libbacktrace)
		{
		}
		#else
		{
		}
		#endif
	}
	#endif
}
bool print_backtrace_skipping_top_frames(int xskipframes) {
	#if defined(CUSTOM_DEFINE_no_backtrace)
	{
	}
	#else
	{
		int skipframes = (int)(xskipframes + 2);
		#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
		{
		}
		#elif defined(__linux__)
		{
			return print_backtrace_skipping_top_frames_linux(skipframes);
		}
		#else
		{
		}
		#endif
	}
	#endif
	return false;
}
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_linux(int skipframes) {
	#if !defined(__GLIBC__)
	{
		eprintln(_SLIT("backtrace_symbols is missing => printing backtraces is not available."));
		eprintln(_SLIT("Some libc implementations like musl simply do not provide it."));
		return false;
	}
	#endif
	#if defined(_VNATIVE)
	{
		eprintln(_SLIT("native backend does not support backtraces yet."));
		return false;
	}
	#elif defined(CUSTOM_DEFINE_no_backtrace)
	{
	}
	#else
	{
		#if defined(__linux__) && !defined(_VFREESTANDING)
		{
			#if defined(__TINYC__)
			{
				tcc_backtrace("Backtrace");
				return false;
			}
			#else
			{
			}
			#endif
		}
		#endif
	}
	#endif
	return true;
}
VV_LOCAL_SYMBOL void v_segmentation_fault_handler(i32 signal_number) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fprintf(stderr, "signal %d: segmentation fault\n", signal_number);
	}
	#endif
	#if defined(CUSTOM_DEFINE_use_libbacktrace)
	{
	}
	#else
	{
		print_backtrace();
	}
	#endif
	_v_exit((i32)(128 + signal_number));
	VUNREACHABLE();
}
VNORETURN void _v_exit(int code) {
	exit(code);
	VUNREACHABLE();
	while(1);
}
_result_void at_exit(void (*cb)(void)) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		int res = atexit((voidptr)cb);
		if (res != 0) {
			return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("at_exit failed"), res), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#endif
	return (_result_void){0};
}
VNORETURN void panic_option_not_set(string s) {
	_v_panic(string__plus(string__plus(_SLIT("option not set ("), s), _SLIT(")")));
	VUNREACHABLE();
	while(1);
}
VNORETURN void panic_result_not_set(string s) {
	_v_panic(string__plus(string__plus(_SLIT("result not set ("), s), _SLIT(")")));
	VUNREACHABLE();
	while(1);
}
string vcurrent_hash(void) {
	return _SLIT("86536e4");
}
VNORETURN void _v_panic(string s) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		eprint(_SLIT("V panic: "));
		eprintln(s);
		eprint(_SLIT("v hash: "));
		eprintln(vcurrent_hash());
		#if defined(_VNATIVE)
		{
			exit(1);
			VUNREACHABLE();
		}
		#elif defined(CUSTOM_DEFINE_exit_after_panic_message)
		{
		}
		#elif defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			#if defined(__TINYC__)
			{
				#if defined(CUSTOM_DEFINE_panics_break_into_debugger)
				{
				}
				#else
				{
					tcc_backtrace("Backtrace");
				}
				#endif
				exit(1);
				VUNREACHABLE();
			}
			#endif
			#if defined(CUSTOM_DEFINE_use_libbacktrace)
			{
			}
			#else
			{
				print_backtrace_skipping_top_frames(1);
			}
			#endif
			exit(1);
			VUNREACHABLE();
		}
		#endif
	}
	#endif
	exit(1);
	VUNREACHABLE();
	while(1);
}
string c_error_number_str(int errnum) {
	string err_msg = _SLIT("");
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if !defined(__vinix__)
		{
			char* c_msg = strerror(errnum);
			err_msg = ((string){.str = ((u8*)(c_msg)), .len = strlen(c_msg), .is_lit = 1});
		}
		#endif
	}
	#endif
	return err_msg;
}
VNORETURN void panic_n(string s, i64 number1) {
	_v_panic(string__plus(s, i64_str(number1)));
	VUNREACHABLE();
	while(1);
}
VNORETURN void panic_n2(string s, i64 number1, i64 number2) {
	_v_panic(string__plus(string__plus(string__plus(s, i64_str(number1)), _SLIT(", ")), i64_str(number2)));
	VUNREACHABLE();
	while(1);
}
VNORETURN VV_LOCAL_SYMBOL void panic_n3(string s, i64 number1, i64 number2, i64 number3) {
	_v_panic(string__plus(string__plus(string__plus(string__plus(string__plus(s, i64_str(number1)), _SLIT(", ")), i64_str(number2)), _SLIT(", ")), i64_str(number2)));
	VUNREACHABLE();
	while(1);
}
VNORETURN void panic_error_number(string basestr, int errnum) {
	_v_panic(string__plus(basestr, c_error_number_str(errnum)));
	VUNREACHABLE();
	while(1);
}
void eprintln(string s) {
	if (s.str == 0) {
		eprintln(_SLIT("eprintln(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		flush_stdout();
		flush_stderr();
		_writeln_to_fd(2, s);
		flush_stderr();
	}
	#endif
}
void eprint(string s) {
	if (s.str == 0) {
		eprint(_SLIT("eprint(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		flush_stdout();
		flush_stderr();
		_write_buf_to_fd(2, s.str, s.len);
		flush_stderr();
	}
	#endif
}
void flush_stdout(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fflush(stdout);
	}
	#endif
}
void flush_stderr(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fflush(stderr);
	}
	#endif
}
void print(string s) {
	#if defined(__ANDROID__) && !defined(__TERMUX__)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		_write_buf_to_fd(1, s.str, s.len);
	}
	#endif
}
void println(string s) {
	if (s.str == 0) {
		println(_SLIT("println(NIL)"));
		return;
	}
	#if defined(__ANDROID__) && !defined(__TERMUX__)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		_writeln_to_fd(1, s);
	}
	#endif
}
VV_LOCAL_SYMBOL void _writeln_to_fd(int fd, string s) {
	#if defined(CUSTOM_DEFINE_builtin_writeln_should_write_at_once)
	{
	}
	#else
	{
		u8 lf = ((u8)('\n'));
		_write_buf_to_fd(fd, s.str, s.len);
		_write_buf_to_fd(fd, &lf, 1);
	}
	#endif
}
VV_LOCAL_SYMBOL void _write_buf_to_fd(int fd, u8* buf, int buf_len) {
	if (buf_len <= 0) {
		return;
	}
	u8* ptr = buf;
	isize remaining_bytes = ((isize)(buf_len));
	isize x = ((isize)(0));
	#if defined(_VFREESTANDING) || defined(__vinix__) || defined(CUSTOM_DEFINE_builtin_write_buf_to_fd_should_use_c_write)
	{
	}
	#else
	{
		voidptr stream = ((voidptr)(stdout));
		if (fd == 2) {
			stream = ((voidptr)(stderr));
		}
		{ // Unsafe block
			for (;;) {
				if (!(remaining_bytes > 0)) break;
				x = ((isize)(fwrite(ptr, 1, remaining_bytes, stream)));
				ptr += x;
				remaining_bytes -= x;
			}
		}
	}
	#endif
}
VNORETURN VV_LOCAL_SYMBOL void _memory_panic(string fname, isize size) {
	v_memory_panic = true;
	eprint(fname);
	eprint(_SLIT("("));
	#if defined(_VFREESTANDING) || defined(__vinix__)
	{
	}
	#else
	{
		fprintf(stderr, "%p", ((voidptr)(size)));
	}
	#endif
	if (size < 0) {
		eprint(_SLIT(" < 0"));
	}
	eprintln(_SLIT(")"));
	_v_panic(_SLIT("memory allocation failure"));
	VUNREACHABLE();
	while(1);
}
u8* _v_malloc(isize n) {
	;
	if (n < 0) {
		_memory_panic(_SLIT("malloc"), n);
		VUNREACHABLE();
	} else if (n == 0) {
		return ((u8*)(0));
	}
	u8* res = ((u8*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		{ // Unsafe block
			res = GC_MALLOC(n);
		}
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
	}
	#endif
	if (res == 0) {
		_memory_panic(_SLIT("malloc"), n);
		VUNREACHABLE();
	}
	return res;
}
u8* malloc_noscan(isize n) {
	;
	if (n < 0) {
		_memory_panic(_SLIT("malloc_noscan"), n);
		VUNREACHABLE();
	}
	u8* res = ((u8*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		#if defined(CUSTOM_DEFINE_gcboehm_opt)
		{
			{ // Unsafe block
				res = GC_MALLOC_ATOMIC(n);
			}
		}
		#else
		{
		}
		#endif
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
	}
	#endif
	if (res == 0) {
		_memory_panic(_SLIT("malloc_noscan"), n);
		VUNREACHABLE();
	}
	return res;
}
inline VV_LOCAL_SYMBOL u64 __at_least_one(u64 how_many) {
	if (how_many == 0U) {
		return 1U;
	}
	return how_many;
}
u8* malloc_uncollectable(isize n) {
	;
	if (n < 0) {
		_memory_panic(_SLIT("malloc_uncollectable"), n);
		VUNREACHABLE();
	}
	u8* res = ((u8*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		{ // Unsafe block
			res = GC_MALLOC_UNCOLLECTABLE(n);
		}
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
	}
	#endif
	if (res == 0) {
		_memory_panic(_SLIT("malloc_uncollectable"), n);
		VUNREACHABLE();
	}
	return res;
}
u8* v_realloc(u8* b, isize n) {
	u8* new_ptr = ((u8*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		new_ptr = GC_REALLOC(b, n);
	}
	#else
	{
	}
	#endif
	if (new_ptr == 0) {
		_memory_panic(_SLIT("v_realloc"), n);
		VUNREACHABLE();
	}
	return new_ptr;
}
u8* realloc_data(u8* old_data, int old_size, int new_size) {
	u8* nptr = ((u8*)(0));
	#if defined(_VGCBOEHM)
	{
		nptr = GC_REALLOC(old_data, new_size);
	}
	#else
	{
	}
	#endif
	if (nptr == 0) {
		_memory_panic(_SLIT("realloc_data"), ((isize)(new_size)));
		VUNREACHABLE();
	}
	return nptr;
}
u8* vcalloc(isize n) {
	if (n < 0) {
		_memory_panic(_SLIT("vcalloc"), n);
		VUNREACHABLE();
	} else if (n == 0) {
		return ((u8*)(0));
	}
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		return ((u8*)(GC_MALLOC(n)));
	}
	#else
	{
	}
	#endif
	return ((u8*)(0));
}
u8* vcalloc_noscan(isize n) {
	;
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		if (n < 0) {
			_memory_panic(_SLIT("vcalloc_noscan"), n);
			VUNREACHABLE();
		}
		#if defined(CUSTOM_DEFINE_gcboehm_opt)
		{
			voidptr res = GC_MALLOC_ATOMIC(n);
			memset(res, 0, n);
			return ((u8*)(res));
		}
		#else
		{
		}
		#endif
	}
	#else
	{
	}
	#endif
	return ((u8*)(0));
}
void _v_free(voidptr ptr) {
	if (ptr == 0) {
		return;
	}
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#else
	{
	}
	#endif
}
voidptr memdup(voidptr src, isize sz) {
	if (sz == 0) {
		return vcalloc(1);
	}
	{ // Unsafe block
		u8* mem = _v_malloc(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}
voidptr memdup_noscan(voidptr src, isize sz) {
	if (sz == 0) {
		return vcalloc_noscan(1);
	}
	{ // Unsafe block
		u8* mem = malloc_noscan(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}
voidptr memdup_uncollectable(voidptr src, isize sz) {
	if (sz == 0) {
		return vcalloc(1);
	}
	{ // Unsafe block
		u8* mem = malloc_uncollectable(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}
inline VV_LOCAL_SYMBOL int v_fixed_index(int i, int len) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= len) {
			_v_panic(string__plus(string__plus(string__plus(string__plus(_SLIT("fixed array index out of range (index: "), i64_str(((i64)(i)))), _SLIT(", len: ")), i64_str(((i64)(len)))), _SLIT(")")));
			VUNREACHABLE();
		}
	}
	#endif
	return i;
}
Array_string arguments(void) {
	u8** argv = ((u8**)(g_main_argv));
	Array_string res = __new_array_with_default(0, g_main_argc, sizeof(string), 0);
	for (int i = 0; i < g_main_argc; ++i) {
		#if defined(_WIN32)
		{
		}
		#else
		{
			array_push((array*)&res, _MOV((string[]){ tos_clone(argv[i]) }));
		}
		#endif
	}
	return res;
}
inline bool isnil(voidptr v) {
	return v == 0;
}
VV_LOCAL_SYMBOL voidptr __as_cast(voidptr obj, int obj_type, int expected_type) {
	if (obj_type != expected_type) {
		string obj_name = string_clone(((VCastTypeIndexName*)as_cast_type_indexes.data)[0].tname);
		string expected_name = string_clone(((VCastTypeIndexName*)as_cast_type_indexes.data)[0].tname);
		for (int _t1 = 0; _t1 < as_cast_type_indexes.len; ++_t1) {
			VCastTypeIndexName x = ((VCastTypeIndexName*)as_cast_type_indexes.data)[_t1];
			if (x.tindex == obj_type) {
				obj_name = string_clone(x.tname);
			}
			if (x.tindex == expected_type) {
				expected_name = string_clone(x.tname);
			}
		}
		_v_panic(string__plus(string__plus(string__plus(string__plus(_SLIT("as cast: cannot cast `"), obj_name), _SLIT("` to `")), expected_name), _SLIT("`")));
		VUNREACHABLE();
	}
	return obj;
}
void VAssertMetaInfo_free(VAssertMetaInfo* ami) {
	{ // Unsafe block
		string_free(&ami->fpath);
		string_free(&ami->fn_name);
		string_free(&ami->src);
		string_free(&ami->op);
		string_free(&ami->llabel);
		string_free(&ami->rlabel);
		string_free(&ami->lvalue);
		string_free(&ami->rvalue);
		string_free(&ami->message);
	}
}
VV_LOCAL_SYMBOL void __print_assert_failure(VAssertMetaInfo* i) {
	eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = i->fpath}}, {_SLIT(":"), 0xfe07, {.d_i32 = (int)(i->line_nr + 1)}}, {_SLIT(": FAIL: fn "), 0xfe10, {.d_s = i->fn_name}}, {_SLIT(": assert "), 0xfe10, {.d_s = i->src}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (i->op.len > 0 && !fast_string_eq(i->op, _SLIT("call"))) {
		if (string__eq(i->llabel, i->lvalue)) {
			eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("  left value: "), 0xfe10, {.d_s = i->llabel}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			eprintln(str_intp(3, _MOV((StrIntpData[]){{_SLIT("  left value: "), 0xfe10, {.d_s = i->llabel}}, {_SLIT(" = "), 0xfe10, {.d_s = i->lvalue}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		if (string__eq(i->rlabel, i->rvalue)) {
			eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("  right value: "), 0xfe10, {.d_s = i->rlabel}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			eprintln(str_intp(3, _MOV((StrIntpData[]){{_SLIT("  right value: "), 0xfe10, {.d_s = i->rlabel}}, {_SLIT(" = "), 0xfe10, {.d_s = i->rvalue}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
	if (i->has_msg) {
		eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("      message: "), 0xfe10, {.d_s = i->message}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}
#if !defined(CUSTOM_DEFINE_no_gc_threads)
#endif
#if defined(CUSTOM_DEFINE_dynamic_boehm)
#else
	#if defined(__APPLE__) || defined(__linux__)
		#if (defined(_VPROD) && !defined(__TINYC__) && !defined(_VDEBUG)) || !(defined(__V_amd64) || defined(__V_arm64) || defined(__V_x86) || defined(__V_arm32) || defined(__V_rv64))
		#else
			#if !defined(CUSTOM_DEFINE_use_bundled_libgc)
			#endif
		#endif
	#elif defined(__FreeBSD__)
	#elif defined(__OpenBSD__)
	#elif defined(_WIN32)
	#elif true
	#else
	#endif
#endif
void gc_set_warn_proc(void (*cb)(char* msg, usize arg)) {
	GC_set_warn_proc((voidptr)cb);
}
VV_LOCAL_SYMBOL void internal_gc_warn_proc_none(char* msg, usize arg) {
}
VV_LOCAL_SYMBOL void builtin_init(void) {
	#if defined(_VGCBOEHM)
	{
		#if !defined(CUSTOM_DEFINE_gc_warn_on_stderr)
		{
			gc_set_warn_proc((voidptr)internal_gc_warn_proc_none);
		}
		#endif
	}
	#endif
}
inline int vstrlen(u8* s) {
	return strlen(((char*)(s)));
}
inline int vstrlen_char(char* s) {
	return strlen(s);
}
inline voidptr vmemcpy(voidptr dest, const voidptr const_src, isize n) {
	if (n == 0) {
		return dest;
	}
	{ // Unsafe block
		return memcpy(dest, const_src, n);
	}
	return 0;
}
inline voidptr vmemmove(voidptr dest, const voidptr const_src, isize n) {
	if (n == 0) {
		return dest;
	}
	{ // Unsafe block
		return memmove(dest, const_src, n);
	}
	return 0;
}
inline int vmemcmp(const voidptr const_s1, const voidptr const_s2, isize n) {
	if (n == 0) {
		return 0;
	}
	{ // Unsafe block
		return memcmp(const_s1, const_s2, n);
	}
	return 0;
}
inline voidptr vmemset(voidptr s, int c, isize n) {
	if (n == 0) {
		return s;
	}
	{ // Unsafe block
		return memset(s, c, n);
	}
	return 0;
}
#if !defined(_VNATIVE)
#endif
inline string f64_str(f64 x) {
	{ // Unsafe block
		strconv__Float64u f = ((strconv__Float64u){.f = x,});
		if (f.u == _const_strconv__double_minus_zero) {
			return _SLIT("-0.0");
		}
		if (f.u == _const_strconv__double_plus_zero) {
			return _SLIT("0.0");
		}
	}
	f64 abs_x = f64_abs(x);
	if (abs_x >= ((f64)(0.0001)) && abs_x < ((f64)(1.0e6))) {
		return strconv__f64_to_str_l(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string f64_strg(f64 x) {
	if (x == 0) {
		return _SLIT("0.0");
	}
	f64 abs_x = f64_abs(x);
	if (abs_x >= ((f64)(0.0001)) && abs_x < ((f64)(1.0e6))) {
		return strconv__f64_to_str_l_with_dot(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string float_literal_str(float_literal d) {
	return f64_str(((f64)(d)));
}
inline string f32_str(f32 x) {
	{ // Unsafe block
		strconv__Float32u f = ((strconv__Float32u){.f = x,});
		if (f.u == _const_strconv__single_minus_zero) {
			return _SLIT("-0.0");
		}
		if (f.u == _const_strconv__single_plus_zero) {
			return _SLIT("0.0");
		}
	}
	f32 abs_x = f32_abs(x);
	if (abs_x >= ((f32)(0.0001)) && abs_x < ((f32)(1.0e6))) {
		return strconv__f32_to_str_l(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string f32_strg(f32 x) {
	if (x == 0) {
		return _SLIT("0.0");
	}
	f32 abs_x = f32_abs(x);
	if (abs_x >= ((f32)(0.0001)) && abs_x < ((f32)(1.0e6))) {
		return strconv__f32_to_str_l_with_dot(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline f32 f32_abs(f32 a) {
	return (a < 0 ? (-a) : (a));
}
inline f64 f64_abs(f64 a) {
	return (a < 0 ? (-a) : (a));
}
inline f64 f64_max(f64 a, f64 b) {
	return (a > b ? (a) : (b));
}
string ptr_str(voidptr ptr) {
	string buf1 = u64_hex(((u64)(ptr)));
	return buf1;
}
string isize_str(isize x) {
	return i64_str(((i64)(x)));
}
string usize_str(usize x) {
	return u64_str(((u64)(x)));
}
string char_str(char* cptr) {
	return u64_hex(((u64)(cptr)));
}
inline VV_LOCAL_SYMBOL string int_str_l(int nn, int max) {
	{ // Unsafe block
		i64 n = ((i64)(nn));
		int d = 0;
		if (n == 0) {
			return _SLIT("0");
		}
		bool is_neg = false;
		if (n < 0) {
			n = -n;
			is_neg = true;
		}
		int index = max;
		u8* buf = malloc_noscan((int)(max + 1));
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			int n1 = ((int)((i64)(n / 100)));
			d = ((int)((((u32)((int)(((int)(n)) - ((int)(n1 * 100))))) << 1U)));
			n = n1;
			buf[index] = _const_digit_pairs.str[d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[d];
			index--;
		}
		index++;
		if (d < 20) {
			index++;
		}
		if (is_neg) {
			index--;
			buf[index] = '-';
		}
		int diff = (int)(max - index);
		vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string i8_str(i8 n) {
	return int_str_l(((int)(n)), 5);
}
string i16_str(i16 n) {
	return int_str_l(((int)(n)), 7);
}
string u16_str(u16 n) {
	return int_str_l(((int)(n)), 7);
}
string i32_str(i32 n) {
	return int_str_l(((int)(n)), 12);
}
string int_str(int n) {
	return int_str_l(n, 12);
}
inline string u32_str(u32 nn) {
	{ // Unsafe block
		u32 n = nn;
		u32 d = ((u32)(0U));
		if (n == 0U) {
			return _SLIT("0");
		}
		int max = 12;
		u8* buf = malloc_noscan((int)(max + 1));
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0U)) break;
			u32 n1 = (u32)(n / ((u32)(100U)));
			d = ((((u32)(n - ((u32)(n1 * ((u32)(100U)))))) << ((u32)(1U))));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < ((u32)(20U))) {
			index++;
		}
		int diff = (int)(max - index);
		vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string int_literal_str(int_literal n) {
	return i64_str(((i64)(n)));
}
inline string i64_str(i64 nn) {
	{ // Unsafe block
		i64 n = nn;
		i64 d = ((i64)(0));
		if (n == 0) {
			return _SLIT("0");
		} else if (n == _const_min_i64) {
			return _SLIT("-9223372036854775808");
		}
		int max = 20;
		u8* buf = malloc_noscan((int)(max + 1));
		bool is_neg = false;
		if (n < 0) {
			n = -n;
			is_neg = true;
		}
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			i64 n1 = (i64)(n / ((i64)(100)));
			d = ((((u32)((i64)(n - ((i64)(n1 * ((i64)(100))))))) << ((i64)(1))));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < ((i64)(20))) {
			index++;
		}
		if (is_neg) {
			index--;
			buf[index] = '-';
		}
		int diff = (int)(max - index);
		vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string u64_str(u64 nn) {
	{ // Unsafe block
		u64 n = nn;
		u64 d = ((u64)(0U));
		if (n == 0U) {
			return _SLIT("0");
		}
		int max = 20;
		u8* buf = malloc_noscan((int)(max + 1));
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0U)) break;
			u64 n1 = (u64)(n / 100U);
			d = ((((u64)(n - ((u64)(n1 * 100U)))) << 1U));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < 20U) {
			index++;
		}
		int diff = (int)(max - index);
		vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string bool_str(bool b) {
	if (b) {
		return _SLIT("true");
	}
	return _SLIT("false");
}
inline VV_LOCAL_SYMBOL string u64_to_hex_no_leading_zeros(u64 nn, u8 len) {
	u64 n = nn;
	Array_fixed_u8_17 buf = {0};
	buf[len] = 0;
	int i = 0;
	for (i = (u8)(len - 1); i >= 0; i--) {
		u8 d = ((u8)((n & 0xFU)));
		buf[i] = (d < 10 ? ((rune)(d + '0')) : ((u8)(d + 87)));
		n = (n >> 4U);
		if (n == 0U) {
			break;
		}
	}
	int res_len = (int)(len - i);
	return tos(memdup(&buf[i], (int)(res_len + 1)), res_len);
}
string u64_hex(u64 nn) {
	if (nn == 0U) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 16);
}
string voidptr_str(voidptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}
string byteptr_str(byteptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}
string charptr_str(charptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}
string u8_str(u8 b) {
	return int_str_l(((int)(b)), 7);
}
string u8_ascii_str(u8 b) {
	string str = ((string){.str = malloc_noscan(2), .len = 1});
	{ // Unsafe block
		str.str[0] = b;
		str.str[1] = 0;
	}
	return str;
}
string Array_u8_bytestr(Array_u8 b) {
	{ // Unsafe block
		u8* buf = malloc_noscan((int)(b.len + 1));
		vmemcpy(buf, b.data, b.len);
		buf[b.len] = 0;
		return tos(buf, b.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOCAL_SYMBOL string _Atomic__int_str(int x) {
	return int_str(x);
}
inline VV_LOCAL_SYMBOL bool fast_string_eq(string a, string b) {
	if (a.len != b.len) {
		return false;
	}
	{ // Unsafe block
		return memcmp(a.str, b.str, b.len) == 0;
	}
	return 0;
}
VV_LOCAL_SYMBOL u64 map_hash_string(voidptr pkey) {
	string key = *((string*)(pkey));
	return wyhash(key.str, ((u64)(key.len)), 0U, ((u64*)(_wyp)));
}
VV_LOCAL_SYMBOL u64 map_hash_int_1(voidptr pkey) {
	return wyhash64(*((u8*)(pkey)), 0U);
}
VV_LOCAL_SYMBOL u64 map_hash_int_2(voidptr pkey) {
	return wyhash64(*((u16*)(pkey)), 0U);
}
VV_LOCAL_SYMBOL u64 map_hash_int_4(voidptr pkey) {
	return wyhash64(*((u32*)(pkey)), 0U);
}
VV_LOCAL_SYMBOL u64 map_hash_int_8(voidptr pkey) {
	return wyhash64(*((u64*)(pkey)), 0U);
}
VV_LOCAL_SYMBOL void DenseArray_zeros_to_end(DenseArray* d) {
	u8* tmp_value = _v_malloc(d->value_bytes);
	u8* tmp_key = _v_malloc(d->key_bytes);
	int count = 0;
	for (int i = 0; i < d->len; ++i) {
		if (DenseArray_has_index(d, i)) {
			{ // Unsafe block
				if (count != i) {
					memcpy(tmp_key, DenseArray_key(d, count), d->key_bytes);
					memcpy(DenseArray_key(d, count), DenseArray_key(d, i), d->key_bytes);
					memcpy(DenseArray_key(d, i), tmp_key, d->key_bytes);
					memcpy(tmp_value, DenseArray_value(d, count), d->value_bytes);
					memcpy(DenseArray_value(d, count), DenseArray_value(d, i), d->value_bytes);
					memcpy(DenseArray_value(d, i), tmp_value, d->value_bytes);
				}
			}
			count++;
		}
	}
	{ // Unsafe block
		_v_free(tmp_value);
		_v_free(tmp_key);
		d->deletes = 0U;
		_v_free(d->all_deleted);
	}
	d->len = count;
	int old_cap = d->cap;
	d->cap = (count < 8 ? (8) : (count));
	{ // Unsafe block
		d->values = realloc_data(d->values, (int)(d->value_bytes * old_cap), (int)(d->value_bytes * d->cap));
		d->keys = realloc_data(d->keys, (int)(d->key_bytes * old_cap), (int)(d->key_bytes * d->cap));
	}
}
inline VV_LOCAL_SYMBOL DenseArray new_dense_array(int key_bytes, int value_bytes) {
	int cap = 8;
	return ((DenseArray){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.cap = cap,
		.len = 0,
		.deletes = 0U,
		.all_deleted = ((void*)0),
		.keys = _v_malloc(__at_least_one((u64)(((u64)(cap)) * ((u64)(key_bytes))))),
		.values = _v_malloc(__at_least_one((u64)(((u64)(cap)) * ((u64)(value_bytes))))),
	});
}
inline VV_LOCAL_SYMBOL voidptr DenseArray_key(DenseArray* d, int i) {
	return ((voidptr)(d->keys + (int)(i * d->key_bytes)));
}
inline VV_LOCAL_SYMBOL voidptr DenseArray_value(DenseArray* d, int i) {
	return ((voidptr)(d->values + (int)(i * d->value_bytes)));
}
inline VV_LOCAL_SYMBOL bool DenseArray_has_index(DenseArray* d, int i) {
	return d->deletes == 0U || d->all_deleted[i] == 0;
}
inline VV_LOCAL_SYMBOL int DenseArray_expand(DenseArray* d) {
	int old_cap = d->cap;
	int old_key_size = (int)(d->key_bytes * old_cap);
	int old_value_size = (int)(d->value_bytes * old_cap);
	if (d->cap == d->len) {
		d->cap += (d->cap >> 3);
		{ // Unsafe block
			d->keys = realloc_data(d->keys, old_key_size, (int)(d->key_bytes * d->cap));
			d->values = realloc_data(d->values, old_value_size, (int)(d->value_bytes * d->cap));
			if (d->deletes != 0U) {
				d->all_deleted = realloc_data(d->all_deleted, old_cap, d->cap);
				vmemset(((voidptr)(d->all_deleted + d->len)), 0, (int)(d->cap - d->len));
			}
		}
	}
	int push_index = d->len;
	{ // Unsafe block
		if (d->deletes != 0U) {
			d->all_deleted[push_index] = 0;
		}
	}
	d->len++;
	return push_index;
}
inline VV_LOCAL_SYMBOL bool map_eq_string(voidptr a, voidptr b) {
	return fast_string_eq(*((string*)(a)), *((string*)(b)));
}
inline VV_LOCAL_SYMBOL bool map_eq_int_1(voidptr a, voidptr b) {
	return *((u8*)(a)) == *((u8*)(b));
}
inline VV_LOCAL_SYMBOL bool map_eq_int_2(voidptr a, voidptr b) {
	return *((u16*)(a)) == *((u16*)(b));
}
inline VV_LOCAL_SYMBOL bool map_eq_int_4(voidptr a, voidptr b) {
	return *((u32*)(a)) == *((u32*)(b));
}
inline VV_LOCAL_SYMBOL bool map_eq_int_8(voidptr a, voidptr b) {
	return *((u64*)(a)) == *((u64*)(b));
}
inline VV_LOCAL_SYMBOL void map_clone_string(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		string s = *((string*)(pkey));
		*((string*)(dest)) = string_clone(s);
	}
}
inline VV_LOCAL_SYMBOL void map_clone_int_1(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u8*)(dest)) = *((u8*)(pkey));
	}
}
inline VV_LOCAL_SYMBOL void map_clone_int_2(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u16*)(dest)) = *((u16*)(pkey));
	}
}
inline VV_LOCAL_SYMBOL void map_clone_int_4(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u32*)(dest)) = *((u32*)(pkey));
	}
}
inline VV_LOCAL_SYMBOL void map_clone_int_8(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u64*)(dest)) = *((u64*)(pkey));
	}
}
inline VV_LOCAL_SYMBOL void map_free_string(voidptr pkey) {
	string_free(ADDR(string, (*((string*)(pkey)))));
}
inline VV_LOCAL_SYMBOL void map_free_nop(voidptr _d1) {
}
VV_LOCAL_SYMBOL map new_map(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr )) {
	int metasize = ((int)((u32)(sizeof(u32) * ((int_literal)(_const_init_capicity + _const_extra_metas_inc)))));
	bool has_string_keys = _us32_lt(sizeof(voidptr),key_bytes);
	return ((map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array(key_bytes, value_bytes),
		.metas = ((u32*)(vcalloc_noscan(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = (voidptr)hash_fn,
		.key_eq_fn = (voidptr)key_eq_fn,
		.clone_fn = (voidptr)clone_fn,
		.free_fn = (voidptr)free_fn,
		.len = 0,
	});
}
VV_LOCAL_SYMBOL map new_map_init(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = new_map(key_bytes, value_bytes, (voidptr)hash_fn, (voidptr)key_eq_fn, (voidptr)clone_fn, (voidptr)free_fn);
	u8* pkey = ((u8*)(keys));
	u8* pval = ((u8*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}
VV_LOCAL_SYMBOL map new_map_update_init(map* update, int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = map_clone(update);
	u8* pkey = ((u8*)(keys));
	u8* pval = ((u8*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}
map map_move(map* m) {
	map r = *m;
	vmemset(m, 0, ((int)(sizeof(map))));
	return r;
}
void map_clear(map* m) {
	{ // Unsafe block
		if (m->key_values.all_deleted != 0) {
			_v_free(m->key_values.all_deleted);
			m->key_values.all_deleted = ((void*)0);
		}
		vmemset(m->key_values.keys, 0, (int)(m->key_values.key_bytes * m->key_values.cap));
		vmemset(m->metas, 0, (u32)(sizeof(u32) * ((u32)((u32)(m->even_index + 2U) + m->extra_metas))));
	}
	m->key_values.len = 0;
	m->key_values.deletes = 0U;
	m->even_index = _const_init_even_index;
	m->cached_hashbits = _const_max_cached_hashbits;
	m->shift = _const_init_log_capicity;
	m->len = 0;
}
inline VV_LOCAL_SYMBOL multi_return_u32_u32 map_key_to_index(map* m, voidptr pkey) {
	u64 hash = m->hash_fn(pkey);
	u64 index = (hash & m->even_index);
	u64 meta = (((((hash >> m->shift)) & _const_hash_mask)) | _const_probe_inc);
	return (multi_return_u32_u32){.arg0=((u32)(index)), .arg1=((u32)(meta))};
}
inline VV_LOCAL_SYMBOL multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas) {
	u32 index = _index;
	u32 meta = _metas;
	for (;;) {
		if (!(meta < m->metas[index])) break;
		index += 2U;
		meta += _const_probe_inc;
	}
	return (multi_return_u32_u32){.arg0=index, .arg1=meta};
}
inline VV_LOCAL_SYMBOL void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi) {
	u32 meta = _metas;
	u32 index = _index;
	u32 kv_index = kvi;
	for (;;) {
		if (!(m->metas[index] != 0U)) break;
		if (meta > m->metas[index]) {
			{ // Unsafe block
				u32 tmp_meta = m->metas[index];
				m->metas[index] = meta;
				meta = tmp_meta;
				u32 tmp_index = m->metas[(u32)(index + 1U)];
				m->metas[(u32)(index + 1U)] = kv_index;
				kv_index = tmp_index;
			}
		}
		index += 2U;
		meta += _const_probe_inc;
	}
	{ // Unsafe block
		m->metas[index] = meta;
		m->metas[(u32)(index + 1U)] = kv_index;
	}
	u32 probe_count = (u32)(((meta >> _const_hashbits)) - 1U);
	map_ensure_extra_metas(m, probe_count);
}
inline VV_LOCAL_SYMBOL void map_ensure_extra_metas(map* m, u32 probe_count) {
	if (((probe_count << 1U)) == m->extra_metas) {
		u32 size_of_u32 = sizeof(u32);
		u32 old_mem_size = ((u32)((u32)(m->even_index + 2U) + m->extra_metas));
		m->extra_metas += _const_extra_metas_inc;
		u32 mem_size = ((u32)((u32)(m->even_index + 2U) + m->extra_metas));
		{ // Unsafe block
			u8* x = realloc_data(((u8*)(m->metas)), ((int)((u32)(size_of_u32 * old_mem_size))), ((int)((u32)(size_of_u32 * mem_size))));
			m->metas = ((u32*)(x));
			vmemset(m->metas + mem_size - _const_extra_metas_inc, 0, ((int)((u32)(sizeof(u32) * _const_extra_metas_inc))));
		}
		if (probe_count == 252U) {
			_v_panic(_SLIT("Probe overflow"));
			VUNREACHABLE();
		}
	}
}
VV_LOCAL_SYMBOL void map_set(map* m, voidptr key, voidptr value) {
	f32 load_factor = (f32)(((f32)((((u32)(m->len)) << 1U))) / ((f32)(m->even_index)));
	if (load_factor > ((f32)(_const_max_load_factor))) {
		map_expand(m);
	}
	multi_return_u32_u32 mr_12308 = map_key_to_index(m, key);
	u32 index = mr_12308.arg0;
	u32 meta = mr_12308.arg1;
	multi_return_u32_u32 mr_12344 = map_meta_less(m, index, meta);
	index = mr_12344.arg0;
	meta = mr_12344.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			{ // Unsafe block
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				vmemcpy(pval, value, m->value_bytes);
			}
			return;
		}
		index += 2U;
		meta += _const_probe_inc;
	}
	int kv_index = DenseArray_expand(&m->key_values);
	{ // Unsafe block
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		voidptr pvalue = DenseArray_value(&m->key_values, kv_index);
		m->clone_fn(pkey, key);
		vmemcpy(((u8*)(pvalue)), value, m->value_bytes);
	}
	map_meta_greater(m, index, meta, ((u32)(kv_index)));
	m->len++;
}
VV_LOCAL_SYMBOL void map_expand(map* m) {
	u32 old_cap = m->even_index;
	m->even_index = (u32)(((((u32)(m->even_index + 2U)) << 1U)) - 2U);
	if (m->cached_hashbits == 0) {
		m->shift += _const_max_cached_hashbits;
		m->cached_hashbits = _const_max_cached_hashbits;
		map_rehash(m);
	} else {
		map_cached_rehash(m, old_cap);
		m->cached_hashbits--;
	}
}
VV_LOCAL_SYMBOL void map_rehash(map* m) {
	u32 meta_bytes = (u32)(sizeof(u32) * ((u32)((u32)(m->even_index + 2U) + m->extra_metas)));
	map_reserve(m, meta_bytes);
}
void map_reserve(map* m, u32 meta_bytes) {
	{ // Unsafe block
		u8* x = v_realloc(((u8*)(m->metas)), ((int)(meta_bytes)));
		m->metas = ((u32*)(x));
		vmemset(m->metas, 0, ((int)(meta_bytes)));
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		voidptr pkey = DenseArray_key(&m->key_values, i);
		multi_return_u32_u32 mr_14118 = map_key_to_index(m, pkey);
		u32 index = mr_14118.arg0;
		u32 meta = mr_14118.arg1;
		multi_return_u32_u32 mr_14156 = map_meta_less(m, index, meta);
		index = mr_14156.arg0;
		meta = mr_14156.arg1;
		map_meta_greater(m, index, meta, ((u32)(i)));
	}
}
VV_LOCAL_SYMBOL void map_cached_rehash(map* m, u32 old_cap) {
	u32* old_metas = m->metas;
	int metasize = ((int)((u32)(sizeof(u32) * ((u32)((u32)(m->even_index + 2U) + m->extra_metas)))));
	m->metas = ((u32*)(vcalloc(metasize)));
	u32 old_extra_metas = m->extra_metas;
	for (u32 i = ((u32)(0U)); i <= (u32)(old_cap + old_extra_metas); i += 2U) {
		if (old_metas[i] == 0U) {
			continue;
		}
		u32 old_meta = old_metas[i];
		u32 old_probe_count = (((u32)(((old_meta >> _const_hashbits)) - 1U)) << 1U);
		u32 old_index = (((u32)(i - old_probe_count)) & ((m->even_index >> 1U)));
		u32 index = (((old_index | ((old_meta << m->shift)))) & m->even_index);
		u32 meta = (((old_meta & _const_hash_mask)) | _const_probe_inc);
		multi_return_u32_u32 mr_14955 = map_meta_less(m, index, meta);
		index = mr_14955.arg0;
		meta = mr_14955.arg1;
		u32 kv_index = old_metas[(u32)(i + 1U)];
		map_meta_greater(m, index, meta, kv_index);
	}
	_v_free(old_metas);
}
VV_LOCAL_SYMBOL voidptr map_get_and_set(map* m, voidptr key, voidptr zero) {
	for (;;) {
		multi_return_u32_u32 mr_15403 = map_key_to_index(m, key);
		u32 index = mr_15403.arg0;
		u32 meta = mr_15403.arg1;
		for (;;) {
			if (meta == m->metas[index]) {
				int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
				voidptr pkey = DenseArray_key(&m->key_values, kv_index);
				if (m->key_eq_fn(key, pkey)) {
					voidptr pval = DenseArray_value(&m->key_values, kv_index);
					return ((u8*)(pval));
				}
			}
			index += 2U;
			meta += _const_probe_inc;
			if (meta > m->metas[index]) {
				break;
			}
		}
		map_set(m, key, zero);
	}
	return ((void*)0);
}
VV_LOCAL_SYMBOL voidptr map_get(map* m, voidptr key, voidptr zero) {
	multi_return_u32_u32 mr_16130 = map_key_to_index(m, key);
	u32 index = mr_16130.arg0;
	u32 meta = mr_16130.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				return ((u8*)(pval));
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return zero;
}
VV_LOCAL_SYMBOL voidptr map_get_check(map* m, voidptr key) {
	multi_return_u32_u32 mr_16795 = map_key_to_index(m, key);
	u32 index = mr_16795.arg0;
	u32 meta = mr_16795.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				return ((u8*)(pval));
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return 0;
}
VV_LOCAL_SYMBOL bool map_exists(map* m, voidptr key) {
	multi_return_u32_u32 mr_17305 = map_key_to_index(m, key);
	u32 index = mr_17305.arg0;
	u32 meta = mr_17305.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				return true;
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return false;
}
inline VV_LOCAL_SYMBOL void DenseArray_delete(DenseArray* d, int i) {
	if (d->deletes == 0U) {
		d->all_deleted = vcalloc(d->cap);
	}
	d->deletes++;
	{ // Unsafe block
		d->all_deleted[i] = 1;
	}
}
void map_delete(map* m, voidptr key) {
	multi_return_u32_u32 mr_17943 = map_key_to_index(m, key);
	u32 index = mr_17943.arg0;
	u32 meta = mr_17943.arg1;
	multi_return_u32_u32 mr_17979 = map_meta_less(m, index, meta);
	index = mr_17979.arg0;
	meta = mr_17979.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			for (;;) {
				if (!(((m->metas[(u32)(index + 2U)] >> _const_hashbits)) > 1U)) break;
				{ // Unsafe block
					m->metas[index] = (u32)(m->metas[(u32)(index + 2U)] - _const_probe_inc);
					m->metas[(u32)(index + 1U)] = m->metas[(u32)(index + 3U)];
				}
				index += 2U;
			}
			m->len--;
			DenseArray_delete(&m->key_values, kv_index);
			{ // Unsafe block
				m->metas[index] = 0U;
				m->free_fn(pkey);
				vmemset(pkey, 0, m->key_bytes);
			}
			if (m->key_values.len <= 32) {
				return;
			}
			if (_us32_ge(m->key_values.deletes,((m->key_values.len >> 1)))) {
				DenseArray_zeros_to_end(&m->key_values);
				map_rehash(m);
			}
			return;
		}
		index += 2U;
		meta += _const_probe_inc;
	}
}
array map_keys(map* m) {
	array keys = __new_array(m->len, 0, m->key_bytes);
	u8* item = ((u8*)(keys.data));
	if (m->key_values.deletes == 0U) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->clone_fn(item, pkey);
				item = item + m->key_bytes;
			}
		}
		return keys;
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		{ // Unsafe block
			voidptr pkey = DenseArray_key(&m->key_values, i);
			m->clone_fn(item, pkey);
			item = item + m->key_bytes;
		}
	}
	return keys;
}
array map_values(map* m) {
	array values = __new_array(m->len, 0, m->value_bytes);
	u8* item = ((u8*)(values.data));
	if (m->key_values.deletes == 0U) {
		vmemcpy(item, m->key_values.values, (int)(m->value_bytes * m->key_values.len));
		return values;
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		{ // Unsafe block
			voidptr pvalue = DenseArray_value(&m->key_values, i);
			vmemcpy(item, pvalue, m->value_bytes);
			item = item + m->value_bytes;
		}
	}
	return values;
}
VV_LOCAL_SYMBOL DenseArray DenseArray_clone(DenseArray* d) {
	DenseArray res = ((DenseArray){
		.key_bytes = d->key_bytes,
		.value_bytes = d->value_bytes,
		.cap = d->cap,
		.len = d->len,
		.deletes = d->deletes,
		.all_deleted = ((void*)0),
		.keys = ((void*)0),
		.values = ((void*)0),
	});
	{ // Unsafe block
		if (d->deletes != 0U) {
			res.all_deleted = memdup(d->all_deleted, d->cap);
		}
		res.keys = memdup(d->keys, (int)(d->cap * d->key_bytes));
		res.values = memdup(d->values, (int)(d->cap * d->value_bytes));
	}
	return res;
}
map map_clone(map* m) {
	int metasize = ((int)((u32)(sizeof(u32) * ((u32)((u32)(m->even_index + 2U) + m->extra_metas)))));
	map res = ((map){
		.key_bytes = m->key_bytes,
		.value_bytes = m->value_bytes,
		.even_index = m->even_index,
		.cached_hashbits = m->cached_hashbits,
		.shift = m->shift,
		.key_values = DenseArray_clone(&m->key_values),
		.metas = ((u32*)(malloc_noscan(metasize))),
		.extra_metas = m->extra_metas,
		.has_string_keys = m->has_string_keys,
		.hash_fn = (voidptr)m->hash_fn,
		.key_eq_fn = (voidptr)m->key_eq_fn,
		.clone_fn = (voidptr)m->clone_fn,
		.free_fn = (voidptr)m->free_fn,
		.len = m->len,
	});
	vmemcpy(res.metas, m->metas, metasize);
	if (!m->has_string_keys) {
		return res;
	}
	for (int i = 0; i < m->key_values.len; ++i) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		m->clone_fn(DenseArray_key(&res.key_values, i), DenseArray_key(&m->key_values, i));
	}
	return res;
}
void map_free(map* m) {
	_v_free(m->metas);
	{ // Unsafe block
		m->metas = ((void*)0);
	}
	if (m->key_values.deletes == 0U) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
				vmemset(pkey, 0, m->key_bytes);
			}
		}
	} else {
		for (int i = 0; i < m->key_values.len; i++) {
			if (!DenseArray_has_index(&m->key_values, i)) {
				continue;
			}
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
				vmemset(pkey, 0, m->key_bytes);
			}
		}
	}
	{ // Unsafe block
		if (m->key_values.all_deleted != ((void*)0)) {
			_v_free(m->key_values.all_deleted);
			m->key_values.all_deleted = ((void*)0);
		}
		if (m->key_values.keys != ((void*)0)) {
			_v_free(m->key_values.keys);
			m->key_values.keys = ((void*)0);
		}
		if (m->key_values.values != ((void*)0)) {
			_v_free(m->key_values.values);
			m->key_values.values = ((void*)0);
		}
		m->hash_fn = (voidptr)((void*)0);
		m->key_eq_fn = (voidptr)((void*)0);
		m->clone_fn = (voidptr)((void*)0);
		m->free_fn = (voidptr)((void*)0);
	}
}
inline VV_LOCAL_SYMBOL u8* __malloc_at_least_one(u64 how_many_bytes, bool noscan) {
	if (noscan) {
		return malloc_noscan(__at_least_one(how_many_bytes));
	}
	return _v_malloc(__at_least_one(how_many_bytes));
}
inline VV_LOCAL_SYMBOL DenseArray new_dense_array_noscan(int key_bytes, bool key_noscan, int value_bytes, bool value_noscan) {
	int cap = 8;
	return ((DenseArray){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.cap = cap,
		.len = 0,
		.deletes = 0U,
		.all_deleted = ((void*)0),
		.keys = __malloc_at_least_one((u64)(((u64)(cap)) * ((u64)(key_bytes))), key_noscan),
		.values = __malloc_at_least_one((u64)(((u64)(cap)) * ((u64)(value_bytes))), value_noscan),
	});
}
VV_LOCAL_SYMBOL map new_map_noscan_key(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr )) {
	int metasize = ((int)((u32)(sizeof(u32) * ((int_literal)(_const_init_capicity + _const_extra_metas_inc)))));
	bool has_string_keys = _us32_lt(sizeof(voidptr),key_bytes);
	return ((map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array_noscan(key_bytes, true, value_bytes, false),
		.metas = ((u32*)(vcalloc_noscan(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = (voidptr)hash_fn,
		.key_eq_fn = (voidptr)key_eq_fn,
		.clone_fn = (voidptr)clone_fn,
		.free_fn = (voidptr)free_fn,
		.len = 0,
	});
}
VV_LOCAL_SYMBOL map new_map_noscan_value(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr )) {
	int metasize = ((int)((u32)(sizeof(u32) * ((int_literal)(_const_init_capicity + _const_extra_metas_inc)))));
	bool has_string_keys = _us32_lt(sizeof(voidptr),key_bytes);
	return ((map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array_noscan(key_bytes, false, value_bytes, true),
		.metas = ((u32*)(vcalloc_noscan(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = (voidptr)hash_fn,
		.key_eq_fn = (voidptr)key_eq_fn,
		.clone_fn = (voidptr)clone_fn,
		.free_fn = (voidptr)free_fn,
		.len = 0,
	});
}
VV_LOCAL_SYMBOL map new_map_noscan_key_value(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr )) {
	int metasize = ((int)((u32)(sizeof(u32) * ((int_literal)(_const_init_capicity + _const_extra_metas_inc)))));
	bool has_string_keys = _us32_lt(sizeof(voidptr),key_bytes);
	return ((map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array_noscan(key_bytes, true, value_bytes, true),
		.metas = ((u32*)(vcalloc_noscan(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = (voidptr)hash_fn,
		.key_eq_fn = (voidptr)key_eq_fn,
		.clone_fn = (voidptr)clone_fn,
		.free_fn = (voidptr)free_fn,
		.len = 0,
	});
}
VV_LOCAL_SYMBOL map new_map_init_noscan_key(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = new_map_noscan_key(key_bytes, value_bytes, (voidptr)hash_fn, (voidptr)key_eq_fn, (voidptr)clone_fn, (voidptr)free_fn);
	u8* pkey = ((u8*)(keys));
	u8* pval = ((u8*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}
VV_LOCAL_SYMBOL map new_map_init_noscan_value(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = new_map_noscan_value(key_bytes, value_bytes, (voidptr)hash_fn, (voidptr)key_eq_fn, (voidptr)clone_fn, (voidptr)free_fn);
	u8* pkey = ((u8*)(keys));
	u8* pval = ((u8*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}
VV_LOCAL_SYMBOL map new_map_init_noscan_key_value(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = new_map_noscan_key_value(key_bytes, value_bytes, (voidptr)hash_fn, (voidptr)key_eq_fn, (voidptr)clone_fn, (voidptr)free_fn);
	u8* pkey = ((u8*)(keys));
	u8* pval = ((u8*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}
void IError_free(IError* ie) {
	{ // Unsafe block
		IError* cie = ((IError*)(ie));
		_v_free(cie->_object);
	}
}
VV_LOCAL_SYMBOL void _option_none(voidptr data, _option* option, int size) {
	{ // Unsafe block
		*option = ((_option){.state = 2,.err = _const_none__,});
		vmemcpy(((u8*)(&option->err)) + sizeof(IError), data, size);
	}
}
VV_LOCAL_SYMBOL void _option_ok(voidptr data, _option* option, int size) {
	{ // Unsafe block
		*option = ((_option){.state = 0,.err = _const_none__,});
		vmemcpy(((u8*)(&option->err)) + sizeof(IError), data, size);
	}
}
VV_LOCAL_SYMBOL void _option_clone(_option* current, _option* option, int size) {
	{ // Unsafe block
		*option = ((_option){.state = current->state,.err = current->err,});
		vmemcpy(((u8*)(&option->err)) + sizeof(IError), ((u8*)(&current->err)) + sizeof(IError), size);
	}
}
VV_LOCAL_SYMBOL string None___str(None__ _d1) {
	return _SLIT("none");
}
string none_str(none _d1) {
	return _SLIT("none");
}
VV_LOCAL_SYMBOL void _result_ok(voidptr data, _result* res, int size) {
	{ // Unsafe block
		*res = ((_result){.is_error = 0,.err = _const_none__,});
		vmemcpy(((u8*)(&res->err)) + sizeof(IError), data, size);
	}
}
string IError_str(IError err) {
	return ((err._typ == _IError_None___index)? (_SLIT("none")) : (err._typ == _IError_Error_index)? (Error_msg(*(err._Error))) : (err._typ == _IError_MessageError_index)? (MessageError_str((*(err._MessageError)))) : (str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = charptr_vstring_literal(v_typeof_interface_IError( (err)._typ ))}}, {_SLIT(": "), 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT0, 0, { .d_c = 0 }}}))));
}
string Error_msg(Error err) {
	return _SLIT("");
}
int Error_code(Error err) {
	return 0;
}
string MessageError_str(MessageError err) {
	if (err.code > 0) {
		return str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = err.msg}}, {_SLIT("; code: "), 0xfe07, {.d_i32 = err.code}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return err.msg;
}
string MessageError_msg(MessageError err) {
	return err.msg;
}
int MessageError_code(MessageError err) {
	return err.code;
}
void MessageError_free(MessageError* err) {
	string_free(&err->msg);
}
inline IError _v_error(string message) {
	;
	return I_MessageError_to_Interface_IError(((MessageError*)memdup(&(MessageError){.msg = message,.code = 0,}, sizeof(MessageError))));
}
inline IError error_with_code(string message, int code) {
	;
	return I_MessageError_to_Interface_IError(((MessageError*)memdup(&(MessageError){.msg = message,.code = code,}, sizeof(MessageError))));
}
string rune_str(rune c) {
	return utf32_to_str(((u32)(c)));
}
string Array_rune_string(Array_rune ra) {
	strings__Builder sb = strings__new_builder(ra.len);
	strings__Builder_write_runes(&sb, ra);
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
rune rune_to_upper(rune c) {
	if (c < 0x80) {
		if (c >= 'a' && c <= 'z') {
			return (rune)(c - 32);
		}
		return c;
	}
	return rune_map_to(c, MapMode__to_upper);
}
rune rune_to_lower(rune c) {
	if (c < 0x80) {
		if (c >= 'A' && c <= 'Z') {
			return (rune)(c + 32);
		}
		return c;
	}
	return rune_map_to(c, MapMode__to_lower);
}
VV_LOCAL_SYMBOL rune rune_map_to(rune c, MapMode mode) {
	int start = 0;
	int end = (int)(1264 / _const_rune_maps_columns_in_row);
	for (;;) {
		if (!(start < end)) break;
		int middle = (int)(((int)(start + end)) / 2);
		i32* cur_map = &_const_rune_maps[(int)(middle * _const_rune_maps_columns_in_row)];
		if (c >= ((u32)(*cur_map)) && c <= ((u32)(*(cur_map + 1)))) {
			i32 offset = ((mode == MapMode__to_upper || mode == MapMode__to_title) ? (*(cur_map + 2)) : (*(cur_map + 3)));
			if (offset == _const_rune_maps_ul) {
				rune cnt = (rune)(((rune)(c - *cur_map)) % 2);
				if (mode == MapMode__to_lower) {
					return (rune)((rune)(c + 1) - cnt);
				}
				return (rune)(c - cnt);
			} else if (offset == _const_rune_maps_utl) {
				rune cnt = (rune)(((rune)(c - *cur_map)) % 3);
				if (mode == MapMode__to_upper) {
					return (rune)(c - cnt);
				} else if (mode == MapMode__to_lower) {
					return (rune)((rune)(c + 2) - cnt);
				}
				return (rune)((rune)(c + 1) - cnt);
			}
			return (rune)(c + offset);
		}
		if (c < ((u32)(*cur_map))) {
			end = middle;
		} else {
			start = (int)(middle + 1);
		}
	}
	return c;
}
VV_LOCAL_SYMBOL void mapnode_free(mapnode* n) {
	println(_SLIT("TODO"));
}
void SortedMap_free(SortedMap* m) {
	if (m->root == ((void*)0)) {
		return;
	}
	mapnode_free(m->root);
}
Array_rune string_runes(string s) {
	Array_rune runes = __new_array_with_default_noscan(0, s.len, sizeof(rune), 0);
	for (int i = 0; i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		if (char_len > 1) {
			int end = ((int)(s.len - 1) >= (int)(i + char_len) ? ((int)(i + char_len)) : (s.len));
			string r = string_substr(s, i, end);
			array_push_noscan((array*)&runes, _MOV((rune[]){ string_utf32_code(r) }));
			i += (int)(char_len - 1);
		} else {
			array_push_noscan((array*)&runes, _MOV((rune[]){ s.str[i] }));
		}
	}
	return runes;
}
string cstring_to_vstring(const char* const_s) {
	return string_clone(tos2(((u8*)(const_s))));
}
string tos_clone(const u8* const_s) {
	return string_clone(tos2(((u8*)(const_s))));
}
string tos(u8* s, int len) {
	if (s == 0) {
		_v_panic(_SLIT("tos(): nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = s, .len = len});
}
string tos2(u8* s) {
	if (s == 0) {
		_v_panic(_SLIT("tos2: nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = s, .len = vstrlen(s)});
}
string tos3(char* s) {
	if (s == 0) {
		_v_panic(_SLIT("tos3: nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = ((u8*)(s)), .len = vstrlen_char(s)});
}
string tos4(u8* s) {
	if (s == 0) {
		return _SLIT("");
	}
	return ((string){.str = s, .len = vstrlen(s)});
}
string tos5(char* s) {
	if (s == 0) {
		return _SLIT("");
	}
	return ((string){.str = ((u8*)(s)), .len = vstrlen_char(s)});
}
string u8_vstring(u8* bp) {
	return ((string){.str = bp, .len = vstrlen(bp)});
}
string u8_vstring_with_len(u8* bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 0});
}
string char_vstring(char* cp) {
	return ((string){.str = ((u8*)(cp)), .len = vstrlen_char(cp), .is_lit = 0});
}
string u8_vstring_literal_with_len(u8* bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 1});
}
string char_vstring_literal_with_len(char* cp, int len) {
	return ((string){.str = ((u8*)(cp)), .len = len, .is_lit = 1});
}
bool string_is_pure_ascii(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[ i] >= 0x80) {
			return false;
		}
	}
	return true;
}
inline VV_LOCAL_SYMBOL string string_clone_static(string a) {
	return string_clone(a);
}
string string_clone(string a) {
	if (a.len <= 0) {
		return _SLIT("");
	}
	string b = ((string){.str = malloc_noscan((int)(a.len + 1)), .len = a.len});
	{ // Unsafe block
		vmemcpy(b.str, a.str, a.len);
		b.str[a.len] = 0;
	}
	return b;
}
string string_replace(string s, string rep, string with) {
	bool string_replace_defer_0 = false;
	int pidxs_cap;
	int* pidxs;
	if (s.len == 0 || rep.len == 0 || rep.len > s.len) {
		return string_clone(s);
	}
	if (!string_contains(s, rep)) {
		return string_clone(s);
	}
	int pidxs_len = 0;
	pidxs_cap = (int)(s.len / rep.len);
	Array_fixed_int_10 stack_idxs = {0};
	pidxs = &stack_idxs[0];
	if (pidxs_cap > _const_replace_stack_buffer_size) {
		pidxs = ((int*)(_v_malloc((int)(((int)(sizeof(int))) * pidxs_cap))));
	}
	string_replace_defer_0 = true;
	int idx = 0;
	for (;;) {
		idx = string_index_after_(s, rep, idx);
		if (idx == -1) {
			break;
		}
		{ // Unsafe block
			pidxs[pidxs_len] = idx;
			pidxs_len++;
		}
		idx += rep.len;
	}
	if (pidxs_len == 0) {
		string _t3 = string_clone(s);
		// Defer begin
		if (string_replace_defer_0) {
			if (pidxs_cap > _const_replace_stack_buffer_size) {
				_v_free(pidxs);
			}
		}
		// Defer end
		return _t3;
	}
	int new_len = (int)(s.len + (int)(pidxs_len * ((int)(with.len - rep.len))));
	u8* b = malloc_noscan((int)(new_len + 1));
	int b_i = 0;
	int s_idx = 0;
	for (int j = 0; j < pidxs_len; ++j) {
		int rep_pos = pidxs[j];
		int before_len = (int)(rep_pos - s_idx);
		vmemcpy(&b[b_i], &s.str[ s_idx], before_len);
		b_i += before_len;
		s_idx = (int)(rep_pos + rep.len);
		vmemcpy(&b[b_i], &with.str[ 0], with.len);
		b_i += with.len;
	}
	if (s_idx < s.len) {
		vmemcpy(&b[b_i], &s.str[ s_idx], (int)(s.len - s_idx));
	}
	{ // Unsafe block
		b[new_len] = 0;
		string _t4 = tos(b, new_len);
		// Defer begin
		if (string_replace_defer_0) {
			if (pidxs_cap > _const_replace_stack_buffer_size) {
				_v_free(pidxs);
			}
		}
		// Defer end
		return _t4;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string string_replace_each(string s, Array_string vals) {
	if (s.len == 0 || vals.len == 0) {
		return string_clone(s);
	}
	if ((int)(vals.len % 2) != 0) {
		eprintln(_SLIT("string.replace_each(): odd number of strings"));
		return string_clone(s);
	}
	int new_len = s.len;
	Array_RepIndex idxs = __new_array_with_default_noscan(0, 6, sizeof(RepIndex), 0);
	int idx = 0;
	string s_ = string_clone(s);
	for (int rep_i = 0; rep_i < vals.len; rep_i += 2) {
		string rep = ((string*)vals.data)[rep_i];
		string with = ((string*)vals.data)[(int)(rep_i + 1)];
		for (;;) {
			idx = string_index_after_(s_, rep, idx);
			if (idx == -1) {
				break;
			}
			for (int i = 0; i < rep.len; ++i) {
				{ // Unsafe block
					s_.str[(int)(idx + i)] = 0;
				}
			}
			array_push_noscan((array*)&idxs, _MOV((RepIndex[]){ ((RepIndex){.idx = idx,.val_idx = rep_i,}) }));
			idx += rep.len;
			new_len += (int)(with.len - rep.len);
		}
	}
	if (idxs.len == 0) {
		return string_clone(s);
	}
	if (idxs.len > 0) { qsort(idxs.data, idxs.len, idxs.element_size, (voidptr)compare_3040552254790933403_RepIndex_by_idx); };
	u8* b = malloc_noscan((int)(new_len + 1));
	int idx_pos = 0;
	RepIndex cur_idx = ((RepIndex*)idxs.data)[idx_pos];
	int b_i = 0;
	for (int i = 0; i < s.len; i++) {
		if (i == cur_idx.idx) {
			string rep = ((string*)vals.data)[cur_idx.val_idx];
			string with = ((string*)vals.data)[(int)(cur_idx.val_idx + 1)];
			for (int j = 0; j < with.len; ++j) {
				{ // Unsafe block
					b[b_i] = with.str[ j];
				}
				b_i++;
			}
			i += (int)(rep.len - 1);
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = ((RepIndex*)idxs.data)[idx_pos];
			}
		} else {
			{ // Unsafe block
				b[b_i] = s.str[i];
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = 0;
		return tos(b, new_len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline int string_int(string s) {
	_result_i64 _t2 = strconv__common_parse_int(s, 0, 32, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return ((int)((*(i64*)_t2.data)));
}
inline i64 string_i64(string s) {
	_result_i64 _t2 = strconv__common_parse_int(s, 0, 64, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return (*(i64*)_t2.data);
}
inline u8 string_u8(string s) {
	_result_u64 _t2 = strconv__common_parse_uint(s, 0, 8, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return ((u8)((*(u64*)_t2.data)));
}
inline u64 string_u64(string s) {
	_result_u64 _t2 = strconv__common_parse_uint(s, 0, 64, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return (*(u64*)_t2.data);
}
VV_LOCAL_SYMBOL bool string__eq(string s, string a) {
	if (s.str == 0) {
		_v_panic(_SLIT("string.eq(): nil string"));
		VUNREACHABLE();
	}
	if (s.len != a.len) {
		return false;
	}
	{ // Unsafe block
		return vmemcmp(s.str, a.str, a.len) == 0;
	}
	return 0;
}
VV_LOCAL_SYMBOL bool string__lt(string s, string a) {
	for (int i = 0; i < s.len; ++i) {
		if (i >= a.len || s.str[ i] > a.str[ i]) {
			return false;
		} else if (s.str[ i] < a.str[ i]) {
			return true;
		}
	}
	if (s.len < a.len) {
		return true;
	}
	return false;
}
VV_LOCAL_SYMBOL string string__plus(string s, string a) {
	int new_len = (int)(a.len + s.len);
	string res = ((string){.str = malloc_noscan((int)(new_len + 1)), .len = new_len});
	{ // Unsafe block
		vmemcpy(res.str, s.str, s.len);
		vmemcpy(res.str + s.len, a.str, a.len);
	}
	{ // Unsafe block
		res.str[new_len] = 0;
	}
	return res;
}
inline Array_string string_split(string s, string delim) {
	return string_split_nth(s, delim, 0);
}
_option_multi_return_string_string string_split_once(string s, string delim) {
	Array_string result = string_split_nth(s, delim, 2);
	if (result.len != 2) {
		_option_multi_return_string_string _t1 = (_option_multi_return_string_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		return _t1;
	}
	_option_multi_return_string_string _t2;
	_option_ok(&(multi_return_string_string[]) { (multi_return_string_string){.arg0=(*(string*)array_get(result, 0)), .arg1=(*(string*)array_get(result, 1))} }, (_option*)(&_t2), sizeof(multi_return_string_string));
	return _t2;
}
Array_string string_split_nth(string s, string delim, int nth) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	switch (delim.len) {
		case 0: {
				for (int i = 0; i < s.len; ++i) {
					u8 ch = s.str[i];
					if (nth > 0 && res.len == (int)(nth - 1)) {
						array_push((array*)&res, _MOV((string[]){ string_substr(s, i, 2147483647) }));
						break;
					}
					array_push((array*)&res, _MOV((string[]){ u8_ascii_str(ch) }));
				}
				break;
		}
		case 1: {
				u8 delim_byte = delim.str[ 0];
				int start = 0;
				for (int i = 0; i < s.len; ++i) {
					u8 ch = s.str[i];
					if (ch == delim_byte) {
						if (nth > 0 && res.len == (int)(nth - 1)) {
							break;
						}
						array_push((array*)&res, _MOV((string[]){ string_substr(s, start, i) }));
						start = (int)(i + 1);
					}
				}
				if (nth < 1 || res.len < nth) {
					array_push((array*)&res, _MOV((string[]){ string_substr(s, start, 2147483647) }));
				}
				break;
		}
		default: {
				int start = 0;
				for (int i = 0; (int)(i + delim.len) <= s.len; ) {
					if (string__eq(string_substr_unsafe(s, i, (int)(i + delim.len)), delim)) {
						if (nth > 0 && res.len == (int)(nth - 1)) {
							break;
						}
						array_push((array*)&res, _MOV((string[]){ string_substr(s, start, i) }));
						i += delim.len;
						start = i;
					} else {
						i++;
					}
				}
				if (nth < 1 || res.len < nth) {
					array_push((array*)&res, _MOV((string[]){ string_substr(s, start, 2147483647) }));
				}
				break;
		}
	}
	
	return res;
}
string string_substr(string s, int start, int _end) {
	int end = (_end == _const_max_int ? (s.len) : (_end));
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
			_v_panic(string__plus(string__plus(string__plus(string__plus(string__plus(string__plus(string__plus(_SLIT("substr("), int_str(start)), _SLIT(", ")), int_str(end)), _SLIT(") out of bounds (len=")), int_str(s.len)), _SLIT(") s=")), s));
			VUNREACHABLE();
		}
	}
	#endif
	int len = (int)(end - start);
	if (len == s.len) {
		return string_clone(s);
	}
	string res = ((string){.str = malloc_noscan((int)(len + 1)), .len = len});
	{ // Unsafe block
		vmemcpy(res.str, s.str + start, len);
		res.str[len] = 0;
	}
	return res;
}
string string_substr_unsafe(string s, int start, int _end) {
	int end = (_end == 2147483647 ? (s.len) : (_end));
	int len = (int)(end - start);
	if (len == s.len) {
		return s;
	}
	return ((string){.str = s.str + start, .len = len});
}
_result_string string_substr_with_check(string s, int start, int _end) {
	int end = (_end == _const_max_int ? (s.len) : (_end));
	if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
		return (_result_string){ .is_error=true, .err=_v_error(string__plus(string__plus(string__plus(string__plus(string__plus(string__plus(_SLIT("substr("), int_str(start)), _SLIT(", ")), int_str(end)), _SLIT(") out of bounds (len=")), int_str(s.len)), _SLIT(")"))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int len = (int)(end - start);
	if (len == s.len) {
		_result_string _t2 = {0};
		_result_ok(&(string[]) { string_clone(s) }, (_result*)(&_t2), sizeof(string));
		return _t2;
	}
	string res = ((string){.str = malloc_noscan((int)(len + 1)), .len = len});
	{ // Unsafe block
		vmemcpy(res.str, s.str + start, len);
		res.str[len] = 0;
	}
	_result_string _t3 = {0};
	_result_ok(&(string[]) { res }, (_result*)(&_t3), sizeof(string));
	return _t3;
}
string string_substr_ni(string s, int _start, int _end) {
	int start = _start;
	int end = (_end == _const_max_int ? (s.len) : (_end));
	if (start < 0) {
		start = (int)(s.len + start);
		if (start < 0) {
			start = 0;
		}
	}
	if (end < 0) {
		end = (int)(s.len + end);
		if (end < 0) {
			end = 0;
		}
	}
	if (end >= s.len) {
		end = s.len;
	}
	if (start > s.len || end < start) {
		return _SLIT("");
	}
	int len = (int)(end - start);
	string res = ((string){.str = malloc_noscan((int)(len + 1)), .len = len});
	{ // Unsafe block
		vmemcpy(res.str, s.str + start, len);
		res.str[len] = 0;
	}
	return res;
}
VV_LOCAL_SYMBOL int string_index_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	if (p.len > 2) {
		return string_index_kmp(s, p);
	}
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[(int)(i + j)] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}
_option_int string_index(string s, string p) {
	int idx = string_index_(s, p);
	if (idx == -1) {
		return (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_option_int _t2;
	_option_ok(&(int[]) { idx }, (_option*)(&_t2), sizeof(int));
	return _t2;
}
inline _option_int string_last_index(string s, string needle) {
	int idx = string_index_last_(s, needle);
	if (idx == -1) {
		return (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_option_int _t2;
	_option_ok(&(int[]) { idx }, (_option*)(&_t2), sizeof(int));
	return _t2;
}
VV_LOCAL_SYMBOL int string_index_kmp(string s, string p) {
	bool string_index_kmp_defer_0 = false;
	int* p_prefixes;
	if (p.len > s.len) {
		return -1;
	}
	Array_fixed_int_20 stack_prefixes = {0};
	p_prefixes = &stack_prefixes[0];
	if (p.len > _const_kmp_stack_buffer_size) {
		p_prefixes = ((int*)(vcalloc((int)(p.len * ((int)(sizeof(int)))))));
	}
	string_index_kmp_defer_0 = true;
	int j = 0;
	for (int i = 1; i < p.len; i++) {
		for (;;) {
			if (!(p.str[j] != p.str[i] && j > 0)) break;
			j = p_prefixes[(int)(j - 1)];
		}
		if (p.str[j] == p.str[i]) {
			j++;
		}
		{ // Unsafe block
			p_prefixes[i] = j;
		}
	}
	j = 0;
	for (int i = 0; i < s.len; ++i) {
		for (;;) {
			if (!(p.str[j] != s.str[i] && j > 0)) break;
			j = p_prefixes[(int)(j - 1)];
		}
		if (p.str[j] == s.str[i]) {
			j++;
		}
		if (j == p.len) {
			int _t2 = (int)((int)(i - p.len) + 1);
			// Defer begin
			if (string_index_kmp_defer_0) {
				if (p.len > _const_kmp_stack_buffer_size) {
					_v_free(p_prefixes);
				}
			}
			// Defer end
			return _t2;
		}
	}
	int _t3 = -1;
	// Defer begin
	if (string_index_kmp_defer_0) {
		if (p.len > _const_kmp_stack_buffer_size) {
			_v_free(p_prefixes);
		}
	}
	// Defer end
	return _t3;
}
int string_index_any(string s, string chars) {
	for (int i = 0; i < s.len; ++i) {
		u8 ss = s.str[i];
		for (int _t1 = 0; _t1 < chars.len; ++_t1) {
			u8 c = chars.str[_t1];
			if (c == ss) {
				return i;
			}
		}
	}
	return -1;
}
VV_LOCAL_SYMBOL int string_index_last_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	int i = (int)(s.len - p.len);
	for (;;) {
		if (!(i >= 0)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[(int)(i + j)] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i--;
	}
	return -1;
}
_option_int string_index_after(string s, string p, int start) {
	if (p.len > s.len) {
		return (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int i = strt;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && s.str[ii] == p.str[j])) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			_option_int _t3;
			_option_ok(&(int[]) { i }, (_option*)(&_t3), sizeof(int));
			return _t3;
		}
		i++;
	}
	return (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}
int string_index_after_(string s, string p, int start) {
	if (p.len > s.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return -1;
	}
	int i = strt;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && s.str[ii] == p.str[j])) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}
int string_index_u8(string s, u8 c) {
	for (int i = 0; i < s.len; ++i) {
		u8 b = s.str[i];
		if (b == c) {
			return i;
		}
	}
	return -1;
}
inline int string_last_index_u8(string s, u8 c) {
	for (int i = (int)(s.len - 1); i >= 0; i--) {
		if (s.str[ i] == c) {
			return i;
		}
	}
	return -1;
}
int string_count(string s, string substr) {
	if (s.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > s.len) {
		return 0;
	}
	int n = 0;
	if (substr.len == 1) {
		u8 target = substr.str[ 0];
		for (int _t3 = 0; _t3 < s.len; ++_t3) {
			u8 letter = s.str[_t3];
			if (letter == target) {
				n++;
			}
		}
		return n;
	}
	int i = 0;
	for (;;) {
		i = string_index_after_(s, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}
bool string_contains_u8(string s, u8 x) {
	for (int _t1 = 0; _t1 < s.len; ++_t1) {
		u8 c = s.str[_t1];
		if (x == c) {
			return true;
		}
	}
	return false;
}
bool string_contains(string s, string substr) {
	if (substr.len == 0) {
		return true;
	}
	if (substr.len == 1) {
		return string_contains_u8(s, substr.str[0]);
	}
	return string_index_(s, substr) != -1;
}
bool string_contains_only(string s, string chars) {
	if (chars.len == 0) {
		return false;
	}
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		u8 ch = s.str[_t2];
		int res = 0;
		for (int i = 0; i < chars.len && res == 0; i++) {
			res += (int[]){(ch == chars.str[i])?1:0}[0];
		}
		if (res == 0) {
			return false;
		}
	}
	return true;
}
bool string_starts_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	} else if (vmemcmp(s.str, p.str, p.len) == 0) {
		return true;
	}
	return false;
}
bool string_ends_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	} else if (vmemcmp(s.str + s.len - p.len, p.str, p.len) == 0) {
		return true;
	}
	return false;
}
string string_to_lower_ascii(string s) {
	{ // Unsafe block
		u8* b = malloc_noscan((int)(s.len + 1));
		for (int i = 0; i < s.len; ++i) {
			if (s.str[i] >= 'A' && s.str[i] <= 'Z') {
				b[i] = (u8)(s.str[i] + 32);
			} else {
				b[i] = s.str[i];
			}
		}
		b[s.len] = 0;
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string string_to_lower(string s) {
	if (string_is_pure_ascii(s)) {
		return string_to_lower_ascii(s);
	}
	Array_rune runes = string_runes(s);
	for (int i = 0; i < runes.len; ++i) {
		((rune*)runes.data)[i] = rune_to_lower(((rune*)runes.data)[i]);
	}
	return Array_rune_string(runes);
}
string string_to_upper_ascii(string s) {
	{ // Unsafe block
		u8* b = malloc_noscan((int)(s.len + 1));
		for (int i = 0; i < s.len; ++i) {
			if (s.str[i] >= 'a' && s.str[i] <= 'z') {
				b[i] = (u8)(s.str[i] - 32);
			} else {
				b[i] = s.str[i];
			}
		}
		b[s.len] = 0;
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string string_to_upper(string s) {
	if (string_is_pure_ascii(s)) {
		return string_to_upper_ascii(s);
	}
	Array_rune runes = string_runes(s);
	for (int i = 0; i < runes.len; ++i) {
		((rune*)runes.data)[i] = rune_to_upper(((rune*)runes.data)[i]);
	}
	return Array_rune_string(runes);
}
string string_capitalize(string s) {
	if (s.len == 0) {
		return _SLIT("");
	}
	u8 s0 = s.str[ 0];
	string letter = u8_ascii_str(s0);
	string uletter = string_to_upper(letter);
	if (s.len == 1) {
		return uletter;
	}
	string srest = string_substr(s, 1, 2147483647);
	string res = string__plus(uletter, srest);
	return res;
}
inline string string_trim_space(string s) {
	return string_trim(s, _SLIT(" \n\t\v\f\r"));
}
string string_trim(string s, string cutset) {
	if ((s).len == 0 || (cutset).len == 0) {
		return string_clone(s);
	}
	if (string_is_pure_ascii(cutset)) {
		return string_trim_chars(s, cutset, TrimMode__trim_both);
	} else {
		return string_trim_runes(s, cutset, TrimMode__trim_both);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOCAL_SYMBOL string string_trim_chars(string s, string cutset, TrimMode mode) {
	int pos_left = 0;
	int pos_right = (int)(s.len - 1);
	bool cs_match = true;
	for (;;) {
		if (!(pos_left <= s.len && pos_right >= -1 && cs_match)) break;
		cs_match = false;
		if (mode == TrimMode__trim_left || mode == TrimMode__trim_both) {
			for (int _t1 = 0; _t1 < cutset.len; ++_t1) {
				u8 cs = cutset.str[_t1];
				if (s.str[ pos_left] == cs) {
					pos_left++;
					cs_match = true;
					break;
				}
			}
		}
		if (mode == TrimMode__trim_right || mode == TrimMode__trim_both) {
			for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
				u8 cs = cutset.str[_t2];
				if (s.str[ pos_right] == cs) {
					pos_right--;
					cs_match = true;
					break;
				}
			}
		}
		if (pos_left > pos_right) {
			return _SLIT("");
		}
	}
	return string_substr(s, pos_left, (int)(pos_right + 1));
}
VV_LOCAL_SYMBOL string string_trim_runes(string s, string cutset, TrimMode mode) {
	Array_rune s_runes = string_runes(s);
	Array_rune c_runes = string_runes(cutset);
	int pos_left = 0;
	int pos_right = (int)(s_runes.len - 1);
	bool cs_match = true;
	for (;;) {
		if (!(pos_left <= s_runes.len && pos_right >= -1 && cs_match)) break;
		cs_match = false;
		if (mode == TrimMode__trim_left || mode == TrimMode__trim_both) {
			for (int _t1 = 0; _t1 < c_runes.len; ++_t1) {
				rune cs = ((rune*)c_runes.data)[_t1];
				if (((rune*)s_runes.data)[pos_left] == cs) {
					pos_left++;
					cs_match = true;
					break;
				}
			}
		}
		if (mode == TrimMode__trim_right || mode == TrimMode__trim_both) {
			for (int _t2 = 0; _t2 < c_runes.len; ++_t2) {
				rune cs = ((rune*)c_runes.data)[_t2];
				if (((rune*)s_runes.data)[pos_right] == cs) {
					pos_right--;
					cs_match = true;
					break;
				}
			}
		}
		if (pos_left > pos_right) {
			return _SLIT("");
		}
	}
	return Array_rune_string(array_slice(s_runes, pos_left, (int)(pos_right + 1)));
}
string string_trim_left(string s, string cutset) {
	if ((s).len == 0 || (cutset).len == 0) {
		return string_clone(s);
	}
	if (string_is_pure_ascii(cutset)) {
		return string_trim_chars(s, cutset, TrimMode__trim_left);
	} else {
		return string_trim_runes(s, cutset, TrimMode__trim_left);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string string_trim_right(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	if (string_is_pure_ascii(cutset)) {
		return string_trim_chars(s, cutset, TrimMode__trim_right);
	} else {
		return string_trim_runes(s, cutset, TrimMode__trim_right);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string string_str(string s) {
	return string_clone(s);
}
VV_LOCAL_SYMBOL u8 string_at(string s, int idx) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (idx < 0 || idx >= s.len) {
			panic_n2(_SLIT("string index out of range(idx,s.len):"), idx, s.len);
			VUNREACHABLE();
		}
	}
	#endif
	return s.str[idx];
}
VV_LOCAL_SYMBOL _option_u8 string_at_with_check(string s, int idx) {
	if (idx < 0 || idx >= s.len) {
		return (_option_u8){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	{ // Unsafe block
		_option_u8 _t2;
		_option_ok(&(u8[]) { s.str[idx] }, (_option*)(&_t2), sizeof(u8));
		return _t2;
	}
	return (_option_u8){.state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION}};
}
inline bool u8_is_space(u8 c) {
	return c == 32 || (c > 8 && c < 14) || c == 0x85 || c == 0xa0;
}
inline bool u8_is_digit(u8 c) {
	return c >= '0' && c <= '9';
}
inline bool u8_is_letter(u8 c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}
inline bool u8_is_alnum(u8 c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9');
}
void string_free(string* s) {
	if (s->is_lit == -98761234) {
		u8* double_free_msg = ((u8*)("double string.free() detected\n"));
		int double_free_msg_len = vstrlen(double_free_msg);
		#if defined(_VFREESTANDING)
		{
		}
		#else
		{
			_write_buf_to_fd(1, double_free_msg, double_free_msg_len);
		}
		#endif
		return;
	}
	if (s->is_lit == 1 || s->str == 0) {
		return;
	}
	{ // Unsafe block
		_v_free(s->str);
		s->str = ((void*)0);
	}
	s->is_lit = -98761234;
}
string string_all_before(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}
string string_all_before_last(string s, string sub) {
	int pos = string_index_last_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}
string string_all_after(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, (int)(pos + sub.len), 2147483647);
}
string string_all_after_last(string s, string sub) {
	int pos = string_index_last_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, (int)(pos + sub.len), 2147483647);
}
string Array_string_join(Array_string a, string sep) {
	if (a.len == 0) {
		return _SLIT("");
	}
	int len = 0;
	for (int _t2 = 0; _t2 < a.len; ++_t2) {
		string val = ((string*)a.data)[_t2];
		len += (int)(val.len + sep.len);
	}
	len -= sep.len;
	string res = ((string){.str = malloc_noscan((int)(len + 1)), .len = len});
	int idx = 0;
	for (int i = 0; i < a.len; ++i) {
		string val = ((string*)a.data)[i];
		{ // Unsafe block
			vmemcpy(((voidptr)(res.str + idx)), val.str, val.len);
			idx += val.len;
		}
		if (i != (int)(a.len - 1)) {
			{ // Unsafe block
				vmemcpy(((voidptr)(res.str + idx)), sep.str, sep.len);
				idx += sep.len;
			}
		}
	}
	{ // Unsafe block
		res.str[res.len] = 0;
	}
	return res;
}
Array_u8 string_bytes(string s) {
	if (s.len == 0) {
		return __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
	}
	Array_u8 buf = __new_array_with_default_noscan(s.len, 0, sizeof(u8), 0);
	vmemcpy(buf.data, s.str, s.len);
	return buf;
}
string string_repeat(string s, int count) {
	if (count <= 0) {
		return _SLIT("");
	} else if (count == 1) {
		return string_clone(s);
	}
	u8* ret = malloc_noscan((int)((int)(s.len * count) + 1));
	for (int i = 0; i < count; ++i) {
		vmemcpy(ret + (int)(i * s.len), s.str, s.len);
	}
	int new_len = (int)(s.len * count);
	{ // Unsafe block
		ret[new_len] = 0;
	}
	return u8_vstring_with_len(ret, new_len);
}
bool string_match_glob(string name, string pattern) {
	int px = 0;
	int nx = 0;
	int next_px = 0;
	int next_nx = 0;
	int plen = pattern.len;
	int nlen = name.len;
	for (;;) {
		if (!(px < plen || nx < nlen)) break;
		if (px < plen) {
			u8 c = pattern.str[ px];

			if (c == ('?')) {
				if (nx < nlen) {
					px++;
					nx++;
					continue;
				}
			}
			else if (c == ('*')) {
				next_px = px;
				next_nx = (int)(nx + 1);
				px++;
				continue;
			}
			else if (c == ('[')) {
				if (nx < nlen) {
					u8 wanted_c = name.str[ nx];
					int bstart = px;
					bool is_inverted = false;
					bool inner_match = false;
					int inner_idx = (int)(bstart + 1);
					int inner_c = 0;
					if (inner_idx < plen) {
						inner_c = pattern.str[ inner_idx];
						if (inner_c == '^') {
							is_inverted = true;
							inner_idx++;
						}
					}
					for (; inner_idx < plen; inner_idx++) {
						inner_c = pattern.str[ inner_idx];
						if (inner_c == ']') {
							break;
						}
						if (inner_c == wanted_c) {
							inner_match = true;
							for (;;) {
								if (!(px < plen && pattern.str[ px] != ']')) break;
								px++;
							}
							break;
						}
					}
					if (is_inverted) {
						if (inner_match) {
							return false;
						} else {
							px = inner_idx;
						}
					}
				}
				px++;
				nx++;
				continue;
			}
			else {
				if (nx < nlen && name.str[ nx] == c) {
					px++;
					nx++;
					continue;
				}
			}
		}
		if (0 < next_nx && next_nx <= nlen) {
			px = next_px;
			nx = next_nx;
			continue;
		}
		return false;
	}
	return true;
}
VV_LOCAL_SYMBOL string data_to_hex_string(u8* data, int len) {
	u8* hex = malloc_noscan((u64)((u64)(((u64)(len)) * 2U) + 1U));
	int dst = 0;
	for (int c = 0; c < len; ++c) {
		u8 b = data[c];
		u8 n0 = (b >> 4);
		u8 n1 = (b & 0xF);
		hex[dst] = (n0 < 10 ? ((rune)(n0 + '0')) : ((rune)(n0 + 'W')));
		hex[(int)(dst + 1)] = (n1 < 10 ? ((rune)(n1 + '0')) : ((rune)(n1 + 'W')));
		dst += 2;
	}
	hex[dst] = 0;
	return tos(hex, dst);
}
string byteptr_vstring(byteptr bp) {
	return ((string){.str = bp, .len = vstrlen(bp)});
}
string byteptr_vstring_with_len(byteptr bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 0});
}
string charptr_vstring(charptr cp) {
	return ((string){.str = ((byteptr)(cp)), .len = vstrlen_char(cp), .is_lit = 0});
}
string charptr_vstring_with_len(charptr cp, int len) {
	return ((string){.str = ((byteptr)(cp)), .len = len, .is_lit = 0});
}
string byteptr_vstring_literal(byteptr bp) {
	return ((string){.str = bp, .len = vstrlen(bp), .is_lit = 1});
}
string charptr_vstring_literal(charptr cp) {
	return ((string){.str = ((byteptr)(cp)), .len = vstrlen_char(cp), .is_lit = 1});
}
string StrIntpType_str(StrIntpType x) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (x) {
		case StrIntpType__si_no_str: {
				_t2 = _SLIT("no_str");
				break;
		}
		case StrIntpType__si_c: {
				_t2 = _SLIT("c");
				break;
		}
		case StrIntpType__si_u8: {
				_t2 = _SLIT("u8");
				break;
		}
		case StrIntpType__si_i8: {
				_t2 = _SLIT("i8");
				break;
		}
		case StrIntpType__si_u16: {
				_t2 = _SLIT("u16");
				break;
		}
		case StrIntpType__si_i16: {
				_t2 = _SLIT("i16");
				break;
		}
		case StrIntpType__si_u32: {
				_t2 = _SLIT("u32");
				break;
		}
		case StrIntpType__si_i32: {
				_t2 = _SLIT("i32");
				break;
		}
		case StrIntpType__si_u64: {
				_t2 = _SLIT("u64");
				break;
		}
		case StrIntpType__si_i64: {
				_t2 = _SLIT("i64");
				break;
		}
		case StrIntpType__si_f32: {
				_t2 = _SLIT("f32");
				break;
		}
		case StrIntpType__si_f64: {
				_t2 = _SLIT("f64");
				break;
		}
		case StrIntpType__si_g32: {
				_t2 = _SLIT("f32");
				break;
		}
		case StrIntpType__si_g64: {
				_t2 = _SLIT("f64");
				break;
		}
		case StrIntpType__si_e32: {
				_t2 = _SLIT("f32");
				break;
		}
		case StrIntpType__si_e64: {
				_t2 = _SLIT("f64");
				break;
		}
		case StrIntpType__si_s: {
				_t2 = _SLIT("s");
				break;
		}
		case StrIntpType__si_p: {
				_t2 = _SLIT("p");
				break;
		}
		case StrIntpType__si_r: {
				_t2 = _SLIT("r");
				break;
		}
		case StrIntpType__si_vp: {
				_t2 = _SLIT("vp");
				break;
		}
	}
	return _t2;
}
inline VV_LOCAL_SYMBOL f32 fabs32(f32 x) {
	return (x < 0 ? (-x) : (x));
}
inline VV_LOCAL_SYMBOL f64 fabs64(f64 x) {
	return (x < 0 ? (-x) : (x));
}
inline VV_LOCAL_SYMBOL u64 abs64(i64 x) {
	return (x < 0 ? (((u64)(-x))) : (((u64)(x))));
}
VV_LOCAL_SYMBOL void StrIntpData_process_str_intp_data(StrIntpData* data, strings__Builder* sb) {
	u32 x = data->fmt;
	StrIntpType typ = ((StrIntpType)((x & 0x1FU)));
	int align = ((int)((((x >> 5U)) & 0x01U)));
	bool upper_case = ((((x >> 7U)) & 0x01U)) > 0U;
	int sign = ((int)((((x >> 8U)) & 0x01U)));
	int precision = ((int)((((x >> 9U)) & 0x7FU)));
	bool tail_zeros = ((((x >> 16U)) & 0x01U)) > 0U;
	int width = ((int)(((i16)((((x >> 17U)) & 0x3FFU)))));
	int base = (((int)((x >> 27U))) & 0xF);
	u8 fmt_pad_ch = ((u8)((((x >> 31U)) & 0xFFU)));
	if (typ == StrIntpType__si_no_str) {
		return;
	}
	if (base > 0) {
		base += 2;
	}
	u8 pad_ch = ((u8)(' '));
	if (fmt_pad_ch > 0) {
		pad_ch = '0';
	}
	int len0_set = (width > 0 ? (width) : (-1));
	int len1_set = (precision == 0x7F ? (-1) : (precision));
	bool sign_set = sign == 1;
	strconv__BF_param bf = ((strconv__BF_param){
		.pad_ch = pad_ch,
		.len0 = len0_set,
		.len1 = len1_set,
		.positive = true,
		.sign_flag = sign_set,
		.align = strconv__Align_text__left,
		.rm_tail_zero = tail_zeros,
	});
	if (fmt_pad_ch == 0) {
		switch (align) {
			case 0: {
					bf.align = strconv__Align_text__left;
					break;
			}
			case 1: {
					bf.align = strconv__Align_text__right;
					break;
			}
			default: {
					bf.align = strconv__Align_text__left;
					break;
			}
		}
		
	} else {
		bf.align = strconv__Align_text__right;
	}
	{ // Unsafe block
		if (typ == StrIntpType__si_s) {
			if (upper_case) {
				string s = string_to_upper(data->d.d_s);
				if (width == 0) {
					strings__Builder_write_string(sb, s);
				} else {
					strconv__format_str_sb(s, bf, sb);
				}
				string_free(&s);
			} else {
				if (width == 0) {
					strings__Builder_write_string(sb, data->d.d_s);
				} else {
					strconv__format_str_sb(data->d.d_s, bf, sb);
				}
			}
			return;
		}
		if (typ == StrIntpType__si_r) {
			if (width > 0) {
				if (upper_case) {
					string s = string_to_upper(data->d.d_s);
					for (int _t1 = 1; _t1 < ((int)(1 + ((width > 0 ? (width) : (0))))); ++_t1) {
						strings__Builder_write_string(sb, s);
					}
					string_free(&s);
				} else {
					for (int _t2 = 1; _t2 < ((int)(1 + ((width > 0 ? (width) : (0))))); ++_t2) {
						strings__Builder_write_string(sb, data->d.d_s);
					}
				}
			}
			return;
		}
		if (typ == StrIntpType__si_i8 || typ == StrIntpType__si_i16 || typ == StrIntpType__si_i32 || typ == StrIntpType__si_i64) {
			i64 d = data->d.d_i64;
			if (typ == StrIntpType__si_i8) {
				d = ((i64)(data->d.d_i8));
			} else if (typ == StrIntpType__si_i16) {
				d = ((i64)(data->d.d_i16));
			} else if (typ == StrIntpType__si_i32) {
				d = ((i64)(data->d.d_i32));
			}
			if (base == 0) {
				if (width == 0) {
					string d_str = i64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				if (d < 0) {
					bf.positive = false;
				}
				strconv__format_dec_sb(abs64(d), bf, sb);
			} else {
				if (base == 3) {
					base = 2;
				}
				i64 absd = d;
				bool write_minus = false;
				if (d < 0 && pad_ch != ' ') {
					absd = -d;
					write_minus = true;
				}
				string hx = strconv__format_int(absd, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (write_minus) {
					strings__Builder_write_u8(sb, '-');
					bf.len0--;
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		if (typ == StrIntpType__si_u8 || typ == StrIntpType__si_u16 || typ == StrIntpType__si_u32 || typ == StrIntpType__si_u64) {
			u64 d = data->d.d_u64;
			if (typ == StrIntpType__si_u8) {
				d = ((u64)(data->d.d_u8));
			} else if (typ == StrIntpType__si_u16) {
				d = ((u64)(data->d.d_u16));
			} else if (typ == StrIntpType__si_u32) {
				d = ((u64)(data->d.d_u32));
			}
			if (base == 0) {
				if (width == 0) {
					string d_str = u64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				strconv__format_dec_sb(d, bf, sb);
			} else {
				if (base == 3) {
					base = 2;
				}
				string hx = strconv__format_uint(d, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		if (typ == StrIntpType__si_p) {
			u64 d = data->d.d_u64;
			base = 16;
			if (base == 0) {
				if (width == 0) {
					string d_str = u64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				strconv__format_dec_sb(d, bf, sb);
			} else {
				string hx = strconv__format_uint(d, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		bool use_default_str = false;
		if (width == 0 && precision == 0x7F) {
			bf.len1 = 3;
			use_default_str = true;
		}
		if (bf.len1 < 0) {
			bf.len1 = 3;
		}
		switch (typ) {
			case StrIntpType__si_f32: {
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						if (use_default_str) {
							string f = f32_str(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f32 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_fl(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
			}
			case StrIntpType__si_f64: {
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						if (use_default_str) {
							string f = f64_str(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f64 < 0) {
								bf.positive = false;
							}
							strconv__Float64u f_union = ((strconv__Float64u){.f = data->d.d_f64,});
							if (f_union.u == _const_strconv__double_minus_zero) {
								bf.positive = false;
							}
							string f = strconv__format_fl(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
			}
			case StrIntpType__si_g32: {
					if (use_default_str) {
						#if !defined(CUSTOM_DEFINE_nofloat)
						{
							string f = f32_strg(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
						#endif
					} else {
						if (data->d.d_f32 == _const_strconv__single_plus_zero) {
							string tmp_str = _SLIT("0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f32 == _const_strconv__single_minus_zero) {
							string tmp_str = _SLIT("-0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f32 == _const_strconv__single_plus_infinity) {
							string tmp_str = _SLIT("+inf");
							if (upper_case) {
								tmp_str = _SLIT("+INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f32 == _const_strconv__single_minus_infinity) {
							string tmp_str = _SLIT("-inf");
							if (upper_case) {
								tmp_str = _SLIT("-INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f32 < 0) {
							bf.positive = false;
						}
						f32 d = fabs32(data->d.d_f32);
						if (d < ((f32)(999999.0)) && d >= ((f32)(0.00001))) {
							string f = strconv__format_fl(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
							return;
						}
						bf.len1--;
						string f = strconv__format_es(data->d.d_f32, bf);
						if (upper_case) {
							string tmp = f;
							f = string_to_upper(f);
							string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						string_free(&f);
					}
					break;
			}
			case StrIntpType__si_g64: {
					if (use_default_str) {
						#if !defined(CUSTOM_DEFINE_nofloat)
						{
							string f = f64_strg(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
						#endif
					} else {
						if (data->d.d_f64 == _const_strconv__double_plus_zero) {
							string tmp_str = _SLIT("0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f64 == _const_strconv__double_minus_zero) {
							string tmp_str = _SLIT("-0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f64 == _const_strconv__double_plus_infinity) {
							string tmp_str = _SLIT("+inf");
							if (upper_case) {
								tmp_str = _SLIT("+INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f64 == _const_strconv__double_minus_infinity) {
							string tmp_str = _SLIT("-inf");
							if (upper_case) {
								tmp_str = _SLIT("-INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f64 < 0) {
							bf.positive = false;
						}
						f64 d = fabs64(data->d.d_f64);
						if (d < ((f64)(999999.0)) && d >= ((f64)(0.00001))) {
							string f = strconv__format_fl(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
							return;
						}
						bf.len1--;
						string f = strconv__format_es(data->d.d_f64, bf);
						if (upper_case) {
							string tmp = f;
							f = string_to_upper(f);
							string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						string_free(&f);
					}
					break;
			}
			case StrIntpType__si_e32: {
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						if (use_default_str) {
							string f = f32_str(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f32 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_es(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
			}
			case StrIntpType__si_e64: {
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						if (use_default_str) {
							string f = f64_str(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f64 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_es(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
			}
			case StrIntpType__si_c: {
					string ss = utf32_to_str(data->d.d_c);
					strings__Builder_write_string(sb, ss);
					string_free(&ss);
					break;
			}
			case StrIntpType__si_vp: {
					string ss = u64_hex(((u64)(data->d.d_vp)));
					strings__Builder_write_string(sb, ss);
					string_free(&ss);
					break;
			}
			case StrIntpType__si_no_str:
			case StrIntpType__si_u8:
			case StrIntpType__si_i8:
			case StrIntpType__si_u16:
			case StrIntpType__si_i16:
			case StrIntpType__si_u32:
			case StrIntpType__si_i32:
			case StrIntpType__si_u64:
			case StrIntpType__si_i64:
			case StrIntpType__si_s:
			case StrIntpType__si_p:
			case StrIntpType__si_r:
			default: {
					strings__Builder_write_string(sb, _SLIT("***ERROR!***"));
					break;
			}
		}
		
	}
}
string str_intp(int data_len, StrIntpData* input_base) {
	strings__Builder res = strings__new_builder(64);
	for (int i = 0; i < data_len; i++) {
		StrIntpData* data = &input_base[i];
		if (data->str.len != 0) {
			strings__Builder_write_string(&res, data->str);
		}
		if (data->fmt != 0U) {
			StrIntpData_process_str_intp_data(data, (voidptr)&res);
		}
	}
	string ret = strings__Builder_str(&res);
	strings__Builder_free(&res);
	return ret;
}
int utf8_char_len(u8 b) {
	return (int_literal)(((((0xe5000000 >> ((((b >> 3)) & 0x1e)))) & 3)) + 1);
}
string utf32_to_str(u32 code) {
	{ // Unsafe block
		u8* buffer = malloc_noscan(5);
		string res = utf32_to_str_no_malloc(code, buffer);
		if (res.len == 0) {
			_v_free(buffer);
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string utf32_to_str_no_malloc(u32 code, u8* buf) {
	{ // Unsafe block
		int len = utf32_decode_to_buffer(code, buf);
		if (len == 0) {
			return _SLIT("");
		}
		buf[len] = 0;
		return tos(buf, len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
int utf32_decode_to_buffer(u32 code, u8* buf) {
	{ // Unsafe block
		int icode = ((int)(code));
		u8* buffer = ((u8*)(buf));
		if (icode <= 127) {
			buffer[0] = ((u8)(icode));
			return 1;
		} else if (icode <= 2047) {
			buffer[0] = (192 | ((u8)((icode >> 6))));
			buffer[1] = (128 | ((u8)((icode & 63))));
			return 2;
		} else if (icode <= 65535) {
			buffer[0] = (224 | ((u8)((icode >> 12))));
			buffer[1] = (128 | ((((u8)((icode >> 6))) & 63)));
			buffer[2] = (128 | ((u8)((icode & 63))));
			return 3;
		} else if (icode <= 1114111) {
			buffer[0] = (240 | ((u8)((icode >> 18))));
			buffer[1] = (128 | ((((u8)((icode >> 12))) & 63)));
			buffer[2] = (128 | ((((u8)((icode >> 6))) & 63)));
			buffer[3] = (128 | ((u8)((icode & 63))));
			return 4;
		}
	}
	return 0;
}
int string_utf32_code(string _rune) {
	_result_rune _t1;
	if (_t1 = Array_u8_utf8_to_utf32(string_bytes(_rune)), !_t1.is_error) {
		rune res = *(rune*)_t1.data;
		return ((int)(res));
	}
	return 0;
}
_result_rune Array_u8_utf8_to_utf32(Array_u8 _bytes) {
	if (_bytes.len == 0) {
		_result_rune _t1 = {0};
		_result_ok(&(rune[]) { 0 }, (_result*)(&_t1), sizeof(rune));
		return _t1;
	}
	if (_bytes.len == 1) {
		_result_rune _t2 = {0};
		_result_ok(&(rune[]) { ((rune)(((u8*)_bytes.data)[0])) }, (_result*)(&_t2), sizeof(rune));
		return _t2;
	}
	if (_bytes.len > 4) {
		return (_result_rune){ .is_error=true, .err=_v_error(_SLIT("attempted to decode too many bytes, utf-8 is limited to four bytes maximum")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	u8 b = ((u8)(((int)(((u8*)_bytes.data)[0]))));
	b = (b << _bytes.len);
	rune res = ((rune)(b));
	int shift = (int)(6 - _bytes.len);
	for (int i = 1; i < _bytes.len; i++) {
		rune c = ((rune)(((u8*)_bytes.data)[i]));
		res = (((rune)(res)) << shift);
		res |= (c & 63);
		shift = 6;
	}
	_result_rune _t4 = {0};
	_result_ok(&(rune[]) { res }, (_result*)(&_t4), sizeof(rune));
	return _t4;
}
int utf8_str_visible_length(string s) {
	int l = 0;
	int ul = 1;
	for (int i = 0; i < s.len; i += ul) {
		u8 c = s.str[i];
		ul = (int_literal)(((((0xe5000000 >> ((((s.str[i] >> 3)) & 0x1e)))) & 3)) + 1);
		if ((int)(i + ul) > s.len) {
			return l;
		}
		l++;
		if (ul == 1) {
			continue;
		}

		if (ul == (2)) {
			u64 r = ((u64)((((((u16)(c)) << 8U)) | s.str[(int)(i + 1)])));
			if (r >= 0xcc80U && r < 0xcdb0U) {
				l--;
			}
		}
		else if (ul == (3)) {
			u64 r = ((u64)((((((u32)(c)) << 16U)) | (((((u32)(s.str[(int)(i + 1)])) << 8U)) | s.str[(int)(i + 2)]))));
			if ((r >= 0xe1aab0U && r <= 0xe1ac7fU) || (r >= 0xe1b780U && r <= 0xe1b87fU) || (r >= 0xe28390U && r <= 0xe2847fU) || (r >= 0xefb8a0U && r <= 0xefb8afU)) {
				l--;
			} else if ((r >= 0xe18480U && r <= 0xe1859fU) || (r >= 0xe2ba80U && r <= 0xe2bf95U) || (r >= 0xe38080U && r <= 0xe4b77fU) || (r >= 0xe4b880U && r <= 0xea807fU) || (r >= 0xeaa5a0U && r <= 0xeaa79fU) || (r >= 0xeab080U && r <= 0xed9eafU) || (r >= 0xefa480U && r <= 0xefac7fU) || (r >= 0xefb8b8U && r <= 0xefb9afU)) {
				l++;
			}
		}
		else if (ul == (4)) {
			u64 r = ((u64)((((((u32)(c)) << 24U)) | ((((((u32)(s.str[(int)(i + 1)])) << 16U)) | ((((u32)(s.str[(int)(i + 2)])) << 8U))) | s.str[(int)(i + 3)]))));
			if ((r >= 0x0f9f8880U && r <= 0xf09f8a8fU) || (r >= 0xf09f8c80U && r <= 0xf09f9c90U) || (r >= 0xf09fa490U && r <= 0xf09fa7afU) || (r >= 0xf0a08080U && r <= 0xf180807fU)) {
				l++;
			}
		}
		else {
		}
	}
	return l;
}
inline bool ArrayFlags_has(ArrayFlags* e, ArrayFlags flag_) {
	return ((((int)(*e)) & (((int)(flag_))))) != 0;
}
inline bool ArrayFlags_all(ArrayFlags* e, ArrayFlags flag_) {
	return ((((int)(*e)) & (((int)(flag_))))) == ((int)(flag_));
}
inline void ArrayFlags_set(ArrayFlags* e, ArrayFlags flag_) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) | (((int)(flag_))))));
	}
}
inline void ArrayFlags_clear(ArrayFlags* e, ArrayFlags flag_) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) & ~(((int)(flag_))))));
	}
}
string json__encode(voidptr x) {
	return _SLIT("");
}
string json__encode_pretty(voidptr x) {
	return _SLIT("");
}
VV_LOCAL_SYMBOL int json__decode_int(struct cJSON* root) {
	if (isnil(root)) {
		return 0;
	}
	return root->valueint;
}
VV_LOCAL_SYMBOL i8 json__decode_i8(struct cJSON* root) {
	if (isnil(root)) {
		return ((i8)(0));
	}
	return ((i8)(root->valueint));
}
VV_LOCAL_SYMBOL i16 json__decode_i16(struct cJSON* root) {
	if (isnil(root)) {
		return ((i16)(0));
	}
	return ((i16)(root->valueint));
}
VV_LOCAL_SYMBOL i64 json__decode_i64(struct cJSON* root) {
	if (isnil(root)) {
		return ((i64)(0));
	}
	return ((i64)(root->valuedouble));
}
VV_LOCAL_SYMBOL u8 json__decode_byte(struct cJSON* root) {
	return json__decode_u8(root);
}
VV_LOCAL_SYMBOL u8 json__decode_u8(struct cJSON* root) {
	if (isnil(root)) {
		return ((u8)(0));
	}
	return ((u8)(root->valueint));
}
VV_LOCAL_SYMBOL u16 json__decode_u16(struct cJSON* root) {
	if (isnil(root)) {
		return ((u16)(0U));
	}
	return ((u16)(root->valueint));
}
VV_LOCAL_SYMBOL u32 json__decode_u32(struct cJSON* root) {
	if (isnil(root)) {
		return ((u32)(0U));
	}
	return ((u32)(root->valueint));
}
VV_LOCAL_SYMBOL u64 json__decode_u64(struct cJSON* root) {
	if (isnil(root)) {
		return ((u64)(0U));
	}
	return ((u64)(root->valuedouble));
}
VV_LOCAL_SYMBOL f32 json__decode_f32(struct cJSON* root) {
	if (isnil(root)) {
		return ((f32)(0));
	}
	return ((f32)(root->valuedouble));
}
VV_LOCAL_SYMBOL f64 json__decode_f64(struct cJSON* root) {
	if (isnil(root)) {
		return ((f64)(0));
	}
	return root->valuedouble;
}
VV_LOCAL_SYMBOL rune json__decode_rune(struct cJSON* root) {
	if (isnil(root)) {
		return ((rune)(0));
	}
	if (isnil(root->valuestring)) {
		return ((rune)(0));
	}
	return (*(rune*)array_first(string_runes(tos_clone(((u8*)(root->valuestring))))));
}
VV_LOCAL_SYMBOL string json__decode_string(struct cJSON* root) {
	if (isnil(root)) {
		return _SLIT("");
	}
	if (isnil(root->valuestring)) {
		return _SLIT("");
	}
	return tos_clone(((u8*)(root->valuestring)));
}
VV_LOCAL_SYMBOL bool json__decode_bool(struct cJSON* root) {
	if (isnil(root)) {
		return false;
	}
	return cJSON_IsTrue(root);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_int(int val) {
	return cJSON_CreateNumber(val);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_i8(i8 val) {
	return cJSON_CreateNumber(val);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_i16(i16 val) {
	return cJSON_CreateNumber(val);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_i64(i64 val) {
	return cJSON_CreateNumber(val);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_byte(u8 root) {
	return json__encode_u8(root);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_u8(u8 val) {
	return cJSON_CreateNumber(val);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_u16(u16 val) {
	return cJSON_CreateNumber(val);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_u32(u32 val) {
	return cJSON_CreateNumber(val);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_u64(u64 val) {
	return cJSON_CreateNumber(val);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_f32(f32 val) {
	return cJSON_CreateNumber(val);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_f64(f64 val) {
	return cJSON_CreateNumber(val);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_bool(bool val) {
	return cJSON_CreateBool(val);
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_rune(rune val) {
	return cJSON_CreateString(((char*)(rune_str(val).str)));
}
VV_LOCAL_SYMBOL struct cJSON* json__encode_string(string val) {
	return cJSON_CreateString(((char*)(val.str)));
}
VV_LOCAL_SYMBOL struct cJSON* json__json_parse(string s) {
	return cJSON_Parse(((char*)(s.str)));
}
VV_LOCAL_SYMBOL string json__json_print(struct cJSON* data) {
	char* s = cJSON_PrintUnformatted(data);
	if (s == ((void*)0)) {
		return _SLIT("");
	}
	string r = tos_clone(((u8*)(s)));
	cJSON_free(s);
	return r;
}
VV_LOCAL_SYMBOL string json__json_print_pretty(struct cJSON* data) {
	char* s = cJSON_Print(data);
	if (s == ((void*)0)) {
		return _SLIT("");
	}
	string r = tos_clone(((u8*)(s)));
	cJSON_free(s);
	return r;
}
VV_LOCAL_SYMBOL int encoding__base64__encode_from_buffer(u8* dest, u8* src, int src_len) {
	if (src_len == 0) {
		return 0;
	}
	int output_length = (int)(4 * ((int)(((int)(src_len + 2)) / 3)));
	u8* d = src;
	u8* b = dest;
	u8* etable = _const_encoding__base64__enc_table.str;
	int di = 0;
	int si = 0;
	int n = (int)(((int)(src_len / 3)) * 3);
	for (;;) {
		if (!(si < n)) break;
		{ // Unsafe block
			u32 val = (((((u32)(d[(int)(si + 0)])) << 16U) | (((u32)(d[(int)(si + 1)])) << 8U)) | ((u32)(d[(int)(si + 2)])));
			b[(int)(di + 0)] = etable[(((val >> 18U)) & 0x3FU)];
			b[(int)(di + 1)] = etable[(((val >> 12U)) & 0x3FU)];
			b[(int)(di + 2)] = etable[(((val >> 6U)) & 0x3FU)];
			b[(int)(di + 3)] = etable[(val & 0x3FU)];
		}
		si += 3;
		di += 4;
	}
	int remain = (int)(src_len - si);
	if (remain == 0) {
		return output_length;
	}
	{ // Unsafe block
		u32 val = (((u32)(d[(int)(si + 0)])) << 16U);
		if (remain == 2) {
			val |= (((u32)(d[(int)(si + 1)])) << 8U);
		}
		b[(int)(di + 0)] = etable[(((val >> 18U)) & 0x3FU)];
		b[(int)(di + 1)] = etable[(((val >> 12U)) & 0x3FU)];
		switch (remain) {
			case 2: {
					b[(int)(di + 2)] = etable[(((val >> 6U)) & 0x3FU)];
					b[(int)(di + 3)] = ((u8)('='));
					break;
			}
			case 1: {
					b[(int)(di + 2)] = ((u8)('='));
					b[(int)(di + 3)] = ((u8)('='));
					break;
			}
			default: {
					_v_panic(_SLIT("base64: This case should never occur."));
					VUNREACHABLE();
					break;
			}
		}
		
	}
	return output_length;
}
int encoding__base64__decode_in_buffer(string* data, u8* buffer) {
	return encoding__base64__decode_from_buffer(buffer, data->str, data->len);
}
VV_LOCAL_SYMBOL int encoding__base64__decode_from_buffer(u8* dest, u8* src, int src_len) {
	if (src_len < 4) {
		return 0;
	}
	int padding = 0;
	if (src[(int)(src_len - 1)] == '=') {
		if (src[(int)(src_len - 2)] == '=') {
			padding = 2;
		} else {
			padding = 1;
		}
	}
	u8* d = src;
	u8* b = dest;
	{ // Unsafe block
		int n_decoded_bytes = 0;
		int si = 0;
		encoding__base64__B64_64_datablock datablock_64 = ((encoding__base64__B64_64_datablock){.data = 0U,});
		encoding__base64__B64_32_datablock datablock_32 = ((encoding__base64__B64_32_datablock){.data = 0U,});
		for (;;) {
			if (!((int)(src_len - si) >= 8)) break;
			datablock_64.data = encoding__base64__assemble64(((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 0)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 1)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 2)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 3)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 4)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 5)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 6)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 7)], 123)])));
			#if defined(TARGET_ORDER_IS_LITTLE)
			{
				b[(int)(n_decoded_bytes + 0)] = datablock_64.data_byte[7];
				b[(int)(n_decoded_bytes + 1)] = datablock_64.data_byte[6];
				b[(int)(n_decoded_bytes + 2)] = datablock_64.data_byte[5];
				b[(int)(n_decoded_bytes + 3)] = datablock_64.data_byte[4];
				b[(int)(n_decoded_bytes + 4)] = datablock_64.data_byte[3];
				b[(int)(n_decoded_bytes + 5)] = datablock_64.data_byte[2];
			}
			#else
			{
				b[(int)(n_decoded_bytes + 0)] = datablock_64.data_byte[0];
				b[(int)(n_decoded_bytes + 1)] = datablock_64.data_byte[1];
				b[(int)(n_decoded_bytes + 2)] = datablock_64.data_byte[2];
				b[(int)(n_decoded_bytes + 3)] = datablock_64.data_byte[3];
				b[(int)(n_decoded_bytes + 4)] = datablock_64.data_byte[4];
				b[(int)(n_decoded_bytes + 5)] = datablock_64.data_byte[5];
			}
			#endif
			n_decoded_bytes += 6;
			si += 8;
		}
		for (;;) {
			if (!((int)(src_len - si) >= 4)) break;
			datablock_32.data = encoding__base64__assemble32(((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 0)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 1)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 2)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 3)], 123)])));
			#if defined(TARGET_ORDER_IS_LITTLE)
			{
				b[(int)(n_decoded_bytes + 0)] = datablock_32.data_byte[3];
				b[(int)(n_decoded_bytes + 1)] = datablock_32.data_byte[2];
				b[(int)(n_decoded_bytes + 2)] = datablock_32.data_byte[1];
				b[(int)(n_decoded_bytes + 3)] = datablock_32.data_byte[0];
			}
			#else
			{
				b[(int)(n_decoded_bytes + 0)] = datablock_32.data_byte[0];
				b[(int)(n_decoded_bytes + 1)] = datablock_32.data_byte[1];
				b[(int)(n_decoded_bytes + 2)] = datablock_32.data_byte[2];
				b[(int)(n_decoded_bytes + 3)] = datablock_32.data_byte[3];
			}
			#endif
			n_decoded_bytes += 3;
			si += 4;
		}
		return (int)(n_decoded_bytes - padding);
	}
	return 0;
}
string encoding__base64__decode_str(string data) {
	int size = (int)((int)(data.len * 3) / 4);
	if (size <= 0 || (int)(data.len % 4) != 0) {
		return _SLIT("");
	}
	{ // Unsafe block
		u8* buffer = malloc_noscan((int)(size + 1));
		buffer[size] = 0;
		int blen = encoding__base64__decode_in_buffer((voidptr)&data, buffer);
		return tos(buffer, blen);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string encoding__base64__encode_str(string data) {
	return encoding__base64__alloc_and_encode(data.str, data.len);
}
VV_LOCAL_SYMBOL string encoding__base64__alloc_and_encode(u8* src, int len) {
	if (len == 0) {
		return _SLIT("");
	}
	int size = (int)(4 * ((int)(((int)(len + 2)) / 3)));
	if (size <= 0) {
		return _SLIT("");
	}
	{ // Unsafe block
		u8* buffer = malloc_noscan((int)(size + 1));
		buffer[size] = 0;
		int blen = encoding__base64__encode_from_buffer(buffer, src, len);
		return tos(buffer, blen);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string encoding__base64__url_decode_str(string data) {
	string result = string_replace_each(data, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("-"), _SLIT("+"), _SLIT("_"), _SLIT("/")})));
	int _t1 = (int)(result.len % 4);
		switch (_t1) {
		case 2: {
				result = string__plus(result, _SLIT("=="));
				break;
		}
		case 3: {
				result = string__plus(result, _SLIT("="));
				break;
		}
		default: {
				break;
		}
	}
	
	return encoding__base64__decode_str(result);
}
string encoding__base64__url_encode_str(string data) {
	return string_replace_each(encoding__base64__encode_str(data), new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("+"), _SLIT("-"), _SLIT("/"), _SLIT("_"), _SLIT("="), _SLIT("")})));
}
VV_LOCAL_SYMBOL u64 encoding__base64__assemble64(u8 n1, u8 n2, u8 n3, u8 n4, u8 n5, u8 n6, u8 n7, u8 n8) {
	return ((((((((((u64)(n1)) << 58U) | (((u64)(n2)) << 52U)) | (((u64)(n3)) << 46U)) | (((u64)(n4)) << 40U)) | (((u64)(n5)) << 34U)) | (((u64)(n6)) << 28U)) | (((u64)(n7)) << 22U)) | (((u64)(n8)) << 16U));
}
VV_LOCAL_SYMBOL u32 encoding__base64__assemble32(u8 n1, u8 n2, u8 n3, u8 n4) {
	return ((((((u32)(n1)) << 26U) | (((u32)(n2)) << 20U)) | (((u32)(n3)) << 14U)) | (((u32)(n4)) << 8U));
}
i64 time__Duration_nanoseconds(time__Duration d) {
	return ((i64)(d));
}
i64 time__Duration_microseconds(time__Duration d) {
	return ((i64)(d)) / _const_time__microsecond;
}
i64 time__Duration_milliseconds(time__Duration d) {
	return ((i64)(d)) / _const_time__millisecond;
}
f64 time__Duration_seconds(time__Duration d) {
	return (f64)(((f64)(d)) / ((f64)(_const_time__second)));
}
string time__Duration_str(time__Duration d) {
	if (d == _const_time__infinite) {
		return _SLIT("inf");
	}
	string sign = _SLIT("");
	i64 t = ((i64)(d));
	if (t < 0) {
		sign = _SLIT("-");
		t = -t;
	}
	i64 hr = t / _const_time__hour;
	t -= hr * _const_time__hour;
	i64 min = t / _const_time__minute;
	t -= min * _const_time__minute;
	i64 sec = t / _const_time__second;
	t -= sec * _const_time__second;
	i64 ms = t / _const_time__millisecond;
	t -= ms * _const_time__millisecond;
	i64 us = t / _const_time__microsecond;
	t -= us * _const_time__microsecond;
	i64 ns = t;
	bool _t3 = true;
	return ((_t3 == (hr > 0))? (str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = hr}}, {_SLIT(":"), 0x8004fe29, {.d_i64 = min}}, {_SLIT(":"), 0x8004fe29, {.d_i64 = sec}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_t3 == (min > 0))? (str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = min}}, {_SLIT(":"), 0x8004fe29, {.d_i64 = sec}}, {_SLIT("."), 0x8006fe29, {.d_i64 = ms}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_t3 == (sec > 0))? (str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = sec}}, {_SLIT("."), 0x8006fe29, {.d_i64 = ms}}, {_SLIT("s"), 0, { .d_c = 0 }}}))) : (_t3 == (ms > 0))? (str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = ms}}, {_SLIT("."), 0x8006fe29, {.d_i64 = us}}, {_SLIT("ms"), 0, { .d_c = 0 }}}))) : (_t3 == (us > 0))? (str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = us}}, {_SLIT("."), 0x8006fe29, {.d_i64 = ns}}, {_SLIT("us"), 0, { .d_c = 0 }}}))) : (str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = ns}}, {_SLIT("ns"), 0, { .d_c = 0 }}}))));
}
VV_LOCAL_SYMBOL void time__int_to_byte_array_no_pad(int value, Array_u8* arr, int size) {
	int num = value;
	if (size <= 0 || num < 0) {
		return;
	}
	int i = (int)(size - 1);
	for (;;) {
		if (!(num > 0 && i >= 0)) break;
		((u8*)arr->data)[i] = (rune)(((int)(num % 10)) + '0');
		num /= 10;
		i--;
	}
}
string time__Time_format_ss(time__Time t) {
	bool time__Time_format_ss_defer_0 = false;
	Array_u8 buf;
	buf = new_array_from_c_array_noscan(19, 19, sizeof(u8), _MOV((u8[19]){
			((u8)('0')), '0', '0', '0', '-', '0', '0', '-', '0',
			'0', ' ', '0', '0', ':', '0', '0', ':',
			'0', '0'}));
	time__Time_format_ss_defer_0 = true;
	time__int_to_byte_array_no_pad(t.year, &buf, 4);
	time__int_to_byte_array_no_pad(t.month, &buf, 7);
	time__int_to_byte_array_no_pad(t.day, &buf, 10);
	time__int_to_byte_array_no_pad(t.hour, &buf, 13);
	time__int_to_byte_array_no_pad(t.minute, &buf, 16);
	time__int_to_byte_array_no_pad(t.second, &buf, 19);
	string _t1 = Array_u8_bytestr(buf);
	// Defer begin
	if (time__Time_format_ss_defer_0) {
		array_free(&buf);
	}
	// Defer end
	return _t1;
}
string time__Time_http_header_string(time__Time t) {
	bool time__Time_http_header_string_defer_0 = false;
	Array_u8 buf;
	string day_str = time__Time_weekday_str(t);
	string month_str = time__Time_smonth(t);
	buf = new_array_from_c_array_noscan(29, 29, sizeof(u8), _MOV((u8[29]){
			string_at(day_str, 0), string_at(day_str, 1), string_at(day_str, 2), ',', ' ', '0', '0', ' ', string_at(month_str, 0),
			string_at(month_str, 1), string_at(month_str, 2), ' ', '0', '0', '0', '0', ' ',
			'0', '0', ':', '0', '0', ':', '0', '0',
			' ', 'G', 'M', 'T'}));
	time__Time_http_header_string_defer_0 = true;
	time__int_to_byte_array_no_pad(t.day, &buf, 7);
	time__int_to_byte_array_no_pad(t.year, &buf, 16);
	time__int_to_byte_array_no_pad(t.hour, &buf, 19);
	time__int_to_byte_array_no_pad(t.minute, &buf, 22);
	time__int_to_byte_array_no_pad(t.second, &buf, 25);
	string http_header_string = Array_u8_bytestr(buf);
	string _t1 = http_header_string;
	// Defer begin
	if (time__Time_http_header_string_defer_0) {
		array_free(&buf);
	}
	// Defer end
	return _t1;
}
inline bool time__Time__eq(time__Time t1, time__Time t2) {
	return time__Time_unix(t1) == time__Time_unix(t2) && t1.nanosecond == t2.nanosecond;
}
inline bool time__Time__lt(time__Time t1, time__Time t2) {
	return time__Time_unix(t1) < time__Time_unix(t2) || (time__Time_unix(t1) == time__Time_unix(t2) && t1.nanosecond < t2.nanosecond);
}
inline time__Duration time__Time__minus(time__Time lhs, time__Time rhs) {
	i64 unixs = ((i64)((i64)(time__Time_unix(lhs) - time__Time_unix(rhs)))) * _const_time__second;
	int nanos = (int)(lhs.nanosecond - rhs.nanosecond);
	return (i64)(unixs + nanos);
}
string time__TimeParseError_msg(time__TimeParseError err) {
	return str_intp(3, _MOV((StrIntpData[]){{_SLIT("Invalid time format code: "), 0xfe07, {.d_i32 = err.code}}, {_SLIT(", error: "), 0xfe10, {.d_s = err.message}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
time__StopWatch time__new_stopwatch(time__StopWatchOptions opts) {
	u64 initial = ((u64)(0U));
	if (opts.auto_start) {
		initial = time__sys_mono_now();
	}
	return ((time__StopWatch){.elapsed = 0U,.start = initial,.end = 0U,});
}
void time__StopWatch_start(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0U;
}
time__Duration time__StopWatch_elapsed(time__StopWatch t) {
	if (t.start > 0U) {
		if (t.end == 0U) {
			return ((((i64)((u64)((u64)(time__sys_mono_now() - t.start) + t.elapsed)))));
		} else {
			return ((((i64)((u64)((u64)(t.end - t.start) + t.elapsed)))));
		}
	}
	return ((((i64)(t.elapsed))));
}
time__Time time__now(void) {
	return time__linux_now();
}
time__Time time__utc(void) {
	return time__linux_utc();
}
VV_LOCAL_SYMBOL time__Time time__time_with_unix(time__Time t) {
	if (t.__v_unix != 0) {
		return t;
	}
	struct tm tt = ((struct tm){
		.tm_sec = t.second,
		.tm_min = t.minute,
		.tm_hour = t.hour,
		.tm_mday = t.day,
		.tm_mon = (int)(t.month - 1),
		.tm_year = (int)(t.year - 1900),
		.tm_wday = 0,
		.tm_yday = 0,
		.tm_isdst = 0,
		.tm_gmtoff = 0,
	});
	i64 utime = time__make_unix_time(tt);
	return ((time__Time){.__v_unix = utime,.year = (t).year,.month = (t).month,.day = (t).day,.hour = (t).hour,.minute = (t).minute,.second = (t).second,.nanosecond = (t).nanosecond,.is_local = (t).is_local,});
}
i64 time__ticks(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		struct timeval ts = ((struct timeval){.tv_sec = 0,.tv_usec = 0,});
		gettimeofday(&ts, 0);
		return ((i64)((u64)((u64)(ts.tv_sec * ((u64)(1000U))) + ((u64)(ts.tv_usec / ((u64)(1000U)))))));
	}
	#endif
	return 0;
}
string time__Time_str(time__Time t) {
	return time__Time_format_ss(t);
}
VV_LOCAL_SYMBOL time__Time time__convert_ctime(struct tm t, int nanosecond) {
	return ((time__Time){
		.__v_unix = time__make_unix_time(t),
		.year = (int)(t.tm_year + 1900),
		.month = (int)(t.tm_mon + 1),
		.day = t.tm_mday,
		.hour = t.tm_hour,
		.minute = t.tm_min,
		.second = t.tm_sec,
		.nanosecond = nanosecond,
		.is_local = true,
	});
}
string time__Time_smonth(time__Time t) {
	if (t.month <= 0 || t.month > 12) {
		return _SLIT("---");
	}
	int i = (int)(t.month - 1);
	return string_substr(_const_time__months_string, (int)(i * 3), (int)(((int)(i + 1)) * 3));
}
inline i64 time__Time_unix(time__Time t) {
	return time__time_with_unix(t).__v_unix;
}
time__Time time__Time_add(time__Time t, time__Duration duration_in_nanosecond) {
	i64 increased_time_nanosecond = (i64)(((i64)(t.nanosecond)) + time__Duration_nanoseconds(duration_in_nanosecond));
	i64 increased_time_second = (i64)(time__Time_unix(t) + (increased_time_nanosecond / _const_time__second));
	increased_time_nanosecond = increased_time_nanosecond % _const_time__second;
	if (increased_time_nanosecond < 0) {
		increased_time_second--;
		increased_time_nanosecond += _const_time__second;
	}
	time__Time res = time__unix_nanosecond(increased_time_second, ((int)(increased_time_nanosecond)));
	return (t.is_local ? (time__Time_as_local(res)) : (res));
}
int time__day_of_week(int y, int m, int d) {
	Array_int t = new_array_from_c_array_noscan(12, 12, sizeof(int), _MOV((int[12]){
			0, 3, 2, 5, 0, 3, 5, 1, 4,
			6, 2, 4}));
	int sy = y;
	if (m < 3) {
		sy = (int)(sy - 1);
	}
	return (int)((int)(((int)((int)((int)((int)((int)((int)(sy + (int)(sy / 4)) - (int)(sy / 100)) + (int)(sy / 400)) + (*(int*)array_get(t, (int)(m - 1)))) + d) - 1)) % 7) + 1);
}
int time__Time_day_of_week(time__Time t) {
	return time__day_of_week(t.year, t.month, t.day);
}
string time__Time_weekday_str(time__Time t) {
	int i = (int)(time__Time_day_of_week(t) - 1);
	return string_substr(_const_time__long_days[v_fixed_index(i, 7)], 0, 3);
}
time__Time time__Time_as_local(time__Time t) {
	return ((time__Time){.__v_unix = (t).__v_unix,.year = (t).year,.month = (t).month,.day = (t).day,.hour = (t).hour,.minute = (t).minute,.second = (t).second,.nanosecond = (t).nanosecond,.is_local = true,});
}
VV_LOCAL_SYMBOL i64 time__make_unix_time(struct tm t) {
	return ((i64)(timegm(&t)));
}
u64 time__sys_mono_now(void) {
	#if defined(__APPLE__)
	{
	}
	#else
	{
		struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
		clock_gettime(CLOCK_MONOTONIC, &ts);
		return (u64)((u64)(((u64)(ts.tv_sec)) * 1000000000U) + ((u64)(ts.tv_nsec)));
	}
	#endif
	return 0;
}
VV_LOCAL_SYMBOL time__Time time__linux_now(void) {
	struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	clock_gettime(CLOCK_REALTIME, &ts);
	struct tm loc_tm = ((struct tm){.tm_sec = 0,.tm_min = 0,.tm_hour = 0,.tm_mday = 0,.tm_mon = 0,.tm_year = 0,.tm_wday = 0,.tm_yday = 0,.tm_isdst = 0,.tm_gmtoff = 0,});
	localtime_r(((voidptr)(&ts.tv_sec)), &loc_tm);
	return time__convert_ctime(loc_tm, ((int)(ts.tv_nsec)));
}
VV_LOCAL_SYMBOL time__Time time__linux_utc(void) {
	struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	clock_gettime(CLOCK_REALTIME, &ts);
	return time__unix_nanosecond(((i64)(ts.tv_sec)), ((int)(ts.tv_nsec)));
}
struct timespec time__Duration_timespec(time__Duration d) {
	struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	clock_gettime(CLOCK_REALTIME, &ts);
	time__Duration d_sec = d / _const_time__second;
	time__Duration d_nsec = d % _const_time__second;
	ts.tv_sec += d_sec;
	ts.tv_nsec += d_nsec;
	if (ts.tv_nsec > ((i64)(_const_time__second))) {
		ts.tv_nsec -= ((i64)(_const_time__second));
		ts.tv_sec++;
	}
	return ts;
}
void time__sleep(time__Duration duration) {
	struct timespec req = ((struct timespec){.tv_sec = duration / _const_time__second,.tv_nsec = duration % _const_time__second,});
	struct timespec rem = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	for (;;) {
		if (!(nanosleep(&req, &rem) < 0)) break;
		if (errno == EINTR) {
			req = rem;
		} else {
			break;
		}
	}
}
time__Time time__unix(i64 epoch) {
	return time__unix_nanosecond(epoch, 0);
}
time__Time time__unix_nanosecond(i64 abs_unix_timestamp, int nanosecond) {
	i64 day_offset = (i64)(abs_unix_timestamp / 86400);
	if ((i64)(abs_unix_timestamp % 86400) < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_1688 = time__calculate_date_from_day_offset(day_offset);
	int year = mr_1688.arg0;
	int month = mr_1688.arg1;
	int day = mr_1688.arg2;
	multi_return_int_int_int mr_1759 = time__calculate_time_from_second_offset((i64)(abs_unix_timestamp % 86400));
	int hour_ = mr_1759.arg0;
	int minute_ = mr_1759.arg1;
	int second_ = mr_1759.arg2;
	return ((time__Time){
		.__v_unix = abs_unix_timestamp,
		.year = year,
		.month = month,
		.day = day,
		.hour = hour_,
		.minute = minute_,
		.second = second_,
		.nanosecond = nanosecond,
		.is_local = 0,
	});
}
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_date_from_day_offset(i64 day_offset_) {
	i64 day_offset = day_offset_;
	day_offset += 719468;
	int era = 0;
	if (day_offset >= 0) {
		era = ((int)((i64)(day_offset / 146097)));
	} else {
		era = ((int)((i64)(((i64)((i64)(day_offset - 146097) - 1)) / 146097)));
	}
	i64 day_of_era = (i64)(day_offset - (int)(era * 146097));
	i64 year_of_era = (i64)(((i64)((i64)((i64)(day_of_era - (i64)(day_of_era / (1460))) + (i64)(day_of_era / 36524)) - (i64)(day_of_era / (146096)))) / 365);
	int year = ((int)((i64)(year_of_era + (int)(era * 400))));
	i64 day_of_year = (i64)(day_of_era - ((i64)((i64)((i64)(365 * year_of_era) + (i64)(year_of_era / 4)) - (i64)(year_of_era / 100))));
	i64 month_position = (i64)(((i64)((i64)(5 * day_of_year) + 2)) / 153);
	int day = ((int)((i64)((i64)(day_of_year - (i64)(((i64)((i64)(153 * month_position) + 2)) / 5)) + 1)));
	int month = ((int)(month_position));
	if (month_position < 10) {
		month += 3;
	} else {
		month -= 9;
	}
	if (month <= 2) {
		year += 1;
	}
	return (multi_return_int_int_int){.arg0=year, .arg1=month, .arg2=day};
}
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_time_from_second_offset(i64 second_offset_) {
	i64 second_offset = second_offset_;
	if (second_offset < 0) {
		second_offset += _const_time__seconds_per_day;
	}
	i64 hour_ = (i64)(second_offset / 3600);
	second_offset %= _const_time__seconds_per_hour;
	i64 minute_ = (i64)(second_offset / 60);
	second_offset %= _const_time__seconds_per_minute;
	return (multi_return_int_int_int){.arg0=((int)(hour_)), .arg1=((int)(minute_)), .arg2=((int)(second_offset))};
}
VV_LOCAL_SYMBOL string net__urllib__error_msg(string message, string val) {
	string msg = str_intp(2, _MOV((StrIntpData[]){{_SLIT("net.urllib."), 0xfe10, {.d_s = message}}, {_SLIT0, 0, { .d_c = 0 }}}));
	if ((val).len != 0) {
		msg = str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = msg}}, {_SLIT(" ("), 0xfe10, {.d_s = val}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	}
	return msg;
}
VV_LOCAL_SYMBOL bool net__urllib__should_escape(u8 c, net__urllib__EncodingMode mode) {
	if (u8_is_alnum(c)) {
		return false;
	}
	if (mode == net__urllib__EncodingMode__encode_host || mode == net__urllib__EncodingMode__encode_zone) {
		if (c == '!' || c == '$' || c == '&' || c == '\\' || c == '(' || c == ')' || c == '*' || c == '+' || c == ',' || c == ';' || c == '=' || c == ':' || c == '[' || c == ']' || c == '<' || c == '>' || c == '"') {
			return false;
		}
	}
	switch (c) {
		case '-': case '_': case '.': case '~': {
				return false;
		}
		case '$': case '&': case '+': case ',': case '/': case ':': case ';': case '=': case '?': case '@': {
				switch (mode) {
					case net__urllib__EncodingMode__encode_path: {
							return c == '?';
					}
					case net__urllib__EncodingMode__encode_path_segment: {
							return c == '/' || c == ';' || c == ',' || c == '?';
					}
					case net__urllib__EncodingMode__encode_user_password: {
							return c == '@' || c == '/' || c == '?' || c == ':';
					}
					case net__urllib__EncodingMode__encode_query_component: {
							return true;
					}
					case net__urllib__EncodingMode__encode_fragment: {
							return false;
					}
					case net__urllib__EncodingMode__encode_host:
					case net__urllib__EncodingMode__encode_zone:
					default: {
							break;
					}
				}
				
				break;
		}
		default: {
				break;
		}
	}
	
	if (mode == net__urllib__EncodingMode__encode_fragment) {
		switch (c) {
			case '!': case '(': case ')': case '*': {
					return false;
			}
			default: {
					break;
			}
		}
		
	}
	return true;
}
_result_string net__urllib__query_unescape(string s) {
	return net__urllib__unescape(s, net__urllib__EncodingMode__encode_query_component);
}
VV_LOCAL_SYMBOL _result_string net__urllib__unescape(string s_, net__urllib__EncodingMode mode) {
	string s = s_;
	int n = 0;
	bool has_plus = false;
	for (int i = 0; i < s.len; ) {
		u8 x = string_at(s, i);

		if (x == ('%')) {
			if ((s).len == 0) {
				break;
			}
			n++;
			if ((int)(i + 2) >= s.len || !net__urllib__ishex(string_at(s, (int)(i + 1))) || !net__urllib__ishex(string_at(s, (int)(i + 2)))) {
				if (mode == net__urllib__EncodingMode__encode_query_component && (int)(i + 1) < s.len) {
					s = string__plus(string__plus(string_substr(s, 0, i), _SLIT("%25")), string_substr(s, ((int)(i + 1)), 2147483647));
					i += 4;
					continue;
				}
				s = string_substr(s, i, 2147483647);
				if (s.len > 3) {
					s = string_substr(s, 0, 3);
				}
				return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_const_net__urllib__err_msg_escape, s)), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			if ((int)(i + 3) >= s.len && mode == net__urllib__EncodingMode__encode_host && net__urllib__unhex(string_at(s, (int)(i + 1))) < 8 && !string__eq(string_substr(s, i, (int)(i + 3)), _SLIT("%25"))) {
				return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_const_net__urllib__err_msg_escape, string_substr(s, i, (int)(i + 3)))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			if (mode == net__urllib__EncodingMode__encode_zone) {
				if ((int)(i + 3) >= s.len) {
					return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("unescape: invalid escape sequence"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				u8 v = ((((net__urllib__unhex(string_at(s, (int)(i + 1))) << ((u8)(4)))) | net__urllib__unhex(string_at(s, (int)(i + 2)))));
				if (!string__eq(string_substr(s, i, (int)(i + 3)), _SLIT("%25")) && v != ' ' && net__urllib__should_escape(v, net__urllib__EncodingMode__encode_host)) {
					_v_error(net__urllib__error_msg(_const_net__urllib__err_msg_escape, string_substr(s, i, (int)(i + 3))));
				}
			}
			i += 3;
		}
		else if (x == ('+')) {
			has_plus = mode == net__urllib__EncodingMode__encode_query_component;
			i++;
		}
		else {
			if ((mode == net__urllib__EncodingMode__encode_host || mode == net__urllib__EncodingMode__encode_zone) && string_at(s, i) < 0x80 && net__urllib__should_escape(string_at(s, i), mode)) {
				_v_error(net__urllib__error_msg(_SLIT("unescape: invalid character in host name"), string_substr(s, i, (int)(i + 1))));
			}
			i++;
		}
	}
	if (n == 0 && !has_plus) {
		_result_string _t4 = {0};
		_result_ok(&(string[]) { str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})) }, (_result*)(&_t4), sizeof(string));
		return _t4;
	}
	if (s.len < (int)(2 * n)) {
		return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("unescape: invalid escape sequence"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	strings__Builder t = strings__new_builder((int)(s.len - (int)(2 * n)));
	for (int i = 0; i < s.len; i++) {
		u8 x = string_at(s, i);

		if (x == ('%')) {
			if ((int)(i + 2) >= s.len) {
				return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("unescape: invalid escape sequence"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			strings__Builder_write_string(&t, u8_ascii_str(((((net__urllib__unhex(string_at(s, (int)(i + 1))) << ((u8)(4)))) | net__urllib__unhex(string_at(s, (int)(i + 2)))))));
			i += 2;
		}
		else if (x == ('+')) {
			if (mode == net__urllib__EncodingMode__encode_query_component) {
				strings__Builder_write_string(&t, _SLIT(" "));
			} else {
				strings__Builder_write_string(&t, _SLIT("+"));
			}
		}
		else {
			strings__Builder_write_string(&t, u8_ascii_str(string_at(s, i)));
		}
	}
	_result_string _t7 = {0};
	_result_ok(&(string[]) { strings__Builder_str(&t) }, (_result*)(&_t7), sizeof(string));
	return _t7;
}
VV_LOCAL_SYMBOL string net__urllib__escape(string s, net__urllib__EncodingMode mode) {
	int space_count = 0;
	int hex_count = 0;
	u8 c = ((u8)(0));
	for (int i = 0; i < s.len; ++i) {
		c = string_at(s, i);
		if (net__urllib__should_escape(c, mode)) {
			if (c == ' ' && mode == net__urllib__EncodingMode__encode_query_component) {
				space_count++;
			} else {
				hex_count++;
			}
		}
	}
	if (space_count == 0 && hex_count == 0) {
		return s;
	}
	int required = (int)(s.len + (int)(2 * hex_count));
	Array_u8 t = __new_array_with_default_noscan(required, 0, sizeof(u8), 0);
	if (hex_count == 0) {
		copy(&t, string_bytes(s));
		for (int i = 0; i < s.len; ++i) {
			if (string_at(s, i) == ' ') {
				array_set(&t, i, &(u8[]) { '+' });
			}
		}
		return Array_u8_bytestr(t);
	}
	string upperhex = _SLIT("0123456789ABCDEF");
	int j = 0;
	for (int i = 0; i < s.len; ++i) {
		u8 c1 = string_at(s, i);
		if (c1 == ' ' && mode == net__urllib__EncodingMode__encode_query_component) {
			array_set(&t, j, &(u8[]) { '+' });
			j++;
		} else if (net__urllib__should_escape(c1, mode)) {
			array_set(&t, j, &(u8[]) { '%' });
			array_set(&t, (int)(j + 1), &(u8[]) { string_at(upperhex, (c1 >> 4)) });
			array_set(&t, (int)(j + 2), &(u8[]) { string_at(upperhex, (c1 & 15)) });
			j += 3;
		} else {
			array_set(&t, j, &(u8[]) { string_at(s, i) });
			j++;
		}
	}
	return Array_u8_bytestr(t);
}
net__urllib__Userinfo* net__urllib__user(string username) {
	return ((net__urllib__Userinfo*)memdup(&(net__urllib__Userinfo){.username = username,.password = _SLIT(""),.password_set = false,}, sizeof(net__urllib__Userinfo)));
}
VV_LOCAL_SYMBOL net__urllib__Userinfo* net__urllib__user_password(string username, string password) {
	return ((net__urllib__Userinfo*)memdup(&(net__urllib__Userinfo){.username = username,.password = password,.password_set = true,}, sizeof(net__urllib__Userinfo)));
}
VV_LOCAL_SYMBOL bool net__urllib__Userinfo_empty(net__urllib__Userinfo* u) {
	return isnil(u) || ((u->username).len == 0 && (u->password).len == 0);
}
VV_LOCAL_SYMBOL string net__urllib__Userinfo_str(net__urllib__Userinfo* u) {
	if (net__urllib__Userinfo_empty(u)) {
		return _SLIT("");
	}
	string s = net__urllib__escape(u->username, net__urllib__EncodingMode__encode_user_password);
	if (u->password_set) {
		s = string__plus(s, string__plus(_SLIT(":"), net__urllib__escape(u->password, net__urllib__EncodingMode__encode_user_password)));
	}
	return s;
}
VV_LOCAL_SYMBOL _result_Array_string net__urllib__split_by_scheme(string rawurl) {
	for (int i = 0; i < rawurl.len; ++i) {
		u8 c = string_at(rawurl, i);
		if (u8_is_letter(c)) {
		} else if (u8_is_digit(c) || (c == '+' || c == '-' || c == '.')) {
			if (i == 0) {
				_result_Array_string _t1 = {0};
				_result_ok(&(Array_string[]) { new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(""), string_clone(rawurl)})) }, (_result*)(&_t1), sizeof(Array_string));
				return _t1;
			}
		} else if (c == ':') {
			if (i == 0) {
				return (_result_Array_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("split_by_scheme: missing protocol scheme"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			_result_Array_string _t3 = {0};
			_result_ok(&(Array_string[]) { new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_substr(rawurl, 0, i), string_substr(rawurl, (int_literal)(i + 1), 2147483647)})) }, (_result*)(&_t3), sizeof(Array_string));
			return _t3;
		} else {
			_result_Array_string _t4 = {0};
			_result_ok(&(Array_string[]) { new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(""), string_clone(rawurl)})) }, (_result*)(&_t4), sizeof(Array_string));
			return _t4;
		}
	}
	_result_Array_string _t5 = {0};
	_result_ok(&(Array_string[]) { new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(""), string_clone(rawurl)})) }, (_result*)(&_t5), sizeof(Array_string));
	return _t5;
}
VV_LOCAL_SYMBOL multi_return_string_string net__urllib__split(string s, u8 sep, bool cutc) {
	int i = string_index_u8(s, sep);
	if (i < 0) {
		return (multi_return_string_string){.arg0=s, .arg1=_SLIT("")};
	}
	if (cutc) {
		return (multi_return_string_string){.arg0=string_substr(s, 0, i), .arg1=string_substr(s, (int)(i + 1), 2147483647)};
	}
	return (multi_return_string_string){.arg0=string_substr(s, 0, i), .arg1=string_substr(s, i, 2147483647)};
}
_result_net__urllib__URL net__urllib__parse(string rawurl) {
	multi_return_string_string mr_13667 = net__urllib__split(rawurl, '#', true);
	string u = mr_13667.arg0;
	string frag = mr_13667.arg1;
	_result_net__urllib__URL _t1 = net__urllib__parse_url(u, false);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(string__plus(_SLIT("parse: failed parsing url"), str_intp(2, _MOV((StrIntpData[]){{_SLIT("["), 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("]"), 0, { .d_c = 0 }}}))), u)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	net__urllib__URL url = (*(net__urllib__URL*)_t1.data);
	if ((frag).len == 0) {
		_result_net__urllib__URL _t3 = {0};
		_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t3), sizeof(net__urllib__URL));
		return _t3;
	}
	_result_string _t4 = net__urllib__unescape(frag, net__urllib__EncodingMode__encode_fragment);
	if (_t4.is_error) {
		IError err = _t4.err;
		return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(string__plus(_SLIT("parse: failed parsing url"), str_intp(2, _MOV((StrIntpData[]){{_SLIT("["), 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("]"), 0, { .d_c = 0 }}}))), u)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	string f = (*(string*)_t4.data);
	url.fragment = f;
	_result_net__urllib__URL _t6 = {0};
	_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t6), sizeof(net__urllib__URL));
	return _t6;
}
VV_LOCAL_SYMBOL _result_net__urllib__URL net__urllib__parse_url(string rawurl, bool via_request) {
	if (net__urllib__string_contains_ctl_u8(rawurl)) {
		return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_url: invalid control character in URL"), rawurl)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if ((rawurl).len == 0 && via_request) {
		return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_url: empty URL"), rawurl)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	net__urllib__URL url = ((net__urllib__URL){.scheme = (string){.str=(byteptr)"", .is_lit=1},.opaque = (string){.str=(byteptr)"", .is_lit=1},.user = ((void*)0),.host = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.raw_path = (string){.str=(byteptr)"", .is_lit=1},.force_query = 0,.raw_query = (string){.str=(byteptr)"", .is_lit=1},.fragment = (string){.str=(byteptr)"", .is_lit=1},});
	if (_SLIT_EQ(rawurl.str, rawurl.len, "*")) {
		url.path = _SLIT("*");
		_result_net__urllib__URL _t3 = {0};
		_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t3), sizeof(net__urllib__URL));
		return _t3;
	}
	_result_Array_string _t4 = net__urllib__split_by_scheme(rawurl);
	if (_t4.is_error) {
		_result_net__urllib__URL _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	Array_string p = (*(Array_string*)_t4.data);
	url.scheme = (*(string*)array_get(p, 0));
	string rest = (*(string*)array_get(p, 1));
	url.scheme = string_to_lower(url.scheme);
	if (string_ends_with(rest, _SLIT("?")) && !string_contains(string_substr(rest, 0, 1), _SLIT("?"))) {
		url.force_query = true;
		rest = string_substr(rest, 0, (int)(rest.len - 1));
	} else {
		multi_return_string_string mr_15452 = net__urllib__split(rest, '?', true);
		string r = mr_15452.arg0;
		string raw_query = mr_15452.arg1;
		rest = r;
		url.raw_query = raw_query;
	}
	if (!string_starts_with(rest, _SLIT("/"))) {
		if ((url.scheme).len != 0) {
			url.opaque = rest;
			_result_net__urllib__URL _t6 = {0};
			_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t6), sizeof(net__urllib__URL));
			return _t6;
		}
		if (via_request) {
			return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_url: invalid URI for request"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_option_int _t8;
		if (_t8 = string_index(rest, _SLIT(":")), _t8.state == 0) {
			int colon = *(int*)_t8.data;
			_option_int _t9 = string_index(rest, _SLIT("/"));
			if (_t9.state != 0) {
				IError err = _t9.err;
				return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(_SLIT("there should be a / in the URL")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			int slash = (*(int*)_t9.data);
			if (colon >= 0 && (slash < 0 || colon < slash)) {
				return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_url: first path segment in URL cannot contain colon"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	if ((((url.scheme).len != 0 || !via_request) && !string_starts_with(rest, _SLIT("///"))) && string_starts_with(rest, _SLIT("//")) && rest.len > 2) {
		multi_return_string_string mr_16528 = net__urllib__split(string_substr(rest, 2, 2147483647), '/', false);
		string authority = mr_16528.arg0;
		string r = mr_16528.arg1;
		rest = r;
		_result_net__urllib__ParseAuthorityRes _t12 = net__urllib__parse_authority(authority);
		if (_t12.is_error) {
			_result_net__urllib__URL _t13;
			memcpy(&_t13, &_t12, sizeof(_result));
			return _t13;
		}
		
 		net__urllib__ParseAuthorityRes a = (*(net__urllib__ParseAuthorityRes*)_t12.data);
		url.user = a.user;
		url.host = a.host;
	}
	_result_bool _t14 = net__urllib__URL_set_path(&url, rest);
	if (_t14.is_error) {
		_result_net__urllib__URL _t15;
		memcpy(&_t15, &_t14, sizeof(_result));
		return _t15;
	}
	
 ;
	_result_net__urllib__URL _t16 = {0};
	_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t16), sizeof(net__urllib__URL));
	return _t16;
}
VV_LOCAL_SYMBOL _result_net__urllib__ParseAuthorityRes net__urllib__parse_authority(string authority) {
	int i = string_last_index_u8(authority, '@');
	if (i < 0) {
		_result_string _t2 = net__urllib__parse_host(authority);
		if (_t2.is_error) {
			_result_net__urllib__ParseAuthorityRes _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 		_result_net__urllib__ParseAuthorityRes _t1 = {0};
		_result_ok(&(net__urllib__ParseAuthorityRes[]) { ((net__urllib__ParseAuthorityRes){.user = net__urllib__user(_SLIT("")),.host = (*(string*)_t2.data),}) }, (_result*)(&_t1), sizeof(net__urllib__ParseAuthorityRes));
		return _t1;
	}
	string raw_user = string_substr(authority, 0, i);
	string raw_host = string_substr(authority, (int)(i + 1), 2147483647);
	if (!net__urllib__valid_userinfo(raw_user)) {
		return (_result_net__urllib__ParseAuthorityRes){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_authority: invalid userinfo"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_string _t5 = net__urllib__parse_host(raw_host);
	if (_t5.is_error) {
		_result_net__urllib__ParseAuthorityRes _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 	string host = (*(string*)_t5.data);
	multi_return_string_string mr_17362 = net__urllib__split(raw_user, ':', true);
	string name = mr_17362.arg0;
	string pwd = mr_17362.arg1;
	net__urllib__Userinfo* _t7; /* if prepend */
	if ((pwd).len != 0) {
		_result_string _t8 = net__urllib__unescape(name, net__urllib__EncodingMode__encode_user_password);
		if (_t8.is_error) {
			_result_net__urllib__ParseAuthorityRes _t9;
			memcpy(&_t9, &_t8, sizeof(_result));
			return _t9;
		}
		_result_string _t10 = net__urllib__unescape(pwd, net__urllib__EncodingMode__encode_user_password);
		if (_t10.is_error) {
			_result_net__urllib__ParseAuthorityRes _t11;
			memcpy(&_t11, &_t10, sizeof(_result));
			return _t11;
		}
		
 		
 		_t7 = net__urllib__user_password((*(string*)_t8.data), (*(string*)_t10.data));
	} else {
		_result_string _t12 = net__urllib__unescape(name, net__urllib__EncodingMode__encode_user_password);
		if (_t12.is_error) {
			_result_net__urllib__ParseAuthorityRes _t13;
			memcpy(&_t13, &_t12, sizeof(_result));
			return _t13;
		}
		
 		_t7 = net__urllib__user((*(string*)_t12.data));
	}
	net__urllib__Userinfo* auth = _t7;
	_result_net__urllib__ParseAuthorityRes _t14 = {0};
	_result_ok(&(net__urllib__ParseAuthorityRes[]) { ((net__urllib__ParseAuthorityRes){.user = auth,.host = host,}) }, (_result*)(&_t14), sizeof(net__urllib__ParseAuthorityRes));
	return _t14;
}
VV_LOCAL_SYMBOL _result_string net__urllib__parse_host(string host) {
	if (host.len > 0 && string_at(host, 0) == '[') {
		int i = string_last_index_u8(host, ']');
		if (i == -1) {
			return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_host: missing ']' in host"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		string colon_port = string_substr(host, (int)(i + 1), 2147483647);
		if (!net__urllib__valid_optional_port(colon_port)) {
			return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(str_intp(2, _MOV((StrIntpData[]){{_SLIT("parse_host: invalid port "), 0xfe10, {.d_s = colon_port}}, {_SLIT(" after host "), 0, { .d_c = 0 }}})), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_option_int _t3;
		if (_t3 = string_index(string_substr(host, 0, i), _SLIT("%25")), _t3.state == 0) {
			int zone = *(int*)_t3.data;
			_result_string _t4 = net__urllib__unescape(string_substr(host, 0, zone), net__urllib__EncodingMode__encode_host);
			if (_t4.is_error) {
				_result_string _t5;
				memcpy(&_t5, &_t4, sizeof(_result));
				return _t5;
			}
			
 			string host1 = (*(string*)_t4.data);
			_result_string _t6 = net__urllib__unescape(string_substr(host, zone, i), net__urllib__EncodingMode__encode_zone);
			if (_t6.is_error) {
				_result_string _t7;
				memcpy(&_t7, &_t6, sizeof(_result));
				return _t7;
			}
			
 			string host2 = (*(string*)_t6.data);
			_result_string _t8 = net__urllib__unescape(string_substr(host, i, 2147483647), net__urllib__EncodingMode__encode_host);
			if (_t8.is_error) {
				_result_string _t9;
				memcpy(&_t9, &_t8, sizeof(_result));
				return _t9;
			}
			
 			string host3 = (*(string*)_t8.data);
			_result_string _t10 = {0};
			_result_ok(&(string[]) { string__plus(string__plus(host1, host2), host3) }, (_result*)(&_t10), sizeof(string));
			return _t10;
		}
	} else {
		int i = string_last_index_u8(host, ':');
		if (i != -1) {
			string colon_port = string_substr(host, i, 2147483647);
			if (!net__urllib__valid_optional_port(colon_port)) {
				return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(str_intp(2, _MOV((StrIntpData[]){{_SLIT("parse_host: invalid port "), 0xfe10, {.d_s = colon_port}}, {_SLIT(" after host "), 0, { .d_c = 0 }}})), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	_result_string _t12 = net__urllib__unescape(host, net__urllib__EncodingMode__encode_host);
	if (_t12.is_error) {
		_result_string _t13;
		memcpy(&_t13, &_t12, sizeof(_result));
		return _t13;
	}
	
 	string h = (*(string*)_t12.data);
	_result_string _t14 = {0};
	_result_ok(&(string[]) { h }, (_result*)(&_t14), sizeof(string));
	return _t14;
}
_result_bool net__urllib__URL_set_path(net__urllib__URL* u, string p) {
	_result_string _t1 = net__urllib__unescape(p, net__urllib__EncodingMode__encode_path);
	if (_t1.is_error) {
		_result_bool _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	u->path = (*(string*)_t1.data);
	u->raw_path = (string__eq(p, net__urllib__escape(u->path, net__urllib__EncodingMode__encode_path)) ? (_SLIT("")) : (p));
	_result_bool _t3 = {0};
	_result_ok(&(bool[]) { true }, (_result*)(&_t3), sizeof(bool));
	return _t3;
}
string net__urllib__URL_escaped_path(net__urllib__URL* u) {
	if ((u->raw_path).len != 0 && net__urllib__valid_encoded_path(u->raw_path)) {
		_result_string _t1 = net__urllib__unescape(u->raw_path, net__urllib__EncodingMode__encode_path);
		if (_t1.is_error) {
			IError err = _t1.err;
			return _SLIT("");
		}
		
 ;
		return u->raw_path;
	}
	if (fast_string_eq(u->path, _SLIT("*"))) {
		return _SLIT("*");
	}
	return net__urllib__escape(u->path, net__urllib__EncodingMode__encode_path);
}
VV_LOCAL_SYMBOL bool net__urllib__valid_encoded_path(string s) {
	for (int i = 0; i < s.len; ++i) {
		u8 x = string_at(s, i);

		if (x == ('!') || x == ('$') || x == ('&') || x == ('\\') || x == ('(') || x == (')') || x == ('*') || x == ('+') || x == (',') || x == (';') || x == ('=') || x == (':') || x == ('@')) {
		}
		else if (x == ('[') || x == (']')) {
		}
		else if (x == ('%')) {
		}
		else {
			if (net__urllib__should_escape(string_at(s, i), net__urllib__EncodingMode__encode_path)) {
				return false;
			}
		}
	}
	return true;
}
VV_LOCAL_SYMBOL bool net__urllib__valid_optional_port(string port) {
	if ((port).len == 0) {
		return true;
	}
	if (string_at(port, 0) != ':') {
		return false;
	}
	for (int _t3 = 0; _t3 < string_substr(port, 1, 2147483647).len; ++_t3) {
		u8 b = string_substr(port, 1, 2147483647).str[_t3];
		if (b < '0' || b > '9') {
			return false;
		}
	}
	return true;
}
string net__urllib__URL_str(net__urllib__URL u) {
	strings__Builder buf = strings__new_builder(200);
	if ((u.scheme).len != 0) {
		strings__Builder_write_string(&buf, u.scheme);
		strings__Builder_write_string(&buf, _SLIT(":"));
	}
	if ((u.opaque).len != 0) {
		strings__Builder_write_string(&buf, u.opaque);
	} else {
		if ((u.scheme).len != 0 || (u.host).len != 0 || !net__urllib__Userinfo_empty(u.user)) {
			if ((u.host).len != 0 || (u.path).len != 0 || !net__urllib__Userinfo_empty(u.user)) {
				strings__Builder_write_string(&buf, _SLIT("//"));
			}
			if (!net__urllib__Userinfo_empty(u.user)) {
				strings__Builder_write_string(&buf, net__urllib__Userinfo_str(u.user));
				strings__Builder_write_string(&buf, _SLIT("@"));
			}
			if ((u.host).len != 0) {
				strings__Builder_write_string(&buf, net__urllib__escape(u.host, net__urllib__EncodingMode__encode_host));
			}
		}
		string path = net__urllib__URL_escaped_path(&u);
		if ((path).len != 0 && string_at(path, 0) != '/' && (u.host).len != 0) {
			strings__Builder_write_string(&buf, _SLIT("/"));
		}
		if (buf.len == 0) {
			int i = string_index_u8(path, ':');
			if (i > -1) {
				if (i > -1 && string_index_u8(string_substr(path, 0, i), '/') == -1) {
					strings__Builder_write_string(&buf, _SLIT("./"));
				}
			}
		}
		strings__Builder_write_string(&buf, path);
	}
	if (u.force_query || (u.raw_query).len != 0) {
		strings__Builder_write_string(&buf, _SLIT("?"));
		strings__Builder_write_string(&buf, u.raw_query);
	}
	if ((u.fragment).len != 0) {
		strings__Builder_write_string(&buf, _SLIT("#"));
		strings__Builder_write_string(&buf, net__urllib__escape(u.fragment, net__urllib__EncodingMode__encode_fragment));
	}
	return strings__Builder_str(&buf);
}
VV_LOCAL_SYMBOL net__urllib__Values net__urllib__parse_query_silent(string query) {
	net__urllib__Values m = net__urllib__new_values();
	_result_bool _t1 = net__urllib__parse_query_values((voidptr)&m, query);
	(void)_t1;
 ;
	return m;
}
VV_LOCAL_SYMBOL _result_bool net__urllib__parse_query_values(net__urllib__Values* m, string query) {
	bool had_error = false;
	string q = query;
	for (;;) {
		if (!((q).len != 0)) break;
		string key = q;
		int i = string_index_any(key, _SLIT("&;"));
		if (i >= 0) {
			q = string_substr(key, (int)(i + 1), 2147483647);
			key = string_substr(key, 0, i);
		} else {
			q = _SLIT("");
		}
		if ((key).len == 0) {
			continue;
		}
		string value = _SLIT("");
		_option_int _t1;
		if (_t1 = string_index(key, _SLIT("=")), _t1.state == 0) {
			int idx = *(int*)_t1.data;
			i = idx;
			value = string_substr(key, (int)(i + 1), 2147483647);
			key = string_substr(key, 0, i);
		}
		_result_string _t2 = net__urllib__query_unescape(key);
		if (_t2.is_error) {
			IError err = _t2.err;
			had_error = true;
			continue;
		}
		
 		string k = (*(string*)_t2.data);
		key = k;
		_result_string _t3 = net__urllib__query_unescape(value);
		if (_t3.is_error) {
			IError err = _t3.err;
			had_error = true;
			continue;
		}
		
 		string v = (*(string*)_t3.data);
		value = v;
		net__urllib__Values_add(m, key, value);
	}
	if (had_error) {
		return (_result_bool){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_query_values: failed parsing query string"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_bool _t5 = {0};
	_result_ok(&(bool[]) { true }, (_result*)(&_t5), sizeof(bool));
	return _t5;
}
net__urllib__Values net__urllib__URL_query(net__urllib__URL* u) {
	net__urllib__Values v = net__urllib__parse_query_silent(u->raw_query);
	return v;
}
multi_return_string_string net__urllib__split_host_port(string hostport) {
	string host = hostport;
	string port = _SLIT("");
	int colon = string_last_index_u8(host, ':');
	if (colon != -1) {
		if (net__urllib__valid_optional_port(string_substr(host, colon, 2147483647))) {
			port = string_substr(host, (int)(colon + 1), 2147483647);
			host = string_substr(host, 0, colon);
		}
	}
	if (host.len > 1 && string_at(host, 0) == '[' && string_ends_with(host, _SLIT("]"))) {
		host = string_substr(host, 1, (int)(host.len - 1));
	}
	return (multi_return_string_string){.arg0=host, .arg1=port};
}
bool net__urllib__valid_userinfo(string s) {
	for (int _t1 = 0; _t1 < s.len; ++_t1) {
		u8 r = s.str[_t1];
		if (u8_is_alnum(r)) {
			continue;
		}

		if (r == ('-') || r == ('.') || r == ('_') || r == (':') || r == ('~') || r == ('!') || r == ('$') || r == ('&') || r == ('\\') || r == ('(') || r == (')') || r == ('*') || r == ('+') || r == (',') || r == (';') || r == ('=') || r == ('%') || r == ('@')) {
			continue;
		}
		else {
			return false;
		}
	}
	return true;
}
VV_LOCAL_SYMBOL bool net__urllib__string_contains_ctl_u8(string s) {
	for (int i = 0; i < s.len; ++i) {
		u8 b = string_at(s, i);
		if (b < ' ' || b == 0x7f) {
			return true;
		}
	}
	return false;
}
bool net__urllib__ishex(u8 c) {
	if ('0' <= c && c <= '9') {
		return true;
	} else if ('a' <= c && c <= 'f') {
		return true;
	} else if ('A' <= c && c <= 'F') {
		return true;
	}
	return false;
}
VV_LOCAL_SYMBOL u8 net__urllib__unhex(u8 c) {
	if ('0' <= c && c <= '9') {
		return (rune)(c - '0');
	} else if ('a' <= c && c <= 'f') {
		return (rune)((rune)(c - 'a') + 10);
	} else if ('A' <= c && c <= 'F') {
		return (rune)((rune)(c - 'A') + 10);
	}
	return 0;
}
net__urllib__Values net__urllib__new_values(void) {
	return ((net__urllib__Values){.data = __new_array_with_default(0, 0, sizeof(net__urllib__QueryValue), 0),.len = 0,});
}
void net__urllib__Values_add(net__urllib__Values* v, string key, string value) {
	array_push((array*)&v->data, _MOV((net__urllib__QueryValue[]){ ((net__urllib__QueryValue){.key = key,.value = value,}) }));
	v->len = v->data.len;
}
io__BufferedReader* io__new_buffered_reader(io__BufferedReaderConfig o) {
	if (o.cap <= 0) {
		_v_panic(_SLIT("new_buffered_reader should be called with a positive `cap`"));
		VUNREACHABLE();
	}
	io__BufferedReader* r = ((io__BufferedReader*)memdup(&(io__BufferedReader){.reader = o.reader,.buf = __new_array_with_default_noscan(o.cap, o.cap, sizeof(u8), 0),.offset = 0,.len = 0,.fails = 0,.mfails = o.retries,.end_of_stream = 0,.total_read = 0,}, sizeof(io__BufferedReader)));
	return r;
}
_result_int io__BufferedReader_read(io__BufferedReader* r, Array_u8* buf) {
	if (r->end_of_stream) {
		return (_result_int){ .is_error=true, .err=I_io__Eof_to_Interface_IError(((io__Eof*)memdup(&(io__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(io__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (io__BufferedReader_needs_fill(*r)) {
		if (!io__BufferedReader_fill_buffer(r)) {
			return (_result_int){ .is_error=true, .err=I_io__Eof_to_Interface_IError(((io__Eof*)memdup(&(io__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(io__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	int read = copy(buf, array_slice(r->buf, r->offset, r->len));
	if (read == 0) {
		return (_result_int){ .is_error=true, .err=I_io__NotExpected_to_Interface_IError(((io__NotExpected*)memdup(&(io__NotExpected){.cause = _SLIT("invalid copy of buffer"),.code = -1,}, sizeof(io__NotExpected)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	r->offset += read;
	r->total_read += read;
	_result_int _t4 = {0};
	_result_ok(&(int[]) { read }, (_result*)(&_t4), sizeof(int));
	return _t4;
}
void io__BufferedReader_free(io__BufferedReader* r) {
	array_free(&r->buf);
}
VV_LOCAL_SYMBOL bool io__BufferedReader_fill_buffer(io__BufferedReader* r) {
	if (r->end_of_stream) {
		return true;
	}
	r->offset = 0;
	r->len = 0;
	_result_int _t2 = io__Reader_name_table[r->reader._typ]._method_read(r->reader._object, &r->buf);
	if (_t2.is_error) {
		IError err = _t2.err;
		r->end_of_stream = true;
		return false;
	}
	
 	r->len = (*(int*)_t2.data);
	if (r->len == 0) {
		r->fails++;
	} else {
		r->fails = 0;
	}
	if (r->fails >= r->mfails) {
		r->end_of_stream = true;
		return false;
	}
	return true;
}
VV_LOCAL_SYMBOL bool io__BufferedReader_needs_fill(io__BufferedReader r) {
	return r.offset >= r.len;
}
bool io__BufferedReader_end_of_stream(io__BufferedReader r) {
	return r.end_of_stream;
}
_result_string io__BufferedReader_read_line(io__BufferedReader* r, io__BufferedReadLineConfig config) {
	if (r->end_of_stream) {
		return (_result_string){ .is_error=true, .err=I_io__Eof_to_Interface_IError(((io__Eof*)memdup(&(io__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(io__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_u8 line = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
	for (;;) {
		if (io__BufferedReader_needs_fill(*r)) {
			if (!io__BufferedReader_fill_buffer(r)) {
				if (line.len == 0) {
					return (_result_string){ .is_error=true, .err=I_io__Eof_to_Interface_IError(((io__Eof*)memdup(&(io__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(io__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				_result_string _t3 = {0};
				_result_ok(&(string[]) { Array_u8_bytestr(line) }, (_result*)(&_t3), sizeof(string));
				return _t3;
			}
		}
		int i = r->offset;
		for (; i < r->len; i++) {
			r->total_read++;
			u8 c = (*(u8*)array_get(r->buf, i));
			if (c == config.delim) {
				if (i != 0 && config.delim == '\n' && (*(u8*)array_get(r->buf, (int)(i - 1))) == '\r') {
					int x = (int)(i - 1);
					_PUSH_MANY_noscan(&line, (array_slice(r->buf, r->offset, x)), _t4, Array_u8);
				} else {
					_PUSH_MANY_noscan(&line, (array_slice(r->buf, r->offset, i)), _t5, Array_u8);
				}
				r->offset = (int)(i + 1);
				_result_string _t6 = {0};
				_result_ok(&(string[]) { Array_u8_bytestr(line) }, (_result*)(&_t6), sizeof(string));
				return _t6;
			}
		}
		_PUSH_MANY_noscan(&line, (array_slice(r->buf, r->offset, i)), _t7, Array_u8);
		r->offset = i;
	}
	return (_result_string){ .is_error=true, .err=I_io__Eof_to_Interface_IError(((io__Eof*)memdup(&(io__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(io__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
}
int io__BufferedWriter_buffered(io__BufferedWriter b) {
	return b.n;
}
_result_void io__BufferedWriter_flush(io__BufferedWriter* b) {
	if (io__BufferedWriter_buffered(*b) == 0) {
		return (_result_void){0};
	}
	_result_int _t1 = io__Writer_name_table[b->wr._typ]._method_write(b->wr._object, array_slice(b->buf, 0, b->n));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	int n = (*(int*)_t1.data);
	if (n < b->n) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("Writer accepted less bytes than expected without returning any explicit error.")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	b->n = 0;
	return (_result_void){0};
}
int io__BufferedWriter_available(io__BufferedWriter b) {
	return (int)(b.buf.len - b.n);
}
_result_int io__BufferedWriter_write(io__BufferedWriter* b, Array_u8 src) {
	Array_u8 p = array_clone_to_depth(&src, 0);
	int nn = 0;
	for (;;) {
		if (!(p.len > io__BufferedWriter_available(*b))) break;
		int n = 0;
		if (io__BufferedWriter_buffered(*b) == 0) {
			_result_int _t1 = io__Writer_name_table[b->wr._typ]._method_write(b->wr._object, p);
			if (_t1.is_error) {
				_result_int _t2;
				memcpy(&_t2, &_t1, sizeof(_result));
				return _t2;
			}
			
 			n = (*(int*)_t1.data);
		} else {
			n = copy(&(array[]){array_slice(b->buf, b->n, 2147483647)}[0], p);
			b->n += n;
			_result_void _t3 = io__BufferedWriter_flush(b);
			if (_t3.is_error) {
				_result_int _t4;
				memcpy(&_t4, &_t3, sizeof(_result));
				return _t4;
			}
			
 ;
		}
		nn += n;
		p = array_clone_static_to_depth(array_slice(p, n, 2147483647), 0);
	}
	int n = copy(&(array[]){array_slice(b->buf, b->n, 2147483647)}[0], p);
	b->n += n;
	nn += n;
	_result_int _t5 = {0};
	_result_ok(&(int[]) { nn }, (_result*)(&_t5), sizeof(int));
	return _t5;
}
_result_int io__MultiWriter_write(io__MultiWriter* m, Array_u8 buf) {
	for (int _t1 = 0; _t1 < m->writers.len; ++_t1) {
		io__Writer* w = ((io__Writer*)m->writers.data) + _t1;
		_result_int _t2 = io__Writer_name_table[w->_typ]._method_write(w->_object, buf);
		if (_t2.is_error) {
			_result_int _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 		int n = (*(int*)_t2.data);
		if (n != buf.len) {
			return (_result_int){ .is_error=true, .err=_v_error(_SLIT("io: incomplete write to writer of MultiWriter")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	_result_int _t5 = {0};
	_result_ok(&(int[]) { buf.len }, (_result*)(&_t5), sizeof(int));
	return _t5;
}
VV_LOCAL_SYMBOL string io__NotExpected_msg(io__NotExpected err) {
	return err.cause;
}
VV_LOCAL_SYMBOL int io__NotExpected_code(io__NotExpected err) {
	return err.code;
}
_result_int io__ReaderWriterImpl_read(io__ReaderWriterImpl* r, Array_u8* buf) {
	return io__Reader_name_table[r->r._typ]._method_read(r->r._object, buf);
}
_result_int io__ReaderWriterImpl_write(io__ReaderWriterImpl* r, Array_u8 buf) {
	return io__Writer_name_table[r->w._typ]._method_write(r->w._object, buf);
}
Array_string arrays__uniq_T_string(Array_string a) {
	Array_string res = __new_array_with_default(0, (int)(a.len / 10), sizeof(string), 0);
	int j = -1;
	if (a.len > 0) {
		j = 0;
		array_push((array*)&res, _MOV((string[]){ (*(string*)array_get(a, 0)) }));
	}
	for (int idx = 0; idx < a.len; ++idx) {
		string e = ((string*)a.data)[idx];
		if (string__eq((*(string*)array_get(a, j)), e)) {
			continue;
		}
		j = idx;
		array_push((array*)&res, _MOV((string[]){ string_clone(e) }));
	}
	return res;
}
#if !defined(_WIN32) && !defined(__ANDROID__)
#endif
u16 net__conv__hton16(u16 host) {
	#if defined(TARGET_ORDER_IS_LITTLE)
	{
		return net__conv__reverse_bytes_u16(host);
	}
	#else
	{
		return host;
	}
	#endif
	return 0;
}
u16 net__conv__ntoh16(u16 net) {
	return net__conv__hton16(net);
}
inline u16 net__conv__reverse_bytes_u16(u16 a) {
	return (((((a >> 8U)) & 0x00FFU)) | ((((a << 8U)) & 0xFF00U)));
}
void strings__textscanner__TextScanner_free(strings__textscanner__TextScanner* ss) {
	string_free(&ss->input);
}
inline term__termios__TcFlag term__termios__invert(term__termios__TcFlag value) {
	return ~((int)(value));
}
inline int term__termios__tcgetattr(int fd, term__termios__Termios* termios_p) {
	{ // Unsafe block
		return tcgetattr(fd, ((struct termios*)(termios_p)));
	}
	return 0;
}
inline int term__termios__tcsetattr(int fd, int optional_actions, term__termios__Termios* termios_p) {
	{ // Unsafe block
		return tcsetattr(fd, optional_actions, ((struct termios*)(termios_p)));
	}
	return 0;
}
int term__termios__set_state(int fd, term__termios__Termios new_state) {
	term__termios__Termios x = new_state;
	return term__termios__tcsetattr(0, TCSANOW, (voidptr)&x);
}
void term__termios__Termios_disable_echo(term__termios__Termios* t) {
	t->c_lflag &= term__termios__invert(ECHO);
}
VV_LOCAL_SYMBOL void picohttpparser__Request_phr_parse_request_path(picohttpparser__Request* r, u8* buf_start, u8* buf_end, picohttpparser__Pret* pret) {
	u8* buf = buf_start + 0;
	string method = picohttpparser__advance_token(buf, buf_end, pret);
	if (pret->ret < 0) {
		return;
	}
	{ // Unsafe block
		buf += pret->ret;
	}
	for (;;) {
		buf++;
		if (*buf != ' ') {
			break;
		}
	}
	string path = picohttpparser__advance_token(buf, buf_end, pret);
	if (pret->ret < 0) {
		return;
	}
	{ // Unsafe block
		buf += pret->ret;
	}
	for (;;) {
		buf++;
		if (*buf != ' ') {
			break;
		}
	}
	if ((method).len == 0 || (path).len == 0) {
		pret->ret = -1;
		pret->err = _SLIT("error parsing request: invalid method or path");
		return;
	}
	r->method = method;
	r->path = path;
	pret->ret = buf - buf_start;
}
VV_LOCAL_SYMBOL u8* picohttpparser__Request_phr_parse_request(picohttpparser__Request* r, u8* buf_start, u8* buf_end, picohttpparser__Pret* pret) {
	u8* buf = buf_start;
	if (buf == buf_end) {
		pret->ret = -2;
		return ((void*)0);
	}
	if (*buf == '\r') {
		buf++;
		if (buf == buf_end) {
			pret->ret = -2;
			return ((void*)0);
		}
		if (*buf != '\n') {
			pret->ret = -1;
			pret->err = _SLIT("error parsing request: expected \"\n\" after \"\r\"");
			return ((void*)0);
		}
	}
	picohttpparser__Request_phr_parse_request_path(r, buf, buf_end, pret);
	if (pret->ret < 0) {
		return ((void*)0);
	}
	{ // Unsafe block
		buf += pret->ret;
	}
	int minor_version = picohttpparser__parse_http_version(buf, buf_end, pret);
	if (pret->ret < 0) {
		return ((void*)0);
	}
	{ // Unsafe block
		buf += pret->ret;
	}
	if (buf == buf_end) {
		pret->ret = -2;
		return ((void*)0);
	}
	if (*buf == '\r') {
		buf++;
		if (buf == buf_end) {
			pret->ret = -2;
			return ((void*)0);
		}
		if (*buf != '\n') {
			pret->ret = -1;
			pret->err = _SLIT("error parsing request: expected \"\n\" after \"\r\"");
			return ((void*)0);
		}
		buf++;
	} else if (*buf == '\n') {
		buf++;
	} else {
		pret->ret = -1;
		pret->err = _SLIT("error parsing request: expecting \"\r\n\" after HTTP version");
		return ((void*)0);
	}
	return picohttpparser__Request_parse_headers(r, buf, buf_end, pret);
}
VV_LOCAL_SYMBOL u8* picohttpparser__Request_parse_headers(picohttpparser__Request* r, u8* buf_start, u8* buf_end, picohttpparser__Pret* pret) {
	u8* buf = buf_start;
	int i = 0;
	for (i = r->num_headers; i < 100; i++) {
		if (buf == buf_end) {
			pret->ret = -2;
			return ((void*)0);
		}
		if (*buf == '\r') {
			buf++;
			if (buf == buf_end) {
				pret->ret = -2;
				return ((void*)0);
			}
			if (*buf != '\n') {
				pret->ret = -1;
				pret->err = _SLIT("error parsing request: expected \"\n\" after \"\r\"");
				return ((void*)0);
			}
			buf++;
			break;
		} else if (*buf == '\n') {
			buf++;
			break;
		}
		if (!(*buf == ' ' || *buf == '\t')) {
			u8* name_start = buf;
			for (;;) {
				if (!(*buf != ':')) break;
				if (_const_picohttpparser__token_char_map.str[ *buf] == 0) {
					pret->ret = -1;
					pret->err = str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing request: invalid character in header \""), 0xfe02, {.d_u8 = *buf}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
					return ((void*)0);
				}
				buf++;
				if (buf == buf_end) {
					pret->ret = -2;
					return ((void*)0);
				}
			}
			int name_len = buf - name_start;
			if (name_len == 0) {
				pret->ret = -1;
				pret->err = _SLIT("error parsing request: invalid header name");
				return ((void*)0);
			}
			r->headers[i].name = tos(name_start, name_len);
			buf++;
			for (;;) {
				if (buf == buf_end) {
					pret->ret = -2;
					return ((void*)0);
				}
				if (!(*buf == ' ' || *buf == '\t')) {
					break;
				}
				buf++;
			}
		} else {
			r->headers[i].name = _SLIT("");
		}
		int value_len = picohttpparser__get_token_length_to_eol(buf, buf_end, pret);
		if (pret->ret < 0) {
			return ((void*)0);
		}
		u8* value_end = buf + value_len;
		for (;;) {
			if (!(value_end != buf)) break;
			u8 c = *(value_end - 1);
			if (!(c == ' ' || c == '\t')) {
				break;
			}
			value_end--;
		}
		r->headers[i].value = tos(buf, value_end - buf);
		r->num_headers++;
		{ // Unsafe block
			buf += pret->ret;
		}
	}
	if (i == 100) {
		eprintln(_SLIT("Too many headers!"));
		pret->ret = -1;
		pret->err = _SLIT("error parsing request: too many headers!");
		return ((void*)0);
	}
	pret->ret = buf - buf_start;
	return buf;
}
VV_LOCAL_SYMBOL u8* picohttpparser__is_complete(u8* buf_start, u8* buf_end, int last_len, picohttpparser__Pret* pret) {
	int ret_cnt = 0;
	u8* buf = (last_len < 3 ? (buf_start) : (buf_start + last_len - 3));
	for (;;) {
		if (buf == buf_end) {
			pret->ret = -2;
			return ((void*)0);
		}
		if (*buf == '\r') {
			buf++;
			if (buf == buf_end) {
				pret->ret = -2;
				return ((void*)0);
			}
			if (*buf != '\n') {
				pret->ret = -1;
				pret->err = _SLIT("error parsing request: expected \"\n\" after \"\r\"");
				return ((void*)0);
			}
			buf++;
			ret_cnt++;
		} else if (*buf == '\n') {
			buf++;
			ret_cnt++;
		} else {
			buf++;
			ret_cnt = 0;
		}
		if (ret_cnt == 2) {
			return buf;
		}
	}
	pret->ret = -2;
	return ((void*)0);
}
VV_LOCAL_SYMBOL int picohttpparser__parse_http_version(u8* buf_start, u8* buf_end, picohttpparser__Pret* pret) {
	if (buf_end - buf_start < 9) {
		pret->ret = -2;
		return 0;
	}
	if (!string__eq(tos(buf_start, 7), _SLIT("HTTP/1."))) {
		pret->ret = -1;
		pret->err = _SLIT("error parsing request: picohttpparser only supports HTTP/1.x");
		return 0;
	}
	u8 c = *(buf_start + 7);
	if (c < '0' || c > '9') {
		pret->ret = -1;
		pret->err = _SLIT("error parsing request: invalid HTTP version");
		return 0;
	}
	pret->ret = 8;
	return ((int)((rune)(c - '0')));
}
VV_LOCAL_SYMBOL int picohttpparser__get_token_length_to_eol(u8* buf_start, u8* buf_end, picohttpparser__Pret* pret) {
	u8* buf = buf_start;
	int token_len = 0;
	for (;;) {
		if (!(_likely_(buf_end - buf >= 8))) break;
		for (int _t1 = 0; _t1 < 8; ++_t1) {
			if (_unlikely_(!picohttpparser__is_printable_ascii(*buf))) {
				{ // Unsafe block
					goto non_printable;
				}
			}
			buf++;
			continue;
			non_printable: {}
			if (_likely_(*buf < ' ' && *buf != 9) || _unlikely_(*buf == 127)) {
				{ // Unsafe block
					goto found_ctl;
				}
			}
			buf++;
		}
	}
	for (;;) {
		if (buf == buf_end) {
			pret->ret = -2;
			return 0;
		}
		if (_likely_(*buf < ' ' && *buf != 9) || _unlikely_(*buf == 127)) {
			{ // Unsafe block
				goto found_ctl;
			}
		}
		buf++;
	}
	found_ctl: {}
	if (_likely_(*buf == '\r')) {
		buf++;
		if (buf == buf_end) {
			pret->ret = -2;
			return 0;
		}
		if (*buf != '\n') {
			pret->ret = -1;
			pret->err = _SLIT("error parsing request: expected \"\n\" after \"\r\"");
			return 0;
		}
		buf++;
		token_len = buf - 2 - buf_start;
	} else if (*buf == '\n') {
		token_len = buf - buf_start;
		buf++;
	} else {
		pret->ret = -1;
		pret->err = _SLIT("error parsing request: expecting \"\r\n\" after header");
		return 0;
	}
	if (token_len == 0) {
		pret->ret = 0;
		return 0;
	}
	pret->ret = buf - buf_start;
	return token_len;
}
inline VV_LOCAL_SYMBOL string picohttpparser__advance_token(u8* tok_start, u8* tok_end, picohttpparser__Pret* pret) {
	u8* buf = tok_start;
	for (;;) {
		if (!(*buf != ' ')) break;
		if (_unlikely_(!picohttpparser__is_printable_ascii(*buf))) {
			if (*buf < ' ' || *buf == 127) {
				pret->ret = -1;
				pret->err = str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing request: invalid character \""), 0xfe02, {.d_u8 = *buf}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
				return _SLIT("");
			}
		}
		buf++;
		if (buf == tok_end) {
			pret->ret = -2;
			return _SLIT("");
		}
	}
	pret->ret = buf - tok_start;
	return tos(tok_start, pret->ret);
}
inline VV_LOCAL_SYMBOL bool picohttpparser__is_printable_ascii(u8 c) {
	return ((u32)((u8)(c - 32))) < 95U;
}
inline _result_int picohttpparser__Request_parse_request(picohttpparser__Request* r, string s) {
	u8* buf = s.str;
	u8* buf_end = s.str + s.len;
	picohttpparser__Pret pret = ((picohttpparser__Pret){.err = (string){.str=(byteptr)"", .is_lit=1},.ret = 0,});
	if (r->prev_len != 0 && picohttpparser__is_complete(buf, buf_end, r->prev_len, (voidptr)&pret) == ((void*)0)) {
		if (pret.ret == -1) {
			return (_result_int){ .is_error=true, .err=_v_error(pret.err), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_result_int _t2 = {0};
		_result_ok(&(int[]) { pret.ret }, (_result*)(&_t2), sizeof(int));
		return _t2;
	}
	buf = picohttpparser__Request_phr_parse_request(r, buf, buf_end, (voidptr)&pret);
	if (pret.ret == -1) {
		return (_result_int){ .is_error=true, .err=_v_error(pret.err), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (buf == ((void*)0)) {
		_result_int _t4 = {0};
		_result_ok(&(int[]) { pret.ret }, (_result*)(&_t4), sizeof(int));
		return _t4;
	}
	pret.ret = buf - s.str;
	r->body = u8_vstring_literal_with_len((&s.str[pret.ret]), (int)(s.len - pret.ret));
	r->prev_len = s.len;
	_result_int _t5 = {0};
	_result_ok(&(int[]) { pret.ret }, (_result*)(&_t5), sizeof(int));
	return _t5;
}
#if !defined(_WIN32)
#endif
inline int picohttpparser__Response_end(picohttpparser__Response* r) {
	int n = ((int)((i64)(((i64)(r->buf)) - ((i64)(r->buf_start)))));
	if (send(r->fd, r->buf_start, n, 0) != n) {
		return -1;
	}
	return n;
}
#if defined(_WIN32)
#else
#endif
#if defined(__TINYC__)
	#if defined(__V_amd64)
	#elif defined(__V_arm64)
	#endif
#endif
inline void encoding__binary__big_endian_put_u32(Array_u8* b, u32 v) {
	{u8 _ = ((u8*)b->data)[3];}
	;
	((u8*)b->data)[0] = ((u8)((v >> ((u32)(24U)))));
	((u8*)b->data)[1] = ((u8)((v >> ((u32)(16U)))));
	((u8*)b->data)[2] = ((u8)((v >> ((u32)(8U)))));
	((u8*)b->data)[3] = ((u8)(v));
}
inline void encoding__binary__big_endian_put_u64(Array_u8* b, u64 v) {
	{u8 _ = ((u8*)b->data)[7];}
	;
	((u8*)b->data)[0] = ((u8)((v >> ((u64)(56U)))));
	((u8*)b->data)[1] = ((u8)((v >> ((u64)(48U)))));
	((u8*)b->data)[2] = ((u8)((v >> ((u64)(40U)))));
	((u8*)b->data)[3] = ((u8)((v >> ((u64)(32U)))));
	((u8*)b->data)[4] = ((u8)((v >> ((u64)(24U)))));
	((u8*)b->data)[5] = ((u8)((v >> ((u64)(16U)))));
	((u8*)b->data)[6] = ((u8)((v >> ((u64)(8U)))));
	((u8*)b->data)[7] = ((u8)(v));
}
inline u64 hash__wymum(u64 a, u64 b) {
	u32 mask32 = ((u32)(4294967295U));
	u64 x0 = (a & mask32);
	u64 x1 = (a >> 32U);
	u64 y0 = (b & mask32);
	u64 y1 = (b >> 32U);
	u64 w0 = (u64)(x0 * y0);
	u64 t = (u64)((u64)(x1 * y0) + ((w0 >> 32U)));
	u64 w1 = (t & mask32);
	u64 w2 = (t >> 32U);
	w1 += (u64)(x0 * y1);
	u64 hi = (u64)((u64)((u64)(x1 * y1) + w2) + ((w1 >> 32U)));
	u64 lo = (u64)(a * b);
	return (hi ^ lo);
}
VV_LOCAL_SYMBOL string orm__OperationKind_to_str(orm__OperationKind kind) {
	string _t1 = (string){.str=(byteptr)"", .is_lit=1};
	switch (kind) {
		case orm__OperationKind__neq: {
				_t1 = _SLIT("<>");
				break;
		}
		case orm__OperationKind__eq: {
				_t1 = _SLIT("=");
				break;
		}
		case orm__OperationKind__gt: {
				_t1 = _SLIT(">");
				break;
		}
		case orm__OperationKind__lt: {
				_t1 = _SLIT("<");
				break;
		}
		case orm__OperationKind__ge: {
				_t1 = _SLIT(">=");
				break;
		}
		case orm__OperationKind__le: {
				_t1 = _SLIT("<=");
				break;
		}
		case orm__OperationKind__orm_like: {
				_t1 = _SLIT("LIKE");
				break;
		}
		case orm__OperationKind__orm_ilike: {
				_t1 = _SLIT("ILIKE");
				break;
		}
		case orm__OperationKind__is_null: {
				_t1 = _SLIT("IS NULL");
				break;
		}
		case orm__OperationKind__is_not_null: {
				_t1 = _SLIT("IS NOT NULL");
				break;
		}
	}
	string str = _t1;
	return str;
}
VV_LOCAL_SYMBOL bool orm__OperationKind_is_unary(orm__OperationKind kind) {
	return (kind == orm__OperationKind__is_null || kind == orm__OperationKind__is_not_null);
}
VV_LOCAL_SYMBOL string orm__OrderType_to_str(orm__OrderType kind) {
	return ((kind == (orm__OrderType__desc))? (_SLIT("DESC")) : (_SLIT("ASC")));
}
multi_return_string_orm__QueryData orm__orm_stmt_gen(orm__SQLDialect sql_dialect, string table, string q, orm__StmtKind kind, bool num, string qm, int start_pos, orm__QueryData data, orm__QueryData where) {
	string str = _SLIT("");
	int c = start_pos;
	Array_string data_fields = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_orm__Primitive data_data = __new_array_with_default(0, 0, sizeof(orm__Primitive), 0);

	if (kind == (orm__StmtKind__insert)) {
		Array_string values = __new_array_with_default(0, 0, sizeof(string), 0);
		Array_string select_fields = __new_array_with_default(0, 0, sizeof(string), 0);
		for (int i = 0; i < data.fields.len; ++i) {
			string column_name = (*(string*)array_get(data.fields, i));
			bool is_auto_field = (Array_int_contains(data.auto_fields, i));
			if (data.data.len > 0) {
				if (is_auto_field) {
					orm__Primitive x = (*(orm__Primitive*)array_get(data.data, i));
					bool skip_auto_field = ((x._typ == 144 /* orm.Null */)? (true) : (x._typ == 21 /* string */)? (((*x._string)).len == 0) : (x._typ == 5 /* i8 */)? (((u64)((*x._i8))) == 0U) : (x._typ == 6 /* i16 */)? (((u64)((*x._i16))) == 0U) : (x._typ == 8 /* int */)? (((u64)((*x._int))) == 0U) : (x._typ == 9 /* i64 */)? (((u64)((*x._i64))) == 0U) : (x._typ == 11 /* u8 */)? (((u64)((*x._u8))) == 0U) : (x._typ == 12 /* u16 */)? (((u64)((*x._u16))) == 0U) : (x._typ == 13 /* u32 */)? (((u64)((*x._u32))) == 0U) : (x._typ == 14 /* u64 */)? (((u64)((*x._u64))) == 0U) : (x._typ == 16 /* f32 */)? (((f64)((*x._f32))) == 0) : (x._typ == 17 /* f64 */)? (((f64)((*x._f64))) == 0) : (x._typ == 142 /* time.Time */)? (time__Time__eq((*x._time__Time), ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}))) : (x._typ == 19 /* bool */)? (!(*x._bool)) : (false));
					if (skip_auto_field) {
						continue;
					}
				}
				array_push((array*)&data_data, _MOV((orm__Primitive[]){ (*(orm__Primitive*)array_get(data.data, i)) }));
			}
			array_push((array*)&select_fields, _MOV((string[]){ str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = column_name}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
			array_push((array*)&values, _MOV((string[]){ orm__factory_insert_qm_value(num, qm, c) }));
			array_push((array*)&data_fields, _MOV((string[]){ string_clone(column_name) }));
			c++;
		}
		str = string__plus(str, str_intp(4, _MOV((StrIntpData[]){{_SLIT("INSERT INTO "), 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = table}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		bool are_values_empty = values.len == 0;
		if (sql_dialect == orm__SQLDialect__sqlite && are_values_empty) {
			str = string__plus(str, _SLIT("DEFAULT VALUES"));
		} else {
			str = string__plus(str, _SLIT("("));
			str = string__plus(str, Array_string_join(select_fields, _SLIT(", ")));
			str = string__plus(str, _SLIT(") VALUES ("));
			str = string__plus(str, Array_string_join(values, _SLIT(", ")));
			str = string__plus(str, _SLIT(")"));
		}
	}
	else if (kind == (orm__StmtKind__update)) {
		str = string__plus(str, str_intp(4, _MOV((StrIntpData[]){{_SLIT("UPDATE "), 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = table}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(" SET "), 0, { .d_c = 0 }}})));
		for (int i = 0; i < data.fields.len; ++i) {
			string field = ((string*)data.fields.data)[i];
			str = string__plus(str, str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = field}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(" = "), 0, { .d_c = 0 }}})));
			if (data.data.len > i) {
				orm__Primitive d = (*(orm__Primitive*)array_get(data.data, i));
				if ((d)._typ == 143 /* orm.InfixType */) {
					string op = (((*d._orm__InfixType).operator == (orm__MathOperationKind__add))? (_SLIT("+")) : ((*d._orm__InfixType).operator == (orm__MathOperationKind__sub))? (_SLIT("-")) : ((*d._orm__InfixType).operator == (orm__MathOperationKind__mul))? (_SLIT("*")) : (_SLIT("/")));
					str = string__plus(str, str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*d._orm__InfixType).name}}, {_SLIT(" "), 0xfe10, {.d_s = op}}, {_SLIT(" "), 0xfe10, {.d_s = qm}}, {_SLIT0, 0, { .d_c = 0 }}})));
				} else {
					str = string__plus(str, str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = qm}}, {_SLIT0, 0, { .d_c = 0 }}})));
				}
			} else {
				str = string__plus(str, str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = qm}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			if (num) {
				str = string__plus(str, str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = c}}, {_SLIT0, 0, { .d_c = 0 }}})));
				c++;
			}
			if (i < (int)(data.fields.len - 1)) {
				str = string__plus(str, _SLIT(", "));
			}
		}
		str = string__plus(str, _SLIT(" WHERE "));
	}
	else if (kind == (orm__StmtKind__delete)) {
		str = string__plus(str, str_intp(4, _MOV((StrIntpData[]){{_SLIT("DELETE FROM "), 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = table}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(" WHERE "), 0, { .d_c = 0 }}})));
	}
	if (kind == orm__StmtKind__update || kind == orm__StmtKind__delete) {
		str = string__plus(str, orm__gen_where_clause(where, q, qm, num, &c));
	}
	str = string__plus(str, _SLIT(";"));
	return (multi_return_string_orm__QueryData){.arg0=str, .arg1=((orm__QueryData){.fields = data_fields,.data = data_data,.types = data.types,.parentheses = __new_array(0, 0, sizeof(Array_int)),.kinds = data.kinds,.auto_fields = __new_array_noscan(0, 0, sizeof(int)),.is_and = data.is_and,})};
}
string orm__orm_select_gen(orm__SelectConfig cfg, string q, bool num, string qm, int start_pos, orm__QueryData where) {
	string str = _SLIT("SELECT ");
	if (cfg.is_count) {
		str = string__plus(str, _SLIT("COUNT(*)"));
	} else {
		for (int i = 0; i < cfg.fields.len; ++i) {
			string field = ((string*)cfg.fields.data)[i];
			str = string__plus(str, str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = field}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0, { .d_c = 0 }}})));
			if (i < (int)(cfg.fields.len - 1)) {
				str = string__plus(str, _SLIT(", "));
			}
		}
	}
	str = string__plus(str, str_intp(4, _MOV((StrIntpData[]){{_SLIT(" FROM "), 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = cfg.table}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0, { .d_c = 0 }}})));
	int c = start_pos;
	if (cfg.has_where) {
		str = string__plus(str, _SLIT(" WHERE "));
		str = string__plus(str, orm__gen_where_clause(where, q, qm, num, &c));
	}
	if (cfg.has_order) {
		str = string__plus(str, _SLIT(" ORDER BY "));
		str = string__plus(str, str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = cfg.order}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		str = string__plus(str, orm__OrderType_to_str(cfg.order_type));
	}
	if (cfg.has_limit) {
		str = string__plus(str, str_intp(2, _MOV((StrIntpData[]){{_SLIT(" LIMIT "), 0xfe10, {.d_s = qm}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (num) {
			str = string__plus(str, str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = c}}, {_SLIT0, 0, { .d_c = 0 }}})));
			c++;
		}
	}
	if (cfg.has_offset) {
		str = string__plus(str, str_intp(2, _MOV((StrIntpData[]){{_SLIT(" OFFSET "), 0xfe10, {.d_s = qm}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (num) {
			str = string__plus(str, str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = c}}, {_SLIT0, 0, { .d_c = 0 }}})));
			c++;
		}
	}
	str = string__plus(str, _SLIT(";"));
	return str;
}
VV_LOCAL_SYMBOL string orm__gen_where_clause(orm__QueryData where, string q, string qm, bool num, int* c) {
	string str = _SLIT("");
	for (int i = 0; i < where.fields.len; ++i) {
		string field = ((string*)where.fields.data)[i];
		bool pre_par = false;
		bool post_par = false;
		for (int _t1 = 0; _t1 < where.parentheses.len; ++_t1) {
			Array_int par = ((Array_int*)where.parentheses.data)[_t1];
			if ((Array_int_contains(par, i))) {
				pre_par = (*(int*)array_get(par, 0)) == i;
				post_par = (*(int*)array_get(par, 1)) == i;
			}
		}
		if (pre_par) {
			str = string__plus(str, _SLIT("("));
		}
		str = string__plus(str, str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = field}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(" "), 0xfe10, {.d_s = orm__OperationKind_to_str((*(orm__OperationKind*)array_get(where.kinds, i)))}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (!orm__OperationKind_is_unary((*(orm__OperationKind*)array_get(where.kinds, i)))) {
			str = string__plus(str, str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = qm}}, {_SLIT0, 0, { .d_c = 0 }}})));
			if (num) {
				str = string__plus(str, str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = *c}}, {_SLIT0, 0, { .d_c = 0 }}})));
				(*c)++;
			}
		}
		if (post_par) {
			str = string__plus(str, _SLIT(")"));
		}
		if (i < (int)(where.fields.len - 1)) {
			if ((*(bool*)array_get(where.is_and, i))) {
				str = string__plus(str, _SLIT(" AND "));
			} else {
				str = string__plus(str, _SLIT(" OR "));
			}
		}
	}
	return str;
}
_result_string orm__orm_table_gen(string table, string q, bool defaults, int def_unique_len, Array_orm__TableField fields, _result_string (*sql_from_v)(int ), bool alternative) {
	string str = str_intp(4, _MOV((StrIntpData[]){{_SLIT("CREATE TABLE IF NOT EXISTS "), 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = table}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(" ("), 0, { .d_c = 0 }}}));
	if (alternative) {
		str = str_intp(9, _MOV((StrIntpData[]){{_SLIT("IF NOT EXISTS (SELECT * FROM sysobjects WHERE name="), 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = table}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(" and xtype="), 0xfe10, {.d_s = q}}, {_SLIT("U"), 0xfe10, {.d_s = q}}, {_SLIT(") CREATE TABLE "), 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = table}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(" ("), 0, { .d_c = 0 }}}));
	}
	Array_string fs = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string unique_fields = __new_array_with_default(0, 0, sizeof(string), 0);
	Map_string_Array_string unique = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	string primary = _SLIT("");
	int primary_typ = 0;
	for (int _t1 = 0; _t1 < fields.len; ++_t1) {
		orm__TableField field = ((orm__TableField*)fields.data)[_t1];
		if (field.is_arr) {
			continue;
		}
		string default_val = field.default_val;
		bool nullable = field.nullable;
		bool is_unique = false;
		bool is_skip = false;
		int unique_len = 0;
		string references_table = _SLIT("");
		string references_field = _SLIT("");
		string field_name = orm__sql_field_name(field);
		_result_string _t2 = sql_from_v(orm__sql_field_type(field));
		if (_t2.is_error) {
			IError err = _t2.err;
			field_name = str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = field_name}}, {_SLIT("_id"), 0, { .d_c = 0 }}}));
			_result_string _t3 = sql_from_v(primary_typ);
			if (_t3.is_error) {
				_result_string _t4;
				memcpy(&_t4, &_t3, sizeof(_result));
				return _t4;
			}
			
 			*(string*) _t2.data = (*(string*)_t3.data);
		}
		
 		string col_typ = (*(string*)_t2.data);
		for (int _t5 = 0; _t5 < field.attrs.len; ++_t5) {
			VAttribute attr = ((VAttribute*)field.attrs.data)[_t5];

			if (_SLIT_EQ(attr.name.str, attr.name.len, "sql")) {
				if (fast_string_eq(attr.arg, _SLIT("-"))) {
					is_skip = true;
				}
			}
			else if (_SLIT_EQ(attr.name.str, attr.name.len, "primary")) {
				primary = field_name;
				primary_typ = field.typ;
			}
			else if (_SLIT_EQ(attr.name.str, attr.name.len, "unique")) {
				if ((attr.arg).len != 0) {
					if (attr.kind == AttributeKind__string) {
						array_push((array*)&(*(Array_string*)map_get_and_set((map*)&unique, &(string[]){attr.arg}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) })), _MOV((string[]){ string_clone(field_name) }));
						continue;
					} else if (attr.kind == AttributeKind__number) {
						unique_len = string_int(attr.arg);
						is_unique = true;
						continue;
					}
				}
				is_unique = true;
			}
			else if (_SLIT_EQ(attr.name.str, attr.name.len, "skip")) {
				is_skip = true;
			}
			else if (_SLIT_EQ(attr.name.str, attr.name.len, "sql_type")) {
				col_typ = string_str(attr.arg);
			}
			else if (_SLIT_EQ(attr.name.str, attr.name.len, "default")) {
				if ((default_val).len == 0) {
					default_val = string_str(attr.arg);
				}
			}
			else if (_SLIT_EQ(attr.name.str, attr.name.len, "references")) {
				if ((attr.arg).len == 0) {
					if (string_ends_with(field.name, _SLIT("_id"))) {
						references_table = string_trim_right(field.name, _SLIT("_id"));
						references_field = _SLIT("id");
					} else {
						return (_result_string){ .is_error=true, .err=_v_error(_SLIT("references attribute can only be implicit if the field name ends with '_id'")), .data={EMPTY_STRUCT_INITIALIZATION} };
					}
				} else {
					if ((string_trim(attr.arg, _SLIT(" "))).len == 0) {
						return (_result_string){ .is_error=true, .err=_v_error(_SLIT("references attribute needs to be in the format [references], [references: 'tablename'], or [references: 'tablename(field_id)']")), .data={EMPTY_STRUCT_INITIALIZATION} };
					}
					if (string_contains(attr.arg, _SLIT("("))) {
						_option_multi_return_string_string _t9;
						if (_t9 = string_split_once(attr.arg, _SLIT("(")), _t9.state == 0) {
							string ref_table = (*(multi_return_string_string*)_t9.data).arg0;
							string ref_field = (*(multi_return_string_string*)_t9.data).arg1;
							if (!string_ends_with(ref_field, _SLIT(")"))) {
								return (_result_string){ .is_error=true, .err=_v_error(_SLIT("explicit references attribute should be written as [references: 'tablename(field_id)']")), .data={EMPTY_STRUCT_INITIALIZATION} };
							}
							references_table = ref_table;
							references_field = string_substr(ref_field, 0, (int)(ref_field.len - 1));
						}
					} else {
						references_table = attr.arg;
						references_field = _SLIT("id");
					}
				}
			}
			else {
			}
		}
		if (is_skip) {
			continue;
		}
		string stmt = _SLIT("");
		if ((col_typ).len == 0) {
			return (_result_string){ .is_error=true, .err=_v_error(str_intp(4, _MOV((StrIntpData[]){{_SLIT("Unknown type ("), 0xfe07, {.d_i32 = field.typ}}, {_SLIT(") for field "), 0xfe10, {.d_s = field.name}}, {_SLIT(" in struct "), 0xfe10, {.d_s = table}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		stmt = str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = field_name}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(" "), 0xfe10, {.d_s = col_typ}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if (defaults && (default_val).len != 0) {
			stmt = string__plus(stmt, str_intp(2, _MOV((StrIntpData[]){{_SLIT(" DEFAULT "), 0xfe10, {.d_s = default_val}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		if (!nullable) {
			stmt = string__plus(stmt, _SLIT(" NOT NULL"));
		}
		if (is_unique) {
			string f = str_intp(4, _MOV((StrIntpData[]){{_SLIT("UNIQUE("), 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = field_name}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0, { .d_c = 0 }}}));
			if (_SLIT_EQ(col_typ.str, col_typ.len, "TEXT") && def_unique_len > 0) {
				if (unique_len > 0) {
					f = string__plus(f, str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe07, {.d_i32 = unique_len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
				} else {
					f = string__plus(f, str_intp(2, _MOV((StrIntpData[]){{_SLIT("("), 0xfe07, {.d_i32 = def_unique_len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
				}
			}
			f = string__plus(f, _SLIT(")"));
			array_push((array*)&unique_fields, _MOV((string[]){ string_clone(f) }));
		}
		if ((references_table).len != 0) {
			stmt = string__plus(stmt, str_intp(7, _MOV((StrIntpData[]){{_SLIT(" REFERENCES "), 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = references_table}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT("("), 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = references_field}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		}
		array_push((array*)&fs, _MOV((string[]){ string_clone(stmt) }));
	}
	if (unique.len > 0) {
		int _t15 = unique.key_values.len;
		for (int _t14 = 0; _t14 < _t15; ++_t14 ) {
			int _t16 = unique.key_values.len - _t15;
			_t15 = unique.key_values.len;
			if (_t16 < 0) {
				_t14 = -1;
				continue;
			}
			if (!DenseArray_has_index(&unique.key_values, _t14)) {continue;}
			string k = *(string*)DenseArray_key(&unique.key_values, _t14);
			k = string_clone(k);
			Array_string v = (*(Array_string*)DenseArray_value(&unique.key_values, _t14));
			Array_string tmp = __new_array_with_default(0, 0, sizeof(string), 0);
			for (int _t17 = 0; _t17 < v.len; ++_t17) {
				string f = ((string*)v.data)[_t17];
				array_push((array*)&tmp, _MOV((string[]){ str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = f}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
			}
			array_push((array*)&fs, _MOV((string[]){ str_intp(3, _MOV((StrIntpData[]){{_SLIT("/* "), 0xfe10, {.d_s = k}}, {_SLIT(" */UNIQUE("), 0xfe10, {.d_s = Array_string_join(tmp, _SLIT(", "))}}, {_SLIT(")"), 0, { .d_c = 0 }}})) }));
		}
	}
	if ((primary).len != 0) {
		array_push((array*)&fs, _MOV((string[]){ str_intp(4, _MOV((StrIntpData[]){{_SLIT("PRIMARY KEY("), 0xfe10, {.d_s = q}}, {_SLIT0, 0xfe10, {.d_s = primary}}, {_SLIT0, 0xfe10, {.d_s = q}}, {_SLIT(")"), 0, { .d_c = 0 }}})) }));
	}
	_PUSH_MANY(&fs, (unique_fields), _t21, Array_string);
	str = string__plus(str, Array_string_join(fs, _SLIT(", ")));
	str = string__plus(str, _SLIT(");"));
	_result_string _t22 = {0};
	_result_ok(&(string[]) { str }, (_result*)(&_t22), sizeof(string));
	return _t22;
}
VV_LOCAL_SYMBOL int orm__sql_field_type(orm__TableField field) {
	int typ = field.typ;
	for (int _t1 = 0; _t1 < field.attrs.len; ++_t1) {
		VAttribute attr = ((VAttribute*)field.attrs.data)[_t1];
		if (fast_string_eq(attr.name, _SLIT("serial")) && attr.kind == AttributeKind__plain && !attr.has_arg) {
			typ = _const_orm__serial;
			break;
		}
		if (attr.kind == AttributeKind__plain && fast_string_eq(attr.name, _SLIT("sql")) && (attr.arg).len != 0) {
			if (string__eq(string_to_lower(attr.arg), _SLIT("serial"))) {
				typ = _const_orm__serial;
				break;
			}
			typ = (*(int*)map_get(ADDR(map, _const_orm__type_idx), &(string[]){attr.arg}, &(int[]){ 0 }));
			break;
		}
	}
	return typ;
}
VV_LOCAL_SYMBOL string orm__sql_field_name(orm__TableField field) {
	string name = field.name;
	for (int _t1 = 0; _t1 < field.attrs.len; ++_t1) {
		VAttribute attr = ((VAttribute*)field.attrs.data)[_t1];
		if (fast_string_eq(attr.name, _SLIT("sql")) && attr.has_arg && attr.kind == AttributeKind__string) {
			name = attr.arg;
			break;
		}
	}
	return name;
}
VV_LOCAL_SYMBOL orm__Primitive orm__bool_to_primitive(bool b) {
	return bool_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_bool_to_primitive(_option_bool b) {
	orm__Primitive _t2; /* if prepend */
	_option_bool _t3;
	if (_t3 = b, _t3.state == 0) {
		bool b_ = *(bool*)_t3.data;
		_t2 = bool_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__f32_to_primitive(f32 b) {
	return f32_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_f32_to_primitive(_option_f32 b) {
	orm__Primitive _t2; /* if prepend */
	_option_f32 _t3;
	if (_t3 = b, _t3.state == 0) {
		f32 b_ = *(f32*)_t3.data;
		_t2 = f32_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__f64_to_primitive(f64 b) {
	return f64_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_f64_to_primitive(_option_f64 b) {
	orm__Primitive _t2; /* if prepend */
	_option_f64 _t3;
	if (_t3 = b, _t3.state == 0) {
		f64 b_ = *(f64*)_t3.data;
		_t2 = f64_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__i8_to_primitive(i8 b) {
	return i8_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_i8_to_primitive(_option_i8 b) {
	orm__Primitive _t2; /* if prepend */
	_option_i8 _t3;
	if (_t3 = b, _t3.state == 0) {
		i8 b_ = *(i8*)_t3.data;
		_t2 = i8_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__i16_to_primitive(i16 b) {
	return i16_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_i16_to_primitive(_option_i16 b) {
	orm__Primitive _t2; /* if prepend */
	_option_i16 _t3;
	if (_t3 = b, _t3.state == 0) {
		i16 b_ = *(i16*)_t3.data;
		_t2 = i16_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__int_to_primitive(int b) {
	return int_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_int_to_primitive(_option_int b) {
	orm__Primitive _t2; /* if prepend */
	_option_int _t3;
	if (_t3 = b, _t3.state == 0) {
		int b_ = *(int*)_t3.data;
		_t2 = int_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__int_literal_to_primitive(int b) {
	return int_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_int_literal_to_primitive(_option_int b) {
	orm__Primitive _t2; /* if prepend */
	_option_int _t3;
	if (_t3 = b, _t3.state == 0) {
		int b_ = *(int*)_t3.data;
		_t2 = int_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__float_literal_to_primitive(f64 b) {
	return f64_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_float_literal_to_primitive(_option_f64 b) {
	orm__Primitive _t2; /* if prepend */
	_option_f64 _t3;
	if (_t3 = b, _t3.state == 0) {
		f64 b_ = *(f64*)_t3.data;
		_t2 = f64_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__i64_to_primitive(i64 b) {
	return i64_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_i64_to_primitive(_option_i64 b) {
	orm__Primitive _t2; /* if prepend */
	_option_i64 _t3;
	if (_t3 = b, _t3.state == 0) {
		i64 b_ = *(i64*)_t3.data;
		_t2 = i64_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__u8_to_primitive(u8 b) {
	return u8_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_u8_to_primitive(_option_u8 b) {
	orm__Primitive _t2; /* if prepend */
	_option_u8 _t3;
	if (_t3 = b, _t3.state == 0) {
		u8 b_ = *(u8*)_t3.data;
		_t2 = u8_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__u16_to_primitive(u16 b) {
	return u16_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_u16_to_primitive(_option_u16 b) {
	orm__Primitive _t2; /* if prepend */
	_option_u16 _t3;
	if (_t3 = b, _t3.state == 0) {
		u16 b_ = *(u16*)_t3.data;
		_t2 = u16_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__u32_to_primitive(u32 b) {
	return u32_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_u32_to_primitive(_option_u32 b) {
	orm__Primitive _t2; /* if prepend */
	_option_u32 _t3;
	if (_t3 = b, _t3.state == 0) {
		u32 b_ = *(u32*)_t3.data;
		_t2 = u32_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__u64_to_primitive(u64 b) {
	return u64_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_u64_to_primitive(_option_u64 b) {
	orm__Primitive _t2; /* if prepend */
	_option_u64 _t3;
	if (_t3 = b, _t3.state == 0) {
		u64 b_ = *(u64*)_t3.data;
		_t2 = u64_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__string_to_primitive(string b) {
	return string_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_string_to_primitive(_option_string b) {
	orm__Primitive _t2; /* if prepend */
	_option_string _t3;
	if (_t3 = b, _t3.state == 0) {
		string b_ = *(string*)_t3.data;
		_t2 = string_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__time_to_primitive(time__Time b) {
	return time__Time_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL orm__Primitive orm__option_time_to_primitive(_option_time__Time b) {
	orm__Primitive _t2; /* if prepend */
	_option_time__Time _t3;
	if (_t3 = b, _t3.state == 0) {
		time__Time b_ = *(time__Time*)_t3.data;
		_t2 = time__Time_to_sumtype_orm__Primitive(&b_);
	} else {
		IError err = _t3.err;
		_t2 = _const_orm__null_primitive;
	}
	return _t2;
}
VV_LOCAL_SYMBOL orm__Primitive orm__infix_to_primitive(orm__InfixType b) {
	return orm__InfixType_to_sumtype_orm__Primitive(&b);
}
VV_LOCAL_SYMBOL string orm__factory_insert_qm_value(bool num, string qm, int c) {
	if (num) {
		return str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = qm}}, {_SLIT0, 0xfe07, {.d_i32 = c}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else {
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = qm}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string os__getenv(string key) {
	_option_string _t2 = os__getenv_opt(key);
	if (_t2.state != 0) {
		IError err = _t2.err;
		*(string*) _t2.data = _SLIT("");
	}
	
 	return (*(string*)_t2.data);
}
_option_string os__getenv_opt(string key) {
	{ // Unsafe block
		#if defined(_WIN32)
		{
		}
		#else
		{
			char* s = getenv(((char*)(key.str)));
			if (s == ((void*)0)) {
				return (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			_option_string _t3;
			_option_ok(&(string[]) { cstring_to_vstring(s) }, (_option*)(&_t3), sizeof(string));
			return _t3;
		}
		#endif
	}
	return (_option_string){.state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION}};
}
#if !defined(_WIN32)
#endif
int os__fd_close(int fd) {
	if (fd == -1) {
		return 0;
	}
	return close(fd);
}
VV_LOCAL_SYMBOL string os__NotExpected_msg(os__NotExpected err) {
	return err.cause;
}
VV_LOCAL_SYMBOL int os__NotExpected_code(os__NotExpected err) {
	return err.code;
}
_result_os__File os__open(string path) {
	_result_FILE_ptr _t1 = os__vfopen(path, _SLIT("rb"));
	if (_t1.is_error) {
		_result_os__File _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	FILE* cfile = (*(FILE**)_t1.data);
	int fd = os__fileno(cfile);
	_result_os__File _t3 = {0};
	_result_ok(&(os__File[]) { ((os__File){.cfile = cfile,.fd = fd,.is_opened = true,}) }, (_result*)(&_t3), sizeof(os__File));
	return _t3;
}
_result_os__File os__create(string path) {
	_result_FILE_ptr _t1 = os__vfopen(path, _SLIT("wb"));
	if (_t1.is_error) {
		_result_os__File _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	FILE* cfile = (*(FILE**)_t1.data);
	int fd = os__fileno(cfile);
	_result_os__File _t3 = {0};
	_result_ok(&(os__File[]) { ((os__File){.cfile = cfile,.fd = fd,.is_opened = true,}) }, (_result*)(&_t3), sizeof(os__File));
	return _t3;
}
_result_int os__File_read(os__File* f, Array_u8* buf) {
	if (buf->len == 0) {
		return (_result_int){ .is_error=true, .err=I_os__Eof_to_Interface_IError(((os__Eof*)memdup(&(os__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int nbytes = ((int)(fread(buf->data, 1, buf->len, ((FILE*)(f->cfile)))));
	if (nbytes <= 0) {
		if (feof(((FILE*)(f->cfile))) != 0) {
			return (_result_int){ .is_error=true, .err=I_os__Eof_to_Interface_IError(((os__Eof*)memdup(&(os__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (ferror(((FILE*)(f->cfile))) != 0) {
			return (_result_int){ .is_error=true, .err=I_os__NotExpected_to_Interface_IError(((os__NotExpected*)memdup(&(os__NotExpected){.cause = _SLIT("unexpected error from fread"),.code = -1,}, sizeof(os__NotExpected)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	_result_int _t4 = {0};
	_result_ok(&(int[]) { nbytes }, (_result*)(&_t4), sizeof(int));
	return _t4;
}
_result_int os__File_write(os__File* f, Array_u8 buf) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int written = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
	if (written == 0 && buf.len != 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_int _t3 = {0};
	_result_ok(&(int[]) { written }, (_result*)(&_t3), sizeof(int));
	return _t3;
}
_result_void os__File_write_full_buffer(os__File* f, voidptr buffer, usize buffer_len) {
	if (buffer_len <= ((usize)(0))) {
		return (_result_void){0};
	}
	if (!f->is_opened) {
		return (_result_void){ .is_error=true, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	u8* ptr = ((u8*)(buffer));
	i64 remaining_bytes = ((i64)(buffer_len));
	for (;;) {
		if (!(remaining_bytes > 0)) break;
		{ // Unsafe block
			i64 x = ((i64)(fwrite(ptr, 1, remaining_bytes, f->cfile)));
			ptr += x;
			remaining_bytes -= x;
			if (x <= 0) {
				return (_result_void){ .is_error=true, .err=_v_error(_SLIT("C.fwrite returned 0")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	return (_result_void){0};
}
VV_LOCAL_SYMBOL _result_int os__fread(voidptr ptr, int item_size, int items, FILE* stream) {
	int nbytes = ((int)(fread(ptr, item_size, items, stream)));
	if (nbytes <= 0) {
		if (feof(stream) != 0) {
			return (_result_int){ .is_error=true, .err=I_os__Eof_to_Interface_IError(((os__Eof*)memdup(&(os__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (ferror(stream) != 0) {
			return (_result_int){ .is_error=true, .err=_v_error(_SLIT("file read error")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	_result_int _t3 = {0};
	_result_ok(&(int[]) { nbytes }, (_result*)(&_t3), sizeof(int));
	return _t3;
}
_result_int os__File_read_from(os__File* f, u64 pos, Array_u8* buf) {
	if (buf->len == 0) {
		_result_int _t1 = {0};
		_result_ok(&(int[]) { 0 }, (_result*)(&_t1), sizeof(int));
		return _t1;
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			fseeko(f->cfile, pos, SEEK_SET);
		}
		#endif
		_result_int _t4 = os__fread(buf->data, 1, buf->len, f->cfile);
		if (_t4.is_error) {
			_result_int _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 		int nbytes = (*(int*)_t4.data);
		_result_int _t6 = {0};
		_result_ok(&(int[]) { nbytes }, (_result*)(&_t6), sizeof(int));
		return _t6;
	}
	#endif
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("Could not read file")), .data={EMPTY_STRUCT_INITIALIZATION} };
}
string os__FileNotOpenedError_msg(os__FileNotOpenedError err) {
	return _SLIT("os: file not opened");
}
string os__SizeOfTypeIs0Error_msg(os__SizeOfTypeIs0Error err) {
	return _SLIT("os: size of type is 0");
}
VV_LOCAL_SYMBOL IError os__error_file_not_opened(void) {
	return I_os__FileNotOpenedError_to_Interface_IError(((os__FileNotOpenedError*)memdup(&(os__FileNotOpenedError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__FileNotOpenedError))));
}
_result_void os__File_seek(os__File* f, i64 pos, os__SeekMode mode) {
	if (!f->is_opened) {
		return (_result_void){ .is_error=true, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int whence = ((int)(mode));
	int res = 0;
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			res = fseeko(f->cfile, pos, whence);
		}
		#endif
	}
	#endif
	if (res == -1) {
		return (_result_void){ .is_error=true, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}
_result_i64 os__File_tell(os__File* f) {
	if (!f->is_opened) {
		return (_result_i64){ .is_error=true, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	isize pos = ((isize)(0));
	#if defined(_WIN32)
	{
	}
	#else
	{
		pos = ftell(f->cfile);
	}
	#endif
	if (pos == -1) {
		return (_result_i64){ .is_error=true, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_i64 _t4 = {0};
	_result_ok(&(i64[]) { pos }, (_result*)(&_t4), sizeof(i64));
	return _t4;
}
VV_LOCAL_SYMBOL _result_int os__find_cfile_size(FILE* fp) {
	int cseek = fseek(fp, 0, SEEK_END);
	isize raw_fsize = ftell(fp);
	if (raw_fsize != 0 && cseek != 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("fseek failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (cseek != 0 && raw_fsize < 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("ftell failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int len = ((int)(raw_fsize));
	if (((i64)(len)) < raw_fsize) {
		return (_result_int){ .is_error=true, .err=_v_error(str_intp(3, _MOV((StrIntpData[]){{_SLIT("int("), 0xfe09, {.d_i64 = raw_fsize}}, {_SLIT(") cast results in "), 0xfe07, {.d_i32 = len}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	rewind(fp);
	_result_int _t4 = {0};
	_result_ok(&(int[]) { len }, (_result*)(&_t4), sizeof(int));
	return _t4;
}
VV_LOCAL_SYMBOL _result_strings__Builder os__slurp_file_in_builder(FILE* fp) {
	Array_fixed_u8_4096 buf = {0};
	strings__Builder sb = strings__new_builder(_const_os__buf_size);
	for (;;) {
		_result_int _t1 = os__fread(&buf[0], 1, _const_os__buf_size, fp);
		if (_t1.is_error) {
			IError err = _t1.err;
			if ((err)._typ == _IError_os__Eof_index) {
				break;
			}
			strings__Builder_free(&sb);
			return (_result_strings__Builder){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		int read_bytes = (*(int*)_t1.data);
		strings__Builder_write_ptr(&sb, &buf[0], read_bytes);
	}
	_result_strings__Builder _t3 = {0};
	_result_ok(&(strings__Builder[]) { sb }, (_result*)(&_t3), sizeof(strings__Builder));
	return _t3;
}
_result_string os__read_file(string path) {
	bool os__read_file_defer_0 = false;
	FILE* fp;
	string mode = _SLIT("rb");
	_result_FILE_ptr _t1 = os__vfopen(path, mode);
	if (_t1.is_error) {
		_result_string _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	fp = (*(FILE**)_t1.data);
	os__read_file_defer_0 = true;
	_result_int _t3 = os__find_cfile_size(fp);
	if (_t3.is_error) {
	// Defer begin
	if (os__read_file_defer_0) {
		fclose(fp);
	}
	// Defer end
		_result_string _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	int allocate = (*(int*)_t3.data);
	if (allocate == 0) {
		_result_strings__Builder _t5 = os__slurp_file_in_builder(fp);
		if (_t5.is_error) {
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
			_result_string _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 		strings__Builder sb = (*(strings__Builder*)_t5.data);
		string res = strings__Builder_str(&sb);
		strings__Builder_free(&sb);
		_result_string _t7 = {0};
		_result_ok(&(string[]) { res }, (_result*)(&_t7), sizeof(string));
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t7;
	}
	{ // Unsafe block
		u8* str = malloc_noscan((int)(allocate + 1));
		int nelements = ((int)(fread(str, 1, allocate, fp)));
		int is_eof = ((int)(feof(fp)));
		int is_error = ((int)(ferror(fp)));
		if (is_eof == 0 && is_error != 0) {
			_v_free(str);
			_result_string _t8 = (_result_string){ .is_error=true, .err=_v_error(_SLIT("fread failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (os__read_file_defer_0) {
				fclose(fp);
			}
			// Defer end
			return _t8;
		}
		str[nelements] = 0;
		if (nelements == 0) {
			_result_string _t9 = {0};
			_result_ok(&(string[]) { u8_vstring(str) }, (_result*)(&_t9), sizeof(string));
			// Defer begin
			if (os__read_file_defer_0) {
				fclose(fp);
			}
			// Defer end
			return _t9;
		}
		_result_string _t10 = {0};
		_result_ok(&(string[]) { u8_vstring_with_len(str, nelements) }, (_result*)(&_t10), sizeof(string));
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t10;
	}
	return (_result_string){0};
}
_result_FILE_ptr os__vfopen(string path, string mode) {
	if ((path).len == 0) {
		return (_result_FILE_ptr){ .is_error=true, .err=_v_error(_SLIT("vfopen called with \"\"")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	voidptr fp = ((void*)0);
	#if defined(_WIN32)
	{
	}
	#else
	{
		fp = fopen(((char*)(path.str)), ((char*)(mode.str)));
	}
	#endif
	if (isnil(((voidptr)(fp)))) {
		return (_result_FILE_ptr){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to open file \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}})),.code = _const_os__error_code_not_set,})), .data={EMPTY_STRUCT_INITIALIZATION} };
	} else {
		_result_FILE_ptr _t4 = {0};
		_result_ok(&(FILE*[]) { fp }, (_result*)(&_t4), sizeof(FILE*));
		return _t4;
	}
	return (_result_FILE_ptr){0};
}
int os__fileno(voidptr cfile) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		FILE* cfile_casted = ((FILE*)(((void*)0)));
		cfile_casted = cfile;
		return fileno(cfile_casted);
	}
	#endif
	return 0;
}
VV_LOCAL_SYMBOL multi_return_int_bool os__posix_wait4_to_exit_status(int waitret) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		int ret = 0;
		bool is_signaled = true;
		if (WIFEXITED(waitret)) {
			ret = WEXITSTATUS(waitret);
			is_signaled = false;
		} else if (WIFSIGNALED(waitret)) {
			ret = WTERMSIG(waitret);
			is_signaled = true;
		}
		return (multi_return_int_bool){.arg0=ret, .arg1=is_signaled};
	}
	#endif
	return (multi_return_int_bool){0};
}
string os__posix_get_error_msg(int code) {
	char* ptr_text = strerror(code);
	if (ptr_text == 0) {
		return _SLIT("");
	}
	return tos3(ptr_text);
}
int os__system(string cmd) {
	int ret = 0;
	#if defined(_WIN32)
	{
	}
	#else
	{
		#if defined(__TARGET_IOS__)
		{
		}
		#else
		{
			{ // Unsafe block
				ret = system(((char*)(cmd.str)));
			}
		}
		#endif
	}
	#endif
	if (ret == -1) {
		os__print_c_errno();
	}
	#if !defined(_WIN32)
	{
		multi_return_int_bool mr_10501 = os__posix_wait4_to_exit_status(ret);
		int pret = mr_10501.arg0;
		bool is_signaled = mr_10501.arg1;
		ret = pret;
		if (is_signaled) {
			eprintln(string__plus(string__plus(str_intp(2, _MOV((StrIntpData[]){{_SLIT("Terminated by signal "), 0x4fe27, {.d_i32 = pret}}, {_SLIT(" ("), 0, { .d_c = 0 }}})), os__sigint_to_signal_name(pret)), _SLIT(")")));
			ret = (int)(pret + 128);
		}
	}
	#endif
	return ret;
}
bool os__exists(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return access(((char*)(path.str)), _const_os__f_ok) != -1;
	}
	#endif
	return 0;
}
_result_void os__rm(string path) {
	int rc = 0;
	#if defined(_WIN32)
	{
	}
	#else
	{
		rc = remove(((char*)(path.str)));
	}
	#endif
	if (rc == -1) {
		return (_result_void){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = string__plus(str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to remove \""), 0xfe10, {.d_s = path}}, {_SLIT("\": "), 0, { .d_c = 0 }}})), os__posix_get_error_msg(errno)),.code = _const_os__error_code_not_set,})), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}
VV_LOCAL_SYMBOL void os__print_c_errno(void) {
	int e = errno;
	string se = tos_clone(((u8*)(strerror(e))));
	eprintln(str_intp(3, _MOV((StrIntpData[]){{_SLIT("errno="), 0xfe07, {.d_i32 = e}}, {_SLIT(" err="), 0xfe10, {.d_s = se}}, {_SLIT0, 0, { .d_c = 0 }}})));
}
string os__get_raw_line(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		usize max = ((usize)(0));
		u8* buf = ((u8*)(0));
		int nr_chars = getline(((voidptr)(&buf)), &max, stdin);
		string str = tos(buf, (nr_chars < 0 ? (0) : (nr_chars)));
		string ret = string_clone(str);
		#if !defined(_VAUTOFREE)
		{
			{ // Unsafe block
				if (nr_chars > 0 && buf != 0) {
					free(buf);
				}
			}
		}
		#endif
		return ret;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}
string os__getwd(void) {
	{ // Unsafe block
		Array_fixed_u8_4096 buf = {0};
		#if defined(_WIN32)
		{
		}
		#else
		{
			if (getcwd(((char*)(&buf[0])), _const_os__max_path_len) == 0) {
				return _SLIT("");
			}
			string res = tos_clone(&buf[0]);
			return res;
		}
		#endif
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
void os__flush(void) {
	fflush(stdout);
}
int os__is_atty(int fd) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return isatty(fd);
	}
	#endif
	return 0;
}
IError os__last_error(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		int code = errno;
		string msg = os__posix_get_error_msg(code);
		return error_with_code(msg, code);
	}
	#endif
	return (IError){0};
}
inline IError os__error_posix(os__SystemError e) {
	int code = (e.code == _const_os__error_code_not_set ? (errno) : (e.code));
	string message = ((e.msg).len == 0 ? (os__posix_get_error_msg(code)) : (e.msg));
	return error_with_code(message, code);
}
void os__Result_free(os__Result* result) {
	string_free(&result->output);
}
string os__sigint_to_signal_name(int si) {
	switch (si) {
		case 1: {
				return _SLIT("SIGHUP");
		}
		case 2: {
				return _SLIT("SIGINT");
		}
		case 3: {
				return _SLIT("SIGQUIT");
		}
		case 4: {
				return _SLIT("SIGILL");
		}
		case 6: {
				return _SLIT("SIGABRT");
		}
		case 8: {
				return _SLIT("SIGFPE");
		}
		case 9: {
				return _SLIT("SIGKILL");
		}
		case 11: {
				return _SLIT("SIGSEGV");
		}
		case 13: {
				return _SLIT("SIGPIPE");
		}
		case 14: {
				return _SLIT("SIGALRM");
		}
		case 15: {
				return _SLIT("SIGTERM");
		}
		default: {
				break;
		}
	}
	
	switch (si) {
		case 10: {
				return _SLIT("SIGUSR1");
		}
		case 12: {
				return _SLIT("SIGUSR2");
		}
		case 17: {
				return _SLIT("SIGCHLD");
		}
		case 18: {
				return _SLIT("SIGCONT");
		}
		case 19: {
				return _SLIT("SIGSTOP");
		}
		case 20: {
				return _SLIT("SIGTSTP");
		}
		case 21: {
				return _SLIT("SIGTTIN");
		}
		case 22: {
				return _SLIT("SIGTTOU");
		}
		case 5: {
				return _SLIT("SIGTRAP");
		}
		case 7: {
				return _SLIT("SIGBUS");
		}
		default: {
				break;
		}
	}
	
	return _SLIT("unknown");
}
string os__file_ext(string opath) {
	if (opath.len < 3) {
		return _SLIT("");
	}
	string path = os__file_name(opath);
	int pos = string_last_index_u8(path, '.');
	if (pos == -1) {
		return _SLIT("");
	}
	if ((int)(pos + 1) >= path.len || pos == 0) {
		return _SLIT("");
	}
	return string_substr(path, pos, 2147483647);
}
string os__base(string path) {
	if ((path).len == 0) {
		return _SLIT(".");
	}
	string detected_path_separator = (string_contains(path, _SLIT("/")) ? (_SLIT("/")) : (_SLIT("\\")));
	if (string__eq(path, detected_path_separator)) {
		return detected_path_separator;
	}
	if (string_ends_with(path, detected_path_separator)) {
		string path2 = string_substr(path, 0, (int)(path.len - 1));
		_option_int _t3 = string_last_index(path2, detected_path_separator);
		if (_t3.state != 0) {
			IError err = _t3.err;
			return string_clone(path2);
		}
		
 		int pos = (*(int*)_t3.data);
		return string_substr(path2, (int)(pos + 1), 2147483647);
	}
	_option_int _t6 = string_last_index(path, detected_path_separator);
	if (_t6.state != 0) {
		IError err = _t6.err;
		return string_clone(path);
	}
	
 	int pos = (*(int*)_t6.data);
	return string_substr(path, (int)(pos + 1), 2147483647);
}
string os__file_name(string path) {
	string detected_path_separator = (string_contains(path, _SLIT("/")) ? (_SLIT("/")) : (_SLIT("\\")));
	return string_all_after_last(path, detected_path_separator);
}
_option_string os__input_opt(string prompt) {
	print(prompt);
	os__flush();
	string res = os__get_raw_line();
	if (res.len > 0) {
		_option_string _t1;
		_option_ok(&(string[]) { string_trim_right(res, _SLIT("\r\n")) }, (_option*)(&_t1), sizeof(string));
		return _t1;
	}
	return (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}
string os__input(string prompt) {
	_option_string _t1 = os__input_opt(prompt);
	if (_t1.state != 0) {
		IError err = _t1.err;
		return _SLIT("<EOF>");
	}
	
 	string res = (*(string*)_t1.data);
	return res;
}
_result_void os__write_file(string path, string text) {
	_result_os__File _t1 = os__create(path);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	os__File f = (*(os__File*)_t1.data);
		_result_void _t3 = os__File_write_full_buffer(&f, text.str, ((usize)(text.len)));
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	os__File_close(&f);
	return (_result_void){0};
}
string os__ExecutableNotFoundError_msg(os__ExecutableNotFoundError err) {
	return _SLIT("os: failed to find executable");
}
string os__join_path(string base, Array_string dirs) {
	bool os__join_path_defer_0 = false;
	strings__Builder sb;
	bool os__join_path_defer_1 = false;
	string sbase;
	sb = strings__new_builder((int)(base.len + (int)(dirs.len * 50)));
	os__join_path_defer_0 = true;
	sbase = string_trim_right(base, _SLIT("\\/"));
	os__join_path_defer_1 = true;
	strings__Builder_write_string(&sb, sbase);
	for (int _t1 = 0; _t1 < dirs.len; ++_t1) {
		string d = ((string*)dirs.data)[_t1];
		if ((d).len != 0) {
			strings__Builder_write_string(&sb, _const_os__path_separator);
			strings__Builder_write_string(&sb, d);
		}
	}
	os__normalize_path_in_builder((voidptr)&sb);
	string res = strings__Builder_str(&sb);
	if ((base).len == 0) {
		res = string_trim_left(res, _const_os__path_separator);
	}
	string _t2 = res;
	// Defer begin
	if (os__join_path_defer_1) {
		string_free(&sbase);
	}
	// Defer end
	// Defer begin
	if (os__join_path_defer_0) {
		strings__Builder_free(&sb);
	}
	// Defer end
	return _t2;
}
VV_LOCAL_SYMBOL void os__normalize_path_in_builder(strings__Builder* sb) {
	rune fs = '\\';
	rune rs = '/';
	for (int idx = 0; idx < sb->len; ++idx) {
		{ // Unsafe block
			if (((u8*)sb->data)[idx] == fs) {
				((u8*)sb->data)[idx] = rs;
			}
		}
	}
	for (int idx = 0; idx < (int)(sb->len - 3); ++idx) {
		if (((u8*)sb->data)[idx] == rs && ((u8*)sb->data)[(int_literal)(idx + 1)] == '.' && ((u8*)sb->data)[(int_literal)(idx + 2)] == rs) {
			{ // Unsafe block
				for (int j = (int_literal)(idx + 1); j < (int)(sb->len - 2); j++) {
					((u8*)sb->data)[j] = ((u8*)sb->data)[(int)(j + 2)];
				}
				sb->len -= 2;
			}
		}
		if (((u8*)sb->data)[idx] == rs && ((u8*)sb->data)[(int_literal)(idx + 1)] == rs) {
			{ // Unsafe block
				for (int j = (int_literal)(idx + 1); j < (int)(sb->len - 1); j++) {
					((u8*)sb->data)[j] = ((u8*)sb->data)[(int)(j + 1)];
				}
				sb->len -= 1;
			}
		}
	}
}
_result_Array_string os__ls(string path) {
	if ((path).len == 0) {
		return (_result_Array_string){ .is_error=true, .err=_v_error(_SLIT("ls() expects a folder, not an empty string")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_string res = __new_array_with_default(0, 50, sizeof(string), 0);
	DIR* dir = opendir(((char*)(path.str)));
	if (isnil(dir)) {
		return (_result_Array_string){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("ls() couldnt open dir \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	struct dirent* ent = ((struct dirent*)(((void*)0)));
	for (;;) {
		ent = readdir(dir);
		if (isnil(ent)) {
			break;
		}
		{ // Unsafe block
			u8* bptr = ((u8*)(&ent->d_name[0]));
			if (bptr[0] == 0 || (bptr[0] == '.' && bptr[1] == 0) || (bptr[0] == '.' && bptr[1] == '.' && bptr[2] == 0)) {
				continue;
			}
			array_push((array*)&res, _MOV((string[]){ tos_clone(bptr) }));
		}
	}
	closedir(dir);
	_result_Array_string _t4 = {0};
	_result_ok(&(Array_string[]) { res }, (_result*)(&_t4), sizeof(Array_string));
	return _t4;
}
void os__File_close(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	f->is_opened = false;
	fflush(f->cfile);
	fclose(f->cfile);
}
_result_string os__input_password(string prompt) {
	if (os__is_atty(1) <= 0 || string__eq(os__getenv(_SLIT("TERM")), _SLIT("dumb"))) {
		return (_result_string){ .is_error=true, .err=_v_error(_SLIT("Could not obtain password discretely.")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	term__termios__Termios old_state = ((term__termios__Termios){.c_iflag = 0,.c_oflag = 0,.c_cflag = 0,.c_lflag = 0,.c_line = 0,.c_cc = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_ispeed = 0,.c_ospeed = 0,});
	if (term__termios__tcgetattr(0, (voidptr)&old_state) != 0) {
		return (_result_string){ .is_error=true, .err=os__last_error(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	term__termios__Termios new_state = old_state;
	term__termios__Termios_disable_echo(&new_state);
	term__termios__set_state(0, new_state);
	_option_string _t3 = os__input_opt(prompt);
	if (_t3.state != 0) {
		IError err = _t3.err;
		return (_result_string){ .is_error=true, .err=_v_error(_SLIT("Failed to read password")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	string password = (*(string*)_t3.data);
	term__termios__set_state(0, old_state);
	println(_SLIT(""));
	_result_string _t5 = {0};
	_result_ok(&(string[]) { password }, (_result*)(&_t5), sizeof(string));
	return _t5;
}
void os__Process_close(os__Process* p) {
	if (p->status == os__ProcessState__not_started || p->status == os__ProcessState__closed) {
		return;
	}
	p->status = os__ProcessState__closed;
	#if !defined(_WIN32)
	{
		for (int i = 0; i < 3; ++i) {
			if (p->stdio_fd[v_fixed_index(i, 3)] != 0) {
				os__fd_close(p->stdio_fd[v_fixed_index(i, 3)]);
			}
		}
	}
	#endif
}
void os__Process_free(os__Process* p) {
	os__Process_close(p);
	{ // Unsafe block
		string_free(&p->filename);
		string_free(&p->err);
		Array_string_free(&p->args);
		Array_string_free(&p->env);
	}
}
_result_os__Stat os__stat(string path) {
	struct stat s;
	{ // Unsafe block
		int res = stat(((char*)(path.str)), &s);
		if (res != 0) {
			return (_result_os__Stat){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = _const_os__error_code_not_set,})), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_result_os__Stat _t2 = {0};
		_result_ok(&(os__Stat[]) { ((os__Stat){
			.dev = s.st_dev,
			.inode = s.st_ino,
			.mode = s.st_mode,
			.nlink = s.st_nlink,
			.uid = s.st_uid,
			.gid = s.st_gid,
			.rdev = s.st_rdev,
			.size = s.st_size,
			.atime = s.st_atime,
			.mtime = s.st_mtime,
			.ctime = s.st_ctime,
		}) }, (_result*)(&_t2), sizeof(os__Stat));
		return _t2;
	}
	return (_result_os__Stat){0};
}
os__FileType os__Stat_get_filetype(os__Stat st) {
	u32 _t1 = (st.mode & ((u32)(S_IFMT)));
	
	if (_t1 == (((u32)(S_IFREG)))) {
		return os__FileType__regular;
	}
	else if (_t1 == (((u32)(S_IFDIR)))) {
		return os__FileType__directory;
	}
	else if (_t1 == (((u32)(S_IFCHR)))) {
		return os__FileType__character_device;
	}
	else if (_t1 == (((u32)(S_IFBLK)))) {
		return os__FileType__block_device;
	}
	else if (_t1 == (((u32)(S_IFIFO)))) {
		return os__FileType__fifo;
	}
	else if (_t1 == (((u32)(S_IFLNK)))) {
		return os__FileType__symbolic_link;
	}
	else if (_t1 == (((u32)(S_IFSOCK)))) {
		return os__FileType__socket;
	}
	else {
		return os__FileType__unknown;
	}
	return 0;
}
bool os__is_dir(string path) {
	_result_os__Stat _t1 = os__stat(path);
	if (_t1.is_error) {
		IError err = _t1.err;
		return false;
	}
	
 	os__Stat attr = (*(os__Stat*)_t1.data);
	return os__Stat_get_filetype(attr) == os__FileType__directory;
}
string encoding__html__escape(string input, encoding__html__EscapeConfig config) {
	return (config.quote ? (string_replace_each(string_replace_each(input, _const_encoding__html__escape_seq), _const_encoding__html__escape_quote_seq)) : (string_replace_each(input, _const_encoding__html__escape_seq)));
}
void crypto__sha256__Digest_free(crypto__sha256__Digest* d) {
	{ // Unsafe block
		array_free(&d->x);
		array_free(&d->h);
	}
}
VV_LOCAL_SYMBOL void crypto__sha256__Digest_init(crypto__sha256__Digest* d) {
	d->h = __new_array_with_default_noscan((8), 0, sizeof(u32), 0);
	d->x = __new_array_with_default_noscan(_const_crypto__sha256__chunk, 0, sizeof(u8), 0);
	crypto__sha256__Digest_reset(d);
}
void crypto__sha256__Digest_reset(crypto__sha256__Digest* d) {
	if (!d->is224) {
		array_set(&d->h, 0, &(u32[]) { ((u32)(_const_crypto__sha256__init0)) });
		array_set(&d->h, 1, &(u32[]) { ((u32)(_const_crypto__sha256__init1)) });
		array_set(&d->h, 2, &(u32[]) { ((u32)(_const_crypto__sha256__init2)) });
		array_set(&d->h, 3, &(u32[]) { ((u32)(_const_crypto__sha256__init3)) });
		array_set(&d->h, 4, &(u32[]) { ((u32)(_const_crypto__sha256__init4)) });
		array_set(&d->h, 5, &(u32[]) { ((u32)(_const_crypto__sha256__init5)) });
		array_set(&d->h, 6, &(u32[]) { ((u32)(_const_crypto__sha256__init6)) });
		array_set(&d->h, 7, &(u32[]) { ((u32)(_const_crypto__sha256__init7)) });
	} else {
		array_set(&d->h, 0, &(u32[]) { ((u32)(_const_crypto__sha256__init0_224)) });
		array_set(&d->h, 1, &(u32[]) { ((u32)(_const_crypto__sha256__init1_224)) });
		array_set(&d->h, 2, &(u32[]) { ((u32)(_const_crypto__sha256__init2_224)) });
		array_set(&d->h, 3, &(u32[]) { ((u32)(_const_crypto__sha256__init3_224)) });
		array_set(&d->h, 4, &(u32[]) { ((u32)(_const_crypto__sha256__init4_224)) });
		array_set(&d->h, 5, &(u32[]) { ((u32)(_const_crypto__sha256__init5_224)) });
		array_set(&d->h, 6, &(u32[]) { ((u32)(_const_crypto__sha256__init6_224)) });
		array_set(&d->h, 7, &(u32[]) { ((u32)(_const_crypto__sha256__init7_224)) });
	}
	d->nx = 0;
	d->len = 0U;
}
VV_LOCAL_SYMBOL crypto__sha256__Digest* crypto__sha256__Digest_clone(crypto__sha256__Digest* d) {
	return ((crypto__sha256__Digest*)memdup(&(crypto__sha256__Digest){.h = array_clone_to_depth(&d->h, 0),.x = array_clone_to_depth(&d->x, 0),.nx = (d)->nx,.len = (d)->len,.is224 = (d)->is224,}, sizeof(crypto__sha256__Digest)));
}
crypto__sha256__Digest* crypto__sha256__new(void) {
	crypto__sha256__Digest* d = ((crypto__sha256__Digest*)memdup(&(crypto__sha256__Digest){.h = __new_array_noscan(0, 0, sizeof(u32)),.x = __new_array_noscan(0, 0, sizeof(u8)),.nx = 0,.len = 0,.is224 = 0,}, sizeof(crypto__sha256__Digest)));
	crypto__sha256__Digest_init(d);
	return d;
}
_result_int crypto__sha256__Digest_write(crypto__sha256__Digest* d, Array_u8 p_) {
	{ // Unsafe block
		Array_u8 p = p_;
		int nn = p.len;
		d->len += ((u64)(nn));
		if (d->nx > 0) {
			int n = copy(&(array[]){array_slice(d->x, d->nx, 2147483647)}[0], p);
			d->nx += n;
			if (d->nx == 64) {
				crypto__sha256__block(d, d->x);
				d->nx = 0;
			}
			if (n >= p.len) {
				p = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
			} else {
				p = array_slice(p, n, 2147483647);
			}
		}
		if (p.len >= 64) {
			int n = (p.len & ~((int_literal)(64 - 1)));
			crypto__sha256__block(d, array_slice(p, 0, n));
			if (n >= p.len) {
				p = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
			} else {
				p = array_slice(p, n, 2147483647);
			}
		}
		if (p.len > 0) {
			d->nx = copy(&d->x, p);
		}
		_result_int _t1 = {0};
		_result_ok(&(int[]) { nn }, (_result*)(&_t1), sizeof(int));
		return _t1;
	}
	return (_result_int){0};
}
Array_u8 crypto__sha256__Digest_sum(crypto__sha256__Digest* d, Array_u8 b_in) {
	crypto__sha256__Digest* d0 = crypto__sha256__Digest_clone(d);
	Array_u8 hash = crypto__sha256__Digest_checksum(d0);
	Array_u8 b_out = array_clone_to_depth(&b_in, 0);
	if (d0->is224) {
		Array_u8 _t1 = array_slice(hash, 0, _const_crypto__sha256__size224);
		for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
			u8 b = ((u8*)_t1.data)[_t2];
			array_push_noscan((array*)&b_out, _MOV((u8[]){ b }));
		}
	} else {
		for (int _t4 = 0; _t4 < hash.len; ++_t4) {
			u8 b = ((u8*)hash.data)[_t4];
			array_push_noscan((array*)&b_out, _MOV((u8[]){ b }));
		}
	}
	return b_out;
}
VV_LOCAL_SYMBOL Array_u8 crypto__sha256__Digest_checksum(crypto__sha256__Digest* d) {
	u64 len = d->len;
	Array_u8 tmp = __new_array_with_default_noscan((64), 0, sizeof(u8), 0);
	((u8*)tmp.data)[0] = 0x80;
	if ((int)(((int)(len)) % 64) < 56) {
		_result_int _t1 = crypto__sha256__Digest_write(d, array_slice(tmp, 0, (int)(56 - (int)(((int)(len)) % 64))));
		if (_t1.is_error) {
			IError err = _t1.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
	} else {
		_result_int _t2 = crypto__sha256__Digest_write(d, array_slice(tmp, 0, (int)((int_literal)(64 + 56) - (int)(((int)(len)) % 64))));
		if (_t2.is_error) {
			IError err = _t2.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
	}
	len <<= ((u64)(3U));
	encoding__binary__big_endian_put_u64(&tmp, len);
	_result_int _t3 = crypto__sha256__Digest_write(d, array_slice(tmp, 0, 8));
	if (_t3.is_error) {
		IError err = _t3.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 ;
	if (d->nx != 0) {
		_v_panic(_SLIT("d.nx != 0"));
		VUNREACHABLE();
	}
	Array_u8 digest = __new_array_with_default_noscan(_const_crypto__sha256__size, 0, sizeof(u8), 0);
	encoding__binary__big_endian_put_u32(&digest, ((u32*)d->h.data)[0]);
	encoding__binary__big_endian_put_u32(&(array[]){array_slice(digest, 4, 2147483647)}[0], ((u32*)d->h.data)[1]);
	encoding__binary__big_endian_put_u32(&(array[]){array_slice(digest, 8, 2147483647)}[0], ((u32*)d->h.data)[2]);
	encoding__binary__big_endian_put_u32(&(array[]){array_slice(digest, 12, 2147483647)}[0], ((u32*)d->h.data)[3]);
	encoding__binary__big_endian_put_u32(&(array[]){array_slice(digest, 16, 2147483647)}[0], ((u32*)d->h.data)[4]);
	encoding__binary__big_endian_put_u32(&(array[]){array_slice(digest, 20, 2147483647)}[0], ((u32*)d->h.data)[5]);
	encoding__binary__big_endian_put_u32(&(array[]){array_slice(digest, 24, 2147483647)}[0], ((u32*)d->h.data)[6]);
	if (!d->is224) {
		encoding__binary__big_endian_put_u32(&(array[]){array_slice(digest, 28, 2147483647)}[0], ((u32*)d->h.data)[7]);
	}
	return digest;
}
Array_u8 crypto__sha256__sum(Array_u8 data) {
	return crypto__sha256__sum256(data);
}
Array_u8 crypto__sha256__sum256(Array_u8 data) {
	crypto__sha256__Digest* d = crypto__sha256__new();
	_result_int _t1 = crypto__sha256__Digest_write(d, data);
	if (_t1.is_error) {
		IError err = _t1.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 ;
	return crypto__sha256__Digest_checksum(d);
}
VV_LOCAL_SYMBOL void crypto__sha256__block(crypto__sha256__Digest* dig, Array_u8 p) {
	crypto__sha256__block_generic(dig, p);
}
int crypto__sha256__Digest_size(crypto__sha256__Digest* d) {
	if (!d->is224) {
		return _const_crypto__sha256__size;
	}
	return _const_crypto__sha256__size224;
}
int crypto__sha256__Digest_block_size(crypto__sha256__Digest* d) {
	return _const_crypto__sha256__block_size;
}
VV_LOCAL_SYMBOL void crypto__sha256__block_generic(crypto__sha256__Digest* dig, Array_u8 p_) {
	{ // Unsafe block
		Array_u8 p = p_;
		Array_u32 w = __new_array_with_default_noscan((64), 0, sizeof(u32), 0);
		u32 h0 = ((u32*)dig->h.data)[0];
		u32 h1 = ((u32*)dig->h.data)[1];
		u32 h2 = ((u32*)dig->h.data)[2];
		u32 h3 = ((u32*)dig->h.data)[3];
		u32 h4 = ((u32*)dig->h.data)[4];
		u32 h5 = ((u32*)dig->h.data)[5];
		u32 h6 = ((u32*)dig->h.data)[6];
		u32 h7 = ((u32*)dig->h.data)[7];
		for (;;) {
			if (!(p.len >= 64)) break;
			for (int i = 0; i < 16; ++i) {
				int j = (int_literal)(i * 4);
				((u32*)w.data)[i] = ((((((u32)(((u8*)p.data)[j])) << 24U) | (((u32)(((u8*)p.data)[(int)(j + 1)])) << 16U)) | (((u32)(((u8*)p.data)[(int)(j + 2)])) << 8U)) | ((u32)(((u8*)p.data)[(int)(j + 3)])));
			}
			for (int i = 16; i < 64; i++) {
				u32 v1 = ((u32*)w.data)[(int)(i - 2)];
				u32 t1 = (((math__bits__rotate_left_32(v1, -17)) ^ (math__bits__rotate_left_32(v1, -19))) ^ ((v1 >> 10U)));
				u32 v2 = ((u32*)w.data)[(int)(i - 15)];
				u32 t2 = (((math__bits__rotate_left_32(v2, -7)) ^ (math__bits__rotate_left_32(v2, -18))) ^ ((v2 >> 3U)));
				((u32*)w.data)[i] = (u32)((u32)((u32)(t1 + ((u32*)w.data)[(int)(i - 7)]) + t2) + ((u32*)w.data)[(int)(i - 16)]);
			}
			u32 a = h0;
			u32 b = h1;
			u32 c = h2;
			u32 d = h3;
			u32 e = h4;
			u32 f = h5;
			u32 g = h6;
			u32 h = h7;
			for (int i = 0; i < 64; ++i) {
				u32 t1 = (u32)((u32)((u32)((u32)(h + ((((math__bits__rotate_left_32(e, -6)) ^ (math__bits__rotate_left_32(e, -11))) ^ (math__bits__rotate_left_32(e, -25))))) + ((((e & f)) ^ ((~e & g))))) + ((u32)(((int*)_const_crypto__sha256___k.data)[i]))) + ((u32*)w.data)[i]);
				u32 t2 = (u32)(((((math__bits__rotate_left_32(a, -2)) ^ (math__bits__rotate_left_32(a, -13))) ^ (math__bits__rotate_left_32(a, -22)))) + (((((a & b)) ^ ((a & c))) ^ ((b & c)))));
				h = g;
				g = f;
				f = e;
				e = (u32)(d + t1);
				d = c;
				c = b;
				b = a;
				a = (u32)(t1 + t2);
			}
			h0 += a;
			h1 += b;
			h2 += c;
			h3 += d;
			h4 += e;
			h5 += f;
			h6 += g;
			h7 += h;
			if (64 >= p.len) {
				p = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
			} else {
				p = array_slice(p, _const_crypto__sha256__chunk, 2147483647);
			}
		}
		((u32*)dig->h.data)[0] = h0;
		((u32*)dig->h.data)[1] = h1;
		((u32*)dig->h.data)[2] = h2;
		((u32*)dig->h.data)[3] = h3;
		((u32*)dig->h.data)[4] = h4;
		((u32*)dig->h.data)[5] = h5;
		((u32*)dig->h.data)[6] = h6;
		((u32*)dig->h.data)[7] = h7;
	}
}
inline VV_LOCAL_SYMBOL u32 rand__seed__nr_next(u32 prev) {
	return (u32)((u32)(prev * 1664525U) + 1013904223U);
}
Array_u32 rand__seed__time_seed_array(int count) {
	u64 ctime = time__sys_mono_now();
	u32 seed = ((u32)(((ctime >> 32U) ^ ((ctime & 0x00000000FFFFFFFFU)))));
	Array_u32 seed_data = __new_array_with_default_noscan(0, count, sizeof(u32), 0);
	for (int _t1 = 0; _t1 < count; ++_t1) {
		seed = rand__seed__nr_next(seed);
		array_push_noscan((array*)&seed_data, _MOV((u32[]){ rand__seed__nr_next(seed) }));
	}
	return seed_data;
}
u64 rand__seed__time_seed_64(void) {
	Array_u32 seed_data = rand__seed__time_seed_array(2);
	u64 lower = ((u64)((*(u32*)array_get(seed_data, 0))));
	u64 upper = ((u64)((*(u32*)array_get(seed_data, 1))));
	array_free(&seed_data);
	u64 res = (lower | ((upper << 32U)));
	return res;
}
_result_Array_Array_orm__Primitive db__sqlite__DB_select(db__sqlite__DB _v_toheap_db, orm__SelectConfig config, orm__QueryData data, orm__QueryData where) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	bool db__sqlite__DB_select_defer_0 = false;
	db__sqlite__Stmt* stmt;
	string query = orm__orm_select_gen(config, _SLIT("`"), true, _SLIT("?"), 1, where);
	_result_db__sqlite__Stmt _t1 = db__sqlite__DB_new_init_stmt(&(*(db)), query);
	if (_t1.is_error) {
		_result_Array_Array_orm__Primitive _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	stmt = HEAP(db__sqlite__Stmt, ((*(db__sqlite__Stmt*)_t1.data)));
	db__sqlite__DB_select_defer_0 = true;
	int c = 1;
	_result_void _t3 = db__sqlite__sqlite_stmt_binder((*(stmt)), where, query, (voidptr)&c);
	if (_t3.is_error) {
	// Defer begin
	if (db__sqlite__DB_select_defer_0) {
		db__sqlite__Stmt_finalize(&(*(stmt)));
	}
	// Defer end
		_result_Array_Array_orm__Primitive _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	_result_void _t5 = db__sqlite__sqlite_stmt_binder((*(stmt)), data, query, (voidptr)&c);
	if (_t5.is_error) {
	// Defer begin
	if (db__sqlite__DB_select_defer_0) {
		db__sqlite__Stmt_finalize(&(*(stmt)));
	}
	// Defer end
		_result_Array_Array_orm__Primitive _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 ;
	Array_Array_orm__Primitive ret = __new_array_with_default(0, 0, sizeof(Array_orm__Primitive), 0);
	if (config.is_count) {
		int step = db__sqlite__Stmt_step(&(*(stmt)));
		if (!(step == _const_db__sqlite__sqlite_row || step == _const_db__sqlite__sqlite_ok || step == _const_db__sqlite__sqlite_done)) {
			_result_Array_Array_orm__Primitive _t7 = (_result_Array_Array_orm__Primitive){ .is_error=true, .err=db__sqlite__DB_error_message(&(*(db)), step, query), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (db__sqlite__DB_select_defer_0) {
				db__sqlite__Stmt_finalize(&(*(stmt)));
			}
			// Defer end
			return _t7;
		}
		_result_orm__Primitive _t8 = db__sqlite__Stmt_sqlite_select_column((*(stmt)), 0, 8);
		if (_t8.is_error) {
		// Defer begin
		if (db__sqlite__DB_select_defer_0) {
			db__sqlite__Stmt_finalize(&(*(stmt)));
		}
		// Defer end
			_result_Array_Array_orm__Primitive _t9;
			memcpy(&_t9, &_t8, sizeof(_result));
			return _t9;
		}
		
 		orm__Primitive count = (*(orm__Primitive*)_t8.data);
		array_push((array*)&ret, _MOV((Array_orm__Primitive[]){ new_array_from_c_array(1, 1, sizeof(orm__Primitive), _MOV((orm__Primitive[1]){count})) }));
		_result_Array_Array_orm__Primitive _t11 = {0};
		_result_ok(&(Array_Array_orm__Primitive[]) { ret }, (_result*)(&_t11), sizeof(Array_Array_orm__Primitive));
		// Defer begin
		if (db__sqlite__DB_select_defer_0) {
			db__sqlite__Stmt_finalize(&(*(stmt)));
		}
		// Defer end
		return _t11;
	}
	for (;;) {
		int step = db__sqlite__Stmt_step(&(*(stmt)));
		if (step == 101) {
			break;
		}
		if (step != 0 && step != 100) {
			break;
		}
		Array_orm__Primitive row = __new_array_with_default(0, 0, sizeof(orm__Primitive), 0);
		for (int i = 0; i < config.types.len; ++i) {
			int typ = ((int*)config.types.data)[i];
			_result_orm__Primitive _t12 = db__sqlite__Stmt_sqlite_select_column((*(stmt)), i, typ);
			if (_t12.is_error) {
			// Defer begin
			if (db__sqlite__DB_select_defer_0) {
				db__sqlite__Stmt_finalize(&(*(stmt)));
			}
			// Defer end
				_result_Array_Array_orm__Primitive _t13;
				memcpy(&_t13, &_t12, sizeof(_result));
				return _t13;
			}
			
 			orm__Primitive primitive = (*(orm__Primitive*)_t12.data);
			array_push((array*)&row, _MOV((orm__Primitive[]){ primitive }));
		}
		array_push((array*)&ret, &row);
	}
	_result_Array_Array_orm__Primitive _t16 = {0};
	_result_ok(&(Array_Array_orm__Primitive[]) { ret }, (_result*)(&_t16), sizeof(Array_Array_orm__Primitive));
	// Defer begin
	if (db__sqlite__DB_select_defer_0) {
		db__sqlite__Stmt_finalize(&(*(stmt)));
	}
	// Defer end
	return _t16;
}
_result_void db__sqlite__DB_insert(db__sqlite__DB _v_toheap_db, string table, orm__QueryData data) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	multi_return_string_orm__QueryData mr_1372 = orm__orm_stmt_gen(orm__SQLDialect__sqlite, table, _SLIT("`"), orm__StmtKind__insert, true, _SLIT("?"), 1, data, ((orm__QueryData){.fields = __new_array(0, 0, sizeof(string)),.data = __new_array(0, 0, sizeof(orm__Primitive)),.types = __new_array_noscan(0, 0, sizeof(int)),.parentheses = __new_array(0, 0, sizeof(Array_int)),.kinds = __new_array_noscan(0, 0, sizeof(orm__OperationKind)),.auto_fields = __new_array_noscan(0, 0, sizeof(int)),.is_and = __new_array_noscan(0, 0, sizeof(bool)),}));
	string query = mr_1372.arg0;
	orm__QueryData converted_data = mr_1372.arg1;
	_result_void _t1 = db__sqlite__sqlite_stmt_worker((*(db)), query, converted_data, ((orm__QueryData){.fields = __new_array(0, 0, sizeof(string)),.data = __new_array(0, 0, sizeof(orm__Primitive)),.types = __new_array_noscan(0, 0, sizeof(int)),.parentheses = __new_array(0, 0, sizeof(Array_int)),.kinds = __new_array_noscan(0, 0, sizeof(orm__OperationKind)),.auto_fields = __new_array_noscan(0, 0, sizeof(int)),.is_and = __new_array_noscan(0, 0, sizeof(bool)),}));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
_result_void db__sqlite__DB_update(db__sqlite__DB _v_toheap_db, string table, orm__QueryData data, orm__QueryData where) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	multi_return_string_orm__QueryData mr_1693 = orm__orm_stmt_gen(orm__SQLDialect__sqlite, table, _SLIT("`"), orm__StmtKind__update, true, _SLIT("?"), 1, data, where);
	string query = mr_1693.arg0;
	_result_void _t1 = db__sqlite__sqlite_stmt_worker((*(db)), query, data, where);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
_result_void db__sqlite__DB_delete(db__sqlite__DB _v_toheap_db, string table, orm__QueryData where) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	multi_return_string_orm__QueryData mr_1962 = orm__orm_stmt_gen(orm__SQLDialect__sqlite, table, _SLIT("`"), orm__StmtKind__delete, true, _SLIT("?"), 1, ((orm__QueryData){.fields = __new_array(0, 0, sizeof(string)),.data = __new_array(0, 0, sizeof(orm__Primitive)),.types = __new_array_noscan(0, 0, sizeof(int)),.parentheses = __new_array(0, 0, sizeof(Array_int)),.kinds = __new_array_noscan(0, 0, sizeof(orm__OperationKind)),.auto_fields = __new_array_noscan(0, 0, sizeof(int)),.is_and = __new_array_noscan(0, 0, sizeof(bool)),}), where);
	string query = mr_1962.arg0;
	_result_void _t1 = db__sqlite__sqlite_stmt_worker((*(db)), query, ((orm__QueryData){.fields = __new_array(0, 0, sizeof(string)),.data = __new_array(0, 0, sizeof(orm__Primitive)),.types = __new_array_noscan(0, 0, sizeof(int)),.parentheses = __new_array(0, 0, sizeof(Array_int)),.kinds = __new_array_noscan(0, 0, sizeof(orm__OperationKind)),.auto_fields = __new_array_noscan(0, 0, sizeof(int)),.is_and = __new_array_noscan(0, 0, sizeof(bool)),}), where);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
int db__sqlite__DB_last_id(db__sqlite__DB _v_toheap_db) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	string query = _SLIT("SELECT last_insert_rowid();");
	_result_int _t2 = db__sqlite__DB_q_int(&(*(db)), query);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(int*) _t2.data = 0;
	}
	
 	return (*(int*)_t2.data);
}
_result_void db__sqlite__DB_create(db__sqlite__DB _v_toheap_db, string table, Array_orm__TableField fields) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	_result_string _t1 = orm__orm_table_gen(table, _SLIT("`"), true, 0, fields, (voidptr)db__sqlite__sqlite_type_from_v, false);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_void){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	string query = (*(string*)_t1.data);
	_result_void _t3 = db__sqlite__sqlite_stmt_worker((*(db)), query, ((orm__QueryData){.fields = __new_array(0, 0, sizeof(string)),.data = __new_array(0, 0, sizeof(orm__Primitive)),.types = __new_array_noscan(0, 0, sizeof(int)),.parentheses = __new_array(0, 0, sizeof(Array_int)),.kinds = __new_array_noscan(0, 0, sizeof(orm__OperationKind)),.auto_fields = __new_array_noscan(0, 0, sizeof(int)),.is_and = __new_array_noscan(0, 0, sizeof(bool)),}), ((orm__QueryData){.fields = __new_array(0, 0, sizeof(string)),.data = __new_array(0, 0, sizeof(orm__Primitive)),.types = __new_array_noscan(0, 0, sizeof(int)),.parentheses = __new_array(0, 0, sizeof(Array_int)),.kinds = __new_array_noscan(0, 0, sizeof(orm__OperationKind)),.auto_fields = __new_array_noscan(0, 0, sizeof(int)),.is_and = __new_array_noscan(0, 0, sizeof(bool)),}));
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	return (_result_void){0};
}
_result_void db__sqlite__DB_drop(db__sqlite__DB _v_toheap_db, string table) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	string query = str_intp(2, _MOV((StrIntpData[]){{_SLIT("DROP TABLE `"), 0xfe10, {.d_s = table}}, {_SLIT("`;"), 0, { .d_c = 0 }}}));
	_result_void _t1 = db__sqlite__sqlite_stmt_worker((*(db)), query, ((orm__QueryData){.fields = __new_array(0, 0, sizeof(string)),.data = __new_array(0, 0, sizeof(orm__Primitive)),.types = __new_array_noscan(0, 0, sizeof(int)),.parentheses = __new_array(0, 0, sizeof(Array_int)),.kinds = __new_array_noscan(0, 0, sizeof(orm__OperationKind)),.auto_fields = __new_array_noscan(0, 0, sizeof(int)),.is_and = __new_array_noscan(0, 0, sizeof(bool)),}), ((orm__QueryData){.fields = __new_array(0, 0, sizeof(string)),.data = __new_array(0, 0, sizeof(orm__Primitive)),.types = __new_array_noscan(0, 0, sizeof(int)),.parentheses = __new_array(0, 0, sizeof(Array_int)),.kinds = __new_array_noscan(0, 0, sizeof(orm__OperationKind)),.auto_fields = __new_array_noscan(0, 0, sizeof(int)),.is_and = __new_array_noscan(0, 0, sizeof(bool)),}));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
VV_LOCAL_SYMBOL _result_void db__sqlite__sqlite_stmt_worker(db__sqlite__DB _v_toheap_db, string query, orm__QueryData data, orm__QueryData where) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	bool db__sqlite__sqlite_stmt_worker_defer_0 = false;
	db__sqlite__Stmt* stmt;
	_result_db__sqlite__Stmt _t1 = db__sqlite__DB_new_init_stmt(&(*(db)), query);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	stmt = HEAP(db__sqlite__Stmt, ((*(db__sqlite__Stmt*)_t1.data)));
	db__sqlite__sqlite_stmt_worker_defer_0 = true;
	int c = 1;
	_result_void _t3 = db__sqlite__sqlite_stmt_binder((*(stmt)), data, query, (voidptr)&c);
	if (_t3.is_error) {
	// Defer begin
	if (db__sqlite__sqlite_stmt_worker_defer_0) {
		db__sqlite__Stmt_finalize(&(*(stmt)));
	}
	// Defer end
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	_result_void _t5 = db__sqlite__sqlite_stmt_binder((*(stmt)), where, query, (voidptr)&c);
	if (_t5.is_error) {
	// Defer begin
	if (db__sqlite__sqlite_stmt_worker_defer_0) {
		db__sqlite__Stmt_finalize(&(*(stmt)));
	}
	// Defer end
		_result_void _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 ;
	_result_void _t7 = db__sqlite__Stmt_orm_step(&(*(stmt)), query);
	if (_t7.is_error) {
	// Defer begin
	if (db__sqlite__sqlite_stmt_worker_defer_0) {
		db__sqlite__Stmt_finalize(&(*(stmt)));
	}
	// Defer end
		_result_void _t8;
		memcpy(&_t8, &_t7, sizeof(_result));
		return _t8;
	}
	
 ;
	// Defer begin
	if (db__sqlite__sqlite_stmt_worker_defer_0) {
		db__sqlite__Stmt_finalize(&(*(stmt)));
	}
	// Defer end
	return (_result_void){0};
}
VV_LOCAL_SYMBOL _result_void db__sqlite__sqlite_stmt_binder(db__sqlite__Stmt _v_toheap_stmt, orm__QueryData d, string query, int* c) {
db__sqlite__Stmt* stmt = HEAP(db__sqlite__Stmt, _v_toheap_stmt);
	for (int _t1 = 0; _t1 < d.data.len; ++_t1) {
		orm__Primitive data = ((orm__Primitive*)d.data.data)[_t1];
		int err = db__sqlite__bind((*(stmt)), c, data);
		if (err != 0) {
			return (_result_void){ .is_error=true, .err=db__sqlite__DB_error_message((*(stmt)).db, err, query), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		(*c)++;
	}
	return (_result_void){0};
}
VV_LOCAL_SYMBOL int db__sqlite__bind(db__sqlite__Stmt _v_toheap_stmt, int* c, orm__Primitive data) {
db__sqlite__Stmt* stmt = HEAP(db__sqlite__Stmt, _v_toheap_stmt);
	int err = 0;
	if (data._typ == 5 /* i8 */) {
		err = db__sqlite__Stmt_bind_int(&(*(stmt)), *c, ((int)((*data._i8))));
	}
	else if (data._typ == 6 /* i16 */) {
		err = db__sqlite__Stmt_bind_int(&(*(stmt)), *c, ((int)((*data._i16))));
	}
	else if (data._typ == 8 /* int */) {
		err = db__sqlite__Stmt_bind_int(&(*(stmt)), *c, ((int)((*data._int))));
	}
	else if (data._typ == 11 /* u8 */) {
		err = db__sqlite__Stmt_bind_int(&(*(stmt)), *c, ((int)((*data._u8))));
	}
	else if (data._typ == 12 /* u16 */) {
		err = db__sqlite__Stmt_bind_int(&(*(stmt)), *c, ((int)((*data._u16))));
	}
	else if (data._typ == 13 /* u32 */) {
		err = db__sqlite__Stmt_bind_int(&(*(stmt)), *c, ((int)((*data._u32))));
	}
	else if (data._typ == 19 /* bool */) {
		err = db__sqlite__Stmt_bind_int(&(*(stmt)), *c, (int[]){((*data._bool))?1:0}[0]);
	}
	else if (data._typ == 9 /* i64 */) {
		err = db__sqlite__Stmt_bind_i64(&(*(stmt)), *c, ((i64)((*data._i64))));
	}
	else if (data._typ == 14 /* u64 */) {
		err = db__sqlite__Stmt_bind_i64(&(*(stmt)), *c, ((i64)((*data._u64))));
	}
	else if (data._typ == 16 /* f32 */) {
		err = db__sqlite__Stmt_bind_f64(&(*(stmt)), *c, *(((f64*)(&(*data._f32)))));
	}
	else if (data._typ == 17 /* f64 */) {
		err = db__sqlite__Stmt_bind_f64(&(*(stmt)), *c, *(((f64*)(&(*data._f64)))));
	}
	else if (data._typ == 21 /* string */) {
		err = db__sqlite__Stmt_bind_text(&(*(stmt)), *c, (*data._string));
	}
	else if (data._typ == 142 /* time.Time */) {
		err = db__sqlite__Stmt_bind_int(&(*(stmt)), *c, ((int)(time__Time_unix((*data._time__Time)))));
	}
	else if (data._typ == 143 /* orm.InfixType */) {
		err = db__sqlite__bind((*(stmt)), c, (*data._orm__InfixType).right);
	}
	else if (data._typ == 144 /* orm.Null */) {
		err = db__sqlite__Stmt_bind_null(&(*(stmt)), *c);
	}
	
	return err;
}
VV_LOCAL_SYMBOL _result_orm__Primitive db__sqlite__Stmt_sqlite_select_column(db__sqlite__Stmt _v_toheap_stmt, int idx, int typ) {
db__sqlite__Stmt* stmt = HEAP(db__sqlite__Stmt, _v_toheap_stmt);
	if ((Array_int_contains(_const_orm__nums, typ)) || typ == -1) {
		_option_int _t2 = db__sqlite__Stmt_get_int(&(*(stmt)), idx);
		if (_t2.state != 0) {
			IError err = _t2.err;
			_result_orm__Primitive _t3 = {0};
			_result_ok(&(orm__Primitive[]) { orm__Null_to_sumtype_orm__Primitive(ADDR(orm__Null, (((orm__Null){EMPTY_STRUCT_INITIALIZATION})))) }, (_result*)(&_t3), sizeof(orm__Primitive));
			return _t3;
		}
		
 		_result_orm__Primitive _t1 = {0};
		_result_ok(&(orm__Primitive[]) { int_to_sumtype_orm__Primitive(ADDR(int, ((*(int*)_t2.data)))) }, (_result*)(&_t1), sizeof(orm__Primitive));
		return _t1;
	} else if ((Array_int_contains(_const_orm__num64, typ))) {
		_option_i64 _t5 = db__sqlite__Stmt_get_i64(&(*(stmt)), idx);
		if (_t5.state != 0) {
			IError err = _t5.err;
			_result_orm__Primitive _t6 = {0};
			_result_ok(&(orm__Primitive[]) { orm__Null_to_sumtype_orm__Primitive(ADDR(orm__Null, (((orm__Null){EMPTY_STRUCT_INITIALIZATION})))) }, (_result*)(&_t6), sizeof(orm__Primitive));
			return _t6;
		}
		
 		_result_orm__Primitive _t4 = {0};
		_result_ok(&(orm__Primitive[]) { i64_to_sumtype_orm__Primitive(ADDR(i64, ((*(i64*)_t5.data)))) }, (_result*)(&_t4), sizeof(orm__Primitive));
		return _t4;
	} else if ((Array_int_contains(_const_orm__float, typ))) {
		_option_f64 _t8 = db__sqlite__Stmt_get_f64(&(*(stmt)), idx);
		if (_t8.state != 0) {
			IError err = _t8.err;
			_result_orm__Primitive _t9 = {0};
			_result_ok(&(orm__Primitive[]) { orm__Null_to_sumtype_orm__Primitive(ADDR(orm__Null, (((orm__Null){EMPTY_STRUCT_INITIALIZATION})))) }, (_result*)(&_t9), sizeof(orm__Primitive));
			return _t9;
		}
		
 		_result_orm__Primitive _t7 = {0};
		_result_ok(&(orm__Primitive[]) { f64_to_sumtype_orm__Primitive(ADDR(f64, ((*(f64*)_t8.data)))) }, (_result*)(&_t7), sizeof(orm__Primitive));
		return _t7;
	} else if (typ == _const_orm__type_string) {
		_option_string _t10;
		if (_t10 = db__sqlite__Stmt_get_text(&(*(stmt)), idx), _t10.state == 0) {
			string v = *(string*)_t10.data;
			_result_orm__Primitive _t11 = {0};
			_result_ok(&(orm__Primitive[]) { string_to_sumtype_orm__Primitive(ADDR(string, (string_clone(v)))) }, (_result*)(&_t11), sizeof(orm__Primitive));
			return _t11;
		} else {
			IError err = _t10.err;
			_result_orm__Primitive _t12 = {0};
			_result_ok(&(orm__Primitive[]) { orm__Null_to_sumtype_orm__Primitive(ADDR(orm__Null, (((orm__Null){EMPTY_STRUCT_INITIALIZATION})))) }, (_result*)(&_t12), sizeof(orm__Primitive));
			return _t12;
		}
	} else if (typ == -3) {
		_option_i64 _t14 = db__sqlite__Stmt_get_i64(&(*(stmt)), idx);
		if (_t14.state != 0) {
			IError err = _t14.err;
			_result_orm__Primitive _t15 = {0};
			_result_ok(&(orm__Primitive[]) { orm__Null_to_sumtype_orm__Primitive(ADDR(orm__Null, (((orm__Null){EMPTY_STRUCT_INITIALIZATION})))) }, (_result*)(&_t15), sizeof(orm__Primitive));
			return _t15;
		}
		
 		_result_orm__Primitive _t13 = {0};
		_result_ok(&(orm__Primitive[]) { i64_to_sumtype_orm__Primitive(ADDR(i64, ((*(i64*)_t14.data)))) }, (_result*)(&_t13), sizeof(orm__Primitive));
		return _t13;
	} else if (typ == -2) {
		_option_int _t16;
		if (_t16 = db__sqlite__Stmt_get_int(&(*(stmt)), idx), _t16.state == 0) {
			int v = *(int*)_t16.data;
			_result_orm__Primitive _t17 = {0};
			_result_ok(&(orm__Primitive[]) { time__Time_to_sumtype_orm__Primitive(ADDR(time__Time, (time__unix(v)))) }, (_result*)(&_t17), sizeof(orm__Primitive));
			return _t17;
		} else {
			IError err = _t16.err;
			_result_orm__Primitive _t18 = {0};
			_result_ok(&(orm__Primitive[]) { orm__Null_to_sumtype_orm__Primitive(ADDR(orm__Null, (((orm__Null){EMPTY_STRUCT_INITIALIZATION})))) }, (_result*)(&_t18), sizeof(orm__Primitive));
			return _t18;
		}
	} else {
		return (_result_orm__Primitive){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unknown type "), 0xfe07, {.d_i32 = typ}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_orm__Primitive){0};
}
VV_LOCAL_SYMBOL _result_string db__sqlite__sqlite_type_from_v(int typ) {
	_result_string _t2; /* if prepend */
	if ((Array_int_contains(_const_orm__nums, typ)) || (Array_int_contains(_const_orm__num64, typ)) || (typ == _const_orm__serial || typ == _const_orm__time_ || typ == _const_orm__enum_)) {
		_result_ok(&(string[]) { _SLIT("INTEGER") }, (_result*)(&_t2), sizeof(string));
	} else if ((Array_int_contains(_const_orm__float, typ))) {
		_result_ok(&(string[]) { _SLIT("REAL") }, (_result*)(&_t2), sizeof(string));
	} else if (typ == _const_orm__type_string) {
		_result_ok(&(string[]) { _SLIT("TEXT") }, (_result*)(&_t2), sizeof(string));
	} else {
		_t2.is_error = true;
		_t2.err = _v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unknown type "), 0xfe07, {.d_i32 = typ}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	return _t2;
}
#if defined(_WIN32)
#else
#endif
string db__sqlite__DB_str(db__sqlite__DB* db) {
	return string__plus(string__plus(_SLIT("sqlite.DB{ conn: "), ptr_str(db->conn)), _SLIT(" }"));
}
_result_db__sqlite__DB db__sqlite__connect(string path) {
	struct sqlite3* db = ((struct sqlite3*)(((void*)0)));
	int code = sqlite3_open(((char*)(path.str)), &db);
	if (code != 0) {
		return (_result_db__sqlite__DB){ .is_error=true, .err=I_db__sqlite__SQLError_to_Interface_IError(((db__sqlite__SQLError*)memdup(&(db__sqlite__SQLError){.MessageError = ((MessageError){.msg = cstring_to_vstring(((char*)(sqlite3_errmsg(db)))),.code = code,}),}, sizeof(db__sqlite__SQLError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_db__sqlite__DB _t2 = {0};
	_result_ok(&(db__sqlite__DB[]) { ((db__sqlite__DB){.is_open = true,.conn = db,}) }, (_result*)(&_t2), sizeof(db__sqlite__DB));
	return _t2;
}
_result_int db__sqlite__DB_q_int(db__sqlite__DB* db, string query) {
	bool db__sqlite__DB_q_int_defer_0 = false;
	struct sqlite3_stmt* stmt;
	stmt = ((struct sqlite3_stmt*)(((void*)0)));
	int pres = sqlite3_prepare_v2(db->conn, ((char*)(query.str)), query.len, &stmt, 0);
	if (pres != 0) {
		return (_result_int){ .is_error=true, .err=db__sqlite__DB_error_message(db, pres, query), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	db__sqlite__DB_q_int_defer_0 = true;
	int code = sqlite3_step(stmt);
	if (code != 100) {
		_result_int _t2 = (_result_int){ .is_error=true, .err=db__sqlite__DB_error_message(db, code, query), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (db__sqlite__DB_q_int_defer_0) {
			sqlite3_finalize(stmt);
		}
		// Defer end
		return _t2;
	}
	int res = sqlite3_column_int(stmt, 0);
	_result_int _t3 = {0};
	_result_ok(&(int[]) { res }, (_result*)(&_t3), sizeof(int));
	// Defer begin
	if (db__sqlite__DB_q_int_defer_0) {
		sqlite3_finalize(stmt);
	}
	// Defer end
	return _t3;
}
_result_Array_db__sqlite__Row db__sqlite__DB_exec(db__sqlite__DB* db, string query) {
	bool db__sqlite__DB_exec_defer_0 = false;
	struct sqlite3_stmt* stmt;
	stmt = ((struct sqlite3_stmt*)(((void*)0)));
	int code = sqlite3_prepare_v2(db->conn, ((char*)(query.str)), query.len, &stmt, 0);
	if (code != 0) {
		return (_result_Array_db__sqlite__Row){ .is_error=true, .err=db__sqlite__DB_error_message(db, code, query), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	db__sqlite__DB_exec_defer_0 = true;
	int nr_cols = sqlite3_column_count(stmt);
	int res = 0;
	Array_db__sqlite__Row rows = __new_array_with_default(0, 0, sizeof(db__sqlite__Row), 0);
	for (;;) {
		res = sqlite3_step(stmt);
		if (res != 100) {
			break;
		}
		db__sqlite__Row row = ((db__sqlite__Row){.vals = __new_array(0, 0, sizeof(string)),});
		for (int i = 0; i < nr_cols; ++i) {
			u8* val = ((u8*)(sqlite3_column_text(stmt, i)));
			if (val == ((u8*)(0))) {
				array_push((array*)&row.vals, _MOV((string[]){ _SLIT("") }));
			} else {
				array_push((array*)&row.vals, _MOV((string[]){ string_clone(u8_vstring(val)) }));
			}
		}
		array_push((array*)&rows, _MOV((db__sqlite__Row[]){ row }));
	}
	_result_Array_db__sqlite__Row _t5 = {0};
	_result_ok(&(Array_db__sqlite__Row[]) { rows }, (_result*)(&_t5), sizeof(Array_db__sqlite__Row));
	// Defer begin
	if (db__sqlite__DB_exec_defer_0) {
		sqlite3_finalize(stmt);
	}
	// Defer end
	return _t5;
}
IError db__sqlite__DB_error_message(db__sqlite__DB* db, int code, string query) {
	string errmsg = cstring_to_vstring(((char*)(sqlite3_errmsg(db->conn))));
	string msg = str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = errmsg}}, {_SLIT(" ("), 0xfe07, {.d_i32 = code}}, {_SLIT(") ("), 0xfe10, {.d_s = query}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	string_free(&errmsg);
	return I_db__sqlite__SQLError_to_Interface_IError(((db__sqlite__SQLError*)memdup(&(db__sqlite__SQLError){.MessageError = ((MessageError){.msg = msg,.code = code,}),}, sizeof(db__sqlite__SQLError))));
}
_result_void db__sqlite__DB_synchronization_mode(db__sqlite__DB* db, db__sqlite__SyncMode sync_mode) {
	if (sync_mode == db__sqlite__SyncMode__off) {
		_result_Array_db__sqlite__Row _t1 = db__sqlite__DB_exec(db, _SLIT("pragma synchronous = OFF;"));
		if (_t1.is_error) {
			_result_void _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 ;
	} else if (sync_mode == db__sqlite__SyncMode__full) {
		_result_Array_db__sqlite__Row _t3 = db__sqlite__DB_exec(db, _SLIT("pragma synchronous = FULL;"));
		if (_t3.is_error) {
			_result_void _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 ;
	} else {
		_result_Array_db__sqlite__Row _t5 = db__sqlite__DB_exec(db, _SLIT("pragma synchronous = NORMAL;"));
		if (_t5.is_error) {
			_result_void _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 ;
	}
	return (_result_void){0};
}
_result_void db__sqlite__DB_journal_mode(db__sqlite__DB* db, db__sqlite__JournalMode journal_mode) {
	if (journal_mode == db__sqlite__JournalMode__off) {
		_result_Array_db__sqlite__Row _t1 = db__sqlite__DB_exec(db, _SLIT("pragma journal_mode = OFF;"));
		if (_t1.is_error) {
			_result_void _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 ;
	} else if (journal_mode == db__sqlite__JournalMode__delete) {
		_result_Array_db__sqlite__Row _t3 = db__sqlite__DB_exec(db, _SLIT("pragma journal_mode = DELETE;"));
		if (_t3.is_error) {
			_result_void _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 ;
	} else if (journal_mode == db__sqlite__JournalMode__truncate) {
		_result_Array_db__sqlite__Row _t5 = db__sqlite__DB_exec(db, _SLIT("pragma journal_mode = TRUNCATE;"));
		if (_t5.is_error) {
			_result_void _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 ;
	} else if (journal_mode == db__sqlite__JournalMode__persist) {
		_result_Array_db__sqlite__Row _t7 = db__sqlite__DB_exec(db, _SLIT("pragma journal_mode = PERSIST;"));
		if (_t7.is_error) {
			_result_void _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
 ;
	} else if (journal_mode == db__sqlite__JournalMode__memory) {
		_result_Array_db__sqlite__Row _t9 = db__sqlite__DB_exec(db, _SLIT("pragma journal_mode = MEMORY;"));
		if (_t9.is_error) {
			_result_void _t10;
			memcpy(&_t10, &_t9, sizeof(_result));
			return _t10;
		}
		
 ;
	} else {
		_result_Array_db__sqlite__Row _t11 = db__sqlite__DB_exec(db, _SLIT("pragma journal_mode = MEMORY;"));
		if (_t11.is_error) {
			_result_void _t12;
			memcpy(&_t12, &_t11, sizeof(_result));
			return _t12;
		}
		
 ;
	}
	return (_result_void){0};
}
VV_LOCAL_SYMBOL multi_return_ref_C__sqlite3_stmt_int db__sqlite__DB_init_stmt(db__sqlite__DB* db, string query) {
	struct sqlite3_stmt* stmt = ((struct sqlite3_stmt*)(((void*)0)));
	int err = sqlite3_prepare_v2(db->conn, ((char*)(query.str)), query.len, &stmt, 0);
	return (multi_return_ref_C__sqlite3_stmt_int){.arg0=stmt, .arg1=err};
}
VV_LOCAL_SYMBOL _result_db__sqlite__Stmt db__sqlite__DB_new_init_stmt(db__sqlite__DB* db, string query) {
	multi_return_ref_C__sqlite3_stmt_int mr_611 = db__sqlite__DB_init_stmt(db, query);
	struct sqlite3_stmt* stmt = mr_611.arg0;
	int err = mr_611.arg1;
	if (err != 0) {
		return (_result_db__sqlite__Stmt){ .is_error=true, .err=db__sqlite__DB_error_message(db, err, query), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_db__sqlite__Stmt _t2 = {0};
	_result_ok(&(db__sqlite__Stmt[]) { ((db__sqlite__Stmt){.stmt = stmt,.db = db,}) }, (_result*)(&_t2), sizeof(db__sqlite__Stmt));
	return _t2;
}
VV_LOCAL_SYMBOL int db__sqlite__Stmt_bind_null(db__sqlite__Stmt* stmt, int idx) {
	return sqlite3_bind_null(stmt->stmt, idx);
}
VV_LOCAL_SYMBOL int db__sqlite__Stmt_bind_int(db__sqlite__Stmt* stmt, int idx, int v) {
	return sqlite3_bind_int(stmt->stmt, idx, v);
}
VV_LOCAL_SYMBOL int db__sqlite__Stmt_bind_i64(db__sqlite__Stmt* stmt, int idx, i64 v) {
	return sqlite3_bind_int64(stmt->stmt, idx, v);
}
VV_LOCAL_SYMBOL int db__sqlite__Stmt_bind_f64(db__sqlite__Stmt* stmt, int idx, f64 v) {
	return sqlite3_bind_double(stmt->stmt, idx, v);
}
VV_LOCAL_SYMBOL int db__sqlite__Stmt_bind_text(db__sqlite__Stmt* stmt, int idx, string s) {
	return sqlite3_bind_text(stmt->stmt, idx, ((voidptr)(s.str)), s.len, 0);
}
VV_LOCAL_SYMBOL _option_int db__sqlite__Stmt_get_int(db__sqlite__Stmt* stmt, int idx) {
	if (sqlite3_column_type(stmt->stmt, idx) == SQLITE_NULL) {
		return (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	} else {
		_option_int _t2;
		_option_ok(&(int[]) { sqlite3_column_int(stmt->stmt, idx) }, (_option*)(&_t2), sizeof(int));
		return _t2;
	}
	return (_option_int){.state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION}};
}
VV_LOCAL_SYMBOL _option_i64 db__sqlite__Stmt_get_i64(db__sqlite__Stmt* stmt, int idx) {
	if (sqlite3_column_type(stmt->stmt, idx) == SQLITE_NULL) {
		return (_option_i64){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	} else {
		_option_i64 _t2;
		_option_ok(&(i64[]) { sqlite3_column_int64(stmt->stmt, idx) }, (_option*)(&_t2), sizeof(i64));
		return _t2;
	}
	return (_option_i64){.state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION}};
}
VV_LOCAL_SYMBOL _option_f64 db__sqlite__Stmt_get_f64(db__sqlite__Stmt* stmt, int idx) {
	if (sqlite3_column_type(stmt->stmt, idx) == SQLITE_NULL) {
		return (_option_f64){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	} else {
		_option_f64 _t2;
		_option_ok(&(f64[]) { sqlite3_column_double(stmt->stmt, idx) }, (_option*)(&_t2), sizeof(f64));
		return _t2;
	}
	return (_option_f64){.state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION}};
}
VV_LOCAL_SYMBOL _option_string db__sqlite__Stmt_get_text(db__sqlite__Stmt* stmt, int idx) {
	if (sqlite3_column_type(stmt->stmt, idx) == SQLITE_NULL) {
		return (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	} else {
		char* b = ((char*)(sqlite3_column_text(stmt->stmt, idx)));
		if (b == ((char*)(0))) {
			_option_string _t2;
			_option_ok(&(string[]) { _SLIT("") }, (_option*)(&_t2), sizeof(string));
			return _t2;
		}
		_option_string _t3;
		_option_ok(&(string[]) { char_vstring(b) }, (_option*)(&_t3), sizeof(string));
		return _t3;
	}
	return (_option_string){.state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION}};
}
VV_LOCAL_SYMBOL int db__sqlite__Stmt_step(db__sqlite__Stmt* stmt) {
	return sqlite3_step(stmt->stmt);
}
VV_LOCAL_SYMBOL _result_void db__sqlite__Stmt_orm_step(db__sqlite__Stmt* stmt, string query) {
	int res = db__sqlite__Stmt_step(stmt);
	if (res != 0 && res != 101 && res != 100) {
		return (_result_void){ .is_error=true, .err=db__sqlite__DB_error_message(stmt->db, res, query), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}
VV_LOCAL_SYMBOL void db__sqlite__Stmt_finalize(db__sqlite__Stmt* stmt) {
	sqlite3_finalize(stmt->stmt);
}
VV_LOCAL_SYMBOL string cmd__CmdOption_options(cmd__CmdOption long_option, Array_string args) {
	string flags = _SLIT("");
	flags = long_option.defa;
	for (int i = 0; i < args.len; ++i) {
		string v = ((string*)args.data)[i];
		if (string__eq(v, long_option.abbr) || string__eq(v, long_option.full)) {
			if ((int)(i + 1) < args.len && string_at((*(string*)array_get(args, (int)(i + 1))), 0) != 45) {
				flags = (*(string*)array_get(args, (int)(i + 1)));
			}
		}
	}
	return flags;
}
VV_LOCAL_SYMBOL bool cmd__CmdOption_set_options(cmd__CmdOption long_option, Array_string args) {
	bool flags = false;
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		string v = ((string*)args.data)[_t1];
		if (string__eq(v, long_option.abbr) || string__eq(v, long_option.full)) {
			flags = true;
		}
	}
	return flags;
}
VV_LOCAL_SYMBOL bool cmd__is_options(Array_string args, Array_cmd__CmdOption long_options, string abr) {
	bool flags = false;
	for (int _t1 = 0; _t1 < long_options.len; ++_t1) {
		cmd__CmdOption long_option = ((cmd__CmdOption*)long_options.data)[_t1];
		if (string__eq(abr, long_option.abbr) || string__eq(abr, long_option.full)) {
			flags = true;
		}
	}
	return flags;
}
VV_LOCAL_SYMBOL string cmd__return_args(Array_string args) {
	string flags = _SLIT("");
	Array_string _t1 = array_slice(args, 1, 2147483647);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string i = ((string*)_t1.data)[_t2];
		flags = string__plus(flags, i);
	}
	return flags;
}
cmd__CmdSet cmd__start(string version) {
	Array_cmd__CmdOption long_options = new_array_from_c_array(4, 4, sizeof(cmd__CmdOption), _MOV((cmd__CmdOption[4]){((cmd__CmdOption){.abbr = _SLIT("-h"),.full = _SLIT("-help"),.vari = _SLIT(""),.defa = _SLIT(""),.desc = _SLIT("\346\230\276\347\244\272\347\274\226\347\240\201\347\232\204\345\237\272\346\234\254\344\277\241\346\201\257\345\271\266\351\200\200\345\207\272."),}), ((cmd__CmdOption){.abbr = _SLIT("-v"),.full = _SLIT("--version"),.vari = _SLIT(""),.defa = _SLIT(""),.desc = _SLIT("\346\230\276\347\244\272\347\211\210\346\234\254\345\217\267\345\271\266\351\200\200\345\207\272."),}), ((cmd__CmdOption){.abbr = _SLIT("-n"),.full = _SLIT("--nohup"),.vari = _SLIT(""),.defa = _SLIT(""),.desc = _SLIT("\345\256\210\346\212\244\350\277\233\347\250\213\345\271\266\345\260\206\346\227\245\345\277\227\350\276\223\345\207\272\345\210\260nohup.out\346\226\207\344\273\266(\347\233\256\345\211\215\345\217\252\346\224\257\346\214\201\345\234\250linux\350\256\276\347\275\256)."),}), ((cmd__CmdOption){.abbr = _SLIT("-p"),.full = _SLIT("--port"),.vari = _SLIT("[int]"),.defa = _SLIT("8080"),.desc = _SLIT("\350\256\276\347\275\256\347\253\257\345\217\243\345\217\267."),})}));
	Array_string args = array_clone_to_depth(&_const_os__args, 0);
	cmd__CmdSet cmd_set = ((cmd__CmdSet){.port = string_int(cmd__CmdOption_options((*(cmd__CmdOption*)array_get(long_options, 3)), args)),.args = cmd__return_args(args),.nohup = false,.workers = 3,});
	if (cmd__CmdOption_set_options((*(cmd__CmdOption*)array_get(long_options, 0)), args)) {
		cmd__help(long_options, version);
		_v_exit(1);
		VUNREACHABLE();
	}
	if (cmd__CmdOption_set_options((*(cmd__CmdOption*)array_get(long_options, 1)), args)) {
		println(str_intp(2, _MOV((StrIntpData[]){{_SLIT("VTF "), 0xfe10, {.d_s = version}}, {_SLIT0, 0, { .d_c = 0 }}})));
		_v_exit(1);
		VUNREACHABLE();
	}
	if (args.len > 1) {
		if (!cmd__is_options(args, long_options, (*(string*)array_get(args, 1)))) {
			cmd_set.workers = string_int((*(string*)array_get(args, 1)));
		}
	}
	if (cmd__CmdOption_set_options((*(cmd__CmdOption*)array_get(long_options, 2)), args)) {
		cmd_set.nohup = true;
	}
	return cmd_set;
}
VV_LOCAL_SYMBOL void cmd__help(Array_cmd__CmdOption long_options, string version) {
	string data = str_intp(2, _MOV((StrIntpData[]){{_SLIT("VTF "), 0xfe10, {.d_s = version}}, {_SLIT(", CTF competition platform based on the V programming language."), 0, { .d_c = 0 }}}));
	data = string__plus(data, _SLIT("\nBasic usages:"));
	data = string__plus(data, _SLIT("\n \350\277\220\350\241\214\347\250\213\345\272\217:\tmain [Options]"));
	data = string__plus(data, _SLIT("\n \350\277\220\350\241\214\347\250\213\345\272\217(\350\256\276\347\275\256\347\272\277\347\250\213\346\225\260):\tmain [walkers] [Options]"));
	data = string__plus(data, _SLIT("\nOptions:"));
	println(data);
	for (int _t1 = 0; _t1 < long_options.len; ++_t1) {
		cmd__CmdOption v = ((cmd__CmdOption*)long_options.data)[_t1];
		data = str_intp(4, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe10, {.d_s = v.abbr}}, {_SLIT(", "), 0xfe10, {.d_s = v.full}}, {_SLIT(" "), 0xfe10, {.d_s = v.vari}}, {_SLIT0, 0, { .d_c = 0 }}}));
		int data_len = data.len;
		for (int _t2 = 0; _t2 < ((int)(5 - ((int)(data_len / 8)))); ++_t2) {
			data = string__plus(data, _SLIT("\t"));
		}
		if (((int)(data_len % 8)) == 0) {
			data = string__plus(data, _SLIT("\t"));
		}
		data = string__plus(data, str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v.desc}}, {_SLIT0, 0, { .d_c = 0 }}})));
		println(data);
	}
}
string err_log__sha256_str(string data) {
	return Array_u8_hex(crypto__sha256__sum(string_bytes(data)));
}
void err_log__logs(string data) {
	println(data);
}
int runtime__nr_jobs(void) {
	int cpus = (int)(runtime__nr_cpus() - 1);
	int vjobs = string_int(os__getenv(_SLIT("VJOBS")));
	if (vjobs > 0) {
		cpus = vjobs;
	}
	if (cpus == 0) {
		return 1;
	}
	return cpus;
}
int runtime__nr_cpus(void) {
	return ((int)(sysconf(_SC_NPROCESSORS_ONLN)));
}
void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, Array_u32 seed_data) {
	if (seed_data.len != 2) {
		eprintln(_SLIT("WyRandRNG needs 2 32-bit unsigned integers as the seed."));
		_v_exit(1);
		VUNREACHABLE();
	}
	rng->state = ((*(u32*)array_get(seed_data, 0)) | ((((u64)((*(u32*)array_get(seed_data, 1)))) << 32U)));
	rng->bytes_left = 0;
	rng->buffer = 0U;
}
inline u8 rand__wyrand__WyRandRNG_u8(rand__wyrand__WyRandRNG* rng) {
	if (rng->bytes_left >= 1) {
		rng->bytes_left -= 1;
		u8 value = ((u8)(rng->buffer));
		rng->buffer >>= 8U;
		return value;
	}
	rng->buffer = rand__wyrand__WyRandRNG_u64(rng);
	rng->bytes_left = 7;
	u8 value = ((u8)(rng->buffer));
	rng->buffer >>= 8U;
	return value;
}
inline u16 rand__wyrand__WyRandRNG_u16(rand__wyrand__WyRandRNG* rng) {
	if (rng->bytes_left >= 2) {
		rng->bytes_left -= 2;
		u16 value = ((u16)(rng->buffer));
		rng->buffer >>= 16U;
		return value;
	}
	u64 ans = rand__wyrand__WyRandRNG_u64(rng);
	rng->buffer = (ans >> 16U);
	rng->bytes_left = 6;
	return ((u16)(ans));
}
inline u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng) {
	if (rng->bytes_left >= 4) {
		rng->bytes_left -= 4;
		u32 value = ((u32)(rng->buffer));
		rng->buffer >>= 32U;
		return value;
	}
	u64 ans = rand__wyrand__WyRandRNG_u64(rng);
	rng->buffer = (ans >> 32U);
	rng->bytes_left = 4;
	return ((u32)(ans));
}
inline u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng) {
	{ // Unsafe block
		u64 seed1 = rng->state;
		seed1 += _const_rand__wyrand__wyp0;
		rng->state = seed1;
		return hash__wymum((seed1 ^ _const_rand__wyrand__wyp1), seed1);
	}
	return 0U;
}
inline int rand__wyrand__WyRandRNG_block_size(rand__wyrand__WyRandRNG* rng) {
	return 64;
}
void rand__wyrand__WyRandRNG_free(rand__wyrand__WyRandRNG* rng) {
	_v_free(rng);
}
VV_LOCAL_SYMBOL db__sqlite__DB sql_db__connect(void) {
	_result_db__sqlite__DB _t1 = db__sqlite__connect(_SLIT("data.db"));
	if (_t1.is_error) {
		IError err = _t1.err;
		println(_SLIT("Error: sqlite\350\260\203\347\224\250\351\224\231\350\257\257"));
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 	db__sqlite__DB *db = HEAP(db__sqlite__DB, ((*(db__sqlite__DB*)_t1.data)));
	_result_void _t2 = db__sqlite__DB_synchronization_mode(&(*(db)), db__sqlite__SyncMode__off);
	if (_t2.is_error) {
		IError err = _t2.err;
		println(_SLIT("Error: data.db\346\216\247\345\210\266\345\220\214\346\255\245\350\256\276\347\275\256\345\244\261\350\264\245"));
	;
	}
	
 ;
	_result_void _t3 = db__sqlite__DB_journal_mode(&(*(db)), db__sqlite__JournalMode__memory);
	if (_t3.is_error) {
		IError err = _t3.err;
		println(_SLIT("Error: data.db\346\227\245\345\277\227\346\250\241\345\274\217\350\256\276\347\275\256\345\244\261\350\264\245"));
	;
	}
	
 ;
	return (*(db));
}
_option_db__sqlite__DB sql_db__connect_db(bool set_nohup, string args) {
	if (!os__exists(_SLIT("data.db"))) {
		string id = os__input(_SLIT("Root id: "));
		string email = os__input(_SLIT("Root email: "));
		_result_string _t1 = os__input_password(_SLIT("Root password: "));
		if (_t1.is_error) {
			IError err = _t1.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 		string passwd = (*(string*)_t1.data);
		db__sqlite__DB *db = HEAP(db__sqlite__DB, (sql_db__connect()));
		sql_db__create_db((*(db)));
		sql_db__Personal root_number = ((sql_db__Personal){.pid = 0,.id = encoding__base64__url_encode_str(id),.email = encoding__base64__url_encode_str(email),.passwd = err_log__sha256_str(passwd),.whoami = _SLIT("root"),.challenge = __new_array_with_default(0, 0, sizeof(sql_db__PersonalFlag), 0),});
		// ORM
		orm__Connection _t2 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
		Array_orm__Primitive _t4 = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0);
		// sql { insert into `personal` }
		_result_void _t3 = orm__Connection_name_table[_t2._typ]._method_insert(
			_t2._object, // Connection object
			_SLIT("personal"),
			(orm__QueryData){
				.fields = new_array_from_c_array(5, 5, sizeof(string),
					_MOV((string[5]){ 
						_SLIT("pid"),
						_SLIT("id"),
						_SLIT("email"),
						_SLIT("passwd"),
						_SLIT("whoami"),
					})
				),
				.data = new_array_from_c_array(5, 5, sizeof(orm__Primitive),
					_MOV((orm__Primitive[5]){
						orm__int_to_primitive(root_number.pid),
						orm__string_to_primitive(root_number.id),
						orm__string_to_primitive(root_number.email),
						orm__string_to_primitive(root_number.passwd),
						orm__string_to_primitive(root_number.whoami),
					})
				),
				.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
				.auto_fields = new_array_from_c_array(1, 1, sizeof(int),
					_MOV((int[1]){ 0, })),
				.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
				.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			}
		);
		;
		if (_t3.is_error) {
			IError err = _t3.err;
			println(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT(": \346\227\240\346\263\225\346\263\250\345\206\214root\347\224\250\346\210\267, \350\257\267\351\207\215\350\257\225."), 0, { .d_c = 0 }}})));
			_result_void _t5 = os__rm(_SLIT("data.db"));
			if (_t5.is_error) {
				IError err = _t5.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
 ;
			_v_exit(1);
			VUNREACHABLE();
		;
		}
		orm__Primitive _t6 = orm__int_to_primitive(orm__Connection_name_table[_t2._typ]._method_last_id(_t2._object));
		for (int _t7 = 0; _t7 < root_number.challenge.len; _t7++) {
			sql_db__PersonalFlag _t10 = (*(sql_db__PersonalFlag*)array_get(root_number.challenge, _t7));
			// sql { insert into `personal_flag` }
			_result_void _t9 = orm__Connection_name_table[_t2._typ]._method_insert(
				_t2._object, // Connection object
				_SLIT("personal_flag"),
				(orm__QueryData){
					.fields = new_array_from_c_array(3, 3, sizeof(string),
						_MOV((string[3]){ 
							_SLIT("parents_id"),
							_SLIT("parents_challenge"),
							_SLIT("complete"),
						})
					),
					.data = new_array_from_c_array(3, 3, sizeof(orm__Primitive),
						_MOV((orm__Primitive[3]){
							_t6, 
							orm__int_to_primitive(_t10.parents_challenge),
							orm__string_to_primitive(_t10.complete),
						})
					),
					.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
					.auto_fields = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
					.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
					.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
				}
			);
			;
			if (_t9.is_error) {
				IError err = _t9.err;
				println(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT(": \346\227\240\346\263\225\346\263\250\345\206\214root\347\224\250\346\210\267, \350\257\267\351\207\215\350\257\225."), 0, { .d_c = 0 }}})));
				_result_void _t11 = os__rm(_SLIT("data.db"));
				if (_t11.is_error) {
					IError err = _t11.err;
					_v_panic(IError_str(err));
					VUNREACHABLE();
				;
				}
				
 ;
				_v_exit(1);
				VUNREACHABLE();
			;
			}
			;
			if (_t9.is_error) {
				IError err = _t9.err;
				println(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT(": \346\227\240\346\263\225\346\263\250\345\206\214root\347\224\250\346\210\267, \350\257\267\351\207\215\350\257\225."), 0, { .d_c = 0 }}})));
				_result_void _t12 = os__rm(_SLIT("data.db"));
				if (_t12.is_error) {
					IError err = _t12.err;
					_v_panic(IError_str(err));
					VUNREACHABLE();
				;
				}
				
 ;
				_v_exit(1);
				VUNREACHABLE();
			;
			}
		}
		;
		if (_t3.is_error) {
			IError err = _t3.err;
			println(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT(": \346\227\240\346\263\225\346\263\250\345\206\214root\347\224\250\346\210\267, \350\257\267\351\207\215\350\257\225."), 0, { .d_c = 0 }}})));
			_result_void _t13 = os__rm(_SLIT("data.db"));
			if (_t13.is_error) {
				IError err = _t13.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
 ;
			_v_exit(1);
			VUNREACHABLE();
		;
		}
		_option_db__sqlite__DB _t14;
		_option_ok(&(db__sqlite__DB[]) { (*(db)) }, (_option*)(&_t14), sizeof(db__sqlite__DB));
		return _t14;
	}
	if (os__exists(_SLIT("start"))) {
		_result_void _t15 = os__rm(_SLIT("start"));
		if (_t15.is_error) {
			IError err = _t15.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
		#if defined(_WIN32)
		{
		}
		#else
		{
			if (set_nohup) {
				os__system(str_intp(2, _MOV((StrIntpData[]){{_SLIT("./main "), 0xfe10, {.d_s = args}}, {_SLIT0, 0, { .d_c = 0 }}})));
				_v_exit(1);
				VUNREACHABLE();
			} else {
				os__system(str_intp(2, _MOV((StrIntpData[]){{_SLIT("./main "), 0xfe10, {.d_s = args}}, {_SLIT0, 0, { .d_c = 0 }}})));
				println(_SLIT("neko"));
				_v_exit(1);
				VUNREACHABLE();
			}
		}
		#endif
		println(_SLIT("test"));
	} else {
		_result_void _t17 = os__write_file(_SLIT("start"), _SLIT(""));
		if (_t17.is_error) {
			IError err = _t17.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
	}
	_option_db__sqlite__DB _t18;
	_option_ok(&(db__sqlite__DB[]) { sql_db__connect() }, (_option*)(&_t18), sizeof(db__sqlite__DB));
	return _t18;
}
Array_sql_db__Personal sql_db__get_personal(db__sqlite__DB _v_toheap_db) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Personal _t2;
	// sql { select from `personal` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("personal"),
			.is_count = false,
			.has_where = false,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("pid"),
			.fields = new_array_from_c_array(5, 5, sizeof(string),
				_MOV((string[5]){
					_SLIT("pid"),
					_SLIT("id"),
					_SLIT("email"),
					_SLIT("passwd"),
					_SLIT("whoami"),
				})
			),
			.types = new_array_from_c_array(5, 5, sizeof(int),
				_MOV((int[5]){ 8, 21, 21, 21, 21, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0)
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Personal*) _t2.data = __new_array_with_default(0, 0, sizeof(sql_db__Personal), 0);
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Personal _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Personal));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Personal _t5 = (sql_db__Personal) {.pid = 0, .id = (string){.str=(byteptr)"", .is_lit=1}, .email = (string){.str=(byteptr)"", .is_lit=1}, .passwd = (string){.str=(byteptr)"", .is_lit=1}, .whoami = (string){.str=(byteptr)"", .is_lit=1}, .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag))};
			if (_t4.len > 0) {
				_t5.pid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_t5.email = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.passwd = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.whoami = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_result_Array_sql_db__PersonalFlag _t7;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_id"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.pid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PersonalFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PersonalFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PersonalFlag _t10 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._int);
							_t10.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 2))._string);
							array_push(&_t10_array, _MOV((sql_db__PersonalFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t7.data;
				}
				array_push(&_t5_array, _MOV((sql_db__Personal[]){ _t5 }));
			}
		}
		*(Array_sql_db__Personal*) _t2.data = _t5_array;
	}
		Array_sql_db__Personal data =  *(Array_sql_db__Personal*)_t2.data;
	return data;
}
Array_sql_db__Task sql_db__find_challenge(db__sqlite__DB _v_toheap_db) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Task _t2;
	// sql { select from `challenge` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("challenge"),
			.is_count = false,
			.has_where = false,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("tid"),
			.fields = new_array_from_c_array(8, 8, sizeof(string),
				_MOV((string[8]){
					_SLIT("tid"),
					_SLIT("type_text"),
					_SLIT("name"),
					_SLIT("diff"),
					_SLIT("intro"),
					_SLIT("max_score"),
					_SLIT("score"),
					_SLIT("container"),
				})
			),
			.types = new_array_from_c_array(8, 8, sizeof(int),
				_MOV((int[8]){ 8, 21, 21, 21, 21, 8, 8, 19, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0)
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Task*) _t2.data = __new_array_with_default(0, 0, sizeof(sql_db__Task), 0);
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Task _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Task));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Task _t5 = (sql_db__Task) {.tid = 0, .type_text = (string){.str=(byteptr)"", .is_lit=1}, .flag = __new_array(0, 0, sizeof(sql_db__PostFlag)), .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag)), .name = (string){.str=(byteptr)"", .is_lit=1}, .diff = (string){.str=(byteptr)"", .is_lit=1}, .intro = (string){.str=(byteptr)"", .is_lit=1}, .max_score = 0, .score = 0, .container = 0};
			if (_t4.len > 0) {
				_t5.tid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.type_text = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_result_Array_sql_db__PostFlag _t7;
				// sql { select from `post_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("post_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(2, 2, sizeof(string),
							_MOV((string[2]){
								_SLIT("parents_challenge"),
								_SLIT("flag"),
							})
						),
						.types = new_array_from_c_array(2, 2, sizeof(int),
							_MOV((int[2]){ 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PostFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PostFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PostFlag _t10 = (sql_db__PostFlag) {.parents_challenge = 0, .flag = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.flag = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._string);
							array_push(&_t10_array, _MOV((sql_db__PostFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PostFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.flag = *(Array_sql_db__PostFlag*)_t7.data;
				}
				_result_Array_sql_db__PersonalFlag _t12;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t13 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t12.is_error = _t13.is_error;
				_t12.err = _t13.err;
				;
				if (_t12.is_error) {
				}
				if (!_t12.is_error) {
					Array_Array_orm__Primitive _t14 = (*(Array_Array_orm__Primitive*)_t13.data);
					int _t16 = 0;
					Array_sql_db__PersonalFlag _t15_array = __new_array(0, _t14.len, sizeof(sql_db__PersonalFlag));
					for (; _t16 < _t14.len; _t16++) {
						sql_db__PersonalFlag _t15 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t14.len > 0) {
							_t15.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 0))._int);
							_t15.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 1))._int);
							_t15.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 2))._string);
							array_push(&_t15_array, _MOV((sql_db__PersonalFlag[]){ _t15 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t12.data = _t15_array;
				}
				;
				if (!_t12.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t12.data;
				}
				_t5.name = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.diff = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.intro = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_t5.max_score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 5))._int);
				_t5.score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 6))._int);
				_t5.container = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 7))._bool);
				array_push(&_t5_array, _MOV((sql_db__Task[]){ _t5 }));
			}
		}
		*(Array_sql_db__Task*) _t2.data = _t5_array;
	}
		Array_sql_db__Task data =  *(Array_sql_db__Task*)_t2.data;
	return data;
}
bool sql_db__bool_solve(sql_db__PersonalFlag pf) {
	if (fast_string_eq(pf.complete, _SLIT("../image/complete.webp"))) {
		return true;
	} else {
		return false;
	}
	return 0;
}
int sql_db__challenge_score(db__sqlite__DB _v_toheap_db, sql_db__PersonalFlag pf) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Task _t2;
	// sql { select from `challenge` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("challenge"),
			.is_count = false,
			.has_where = true,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("tid"),
			.fields = new_array_from_c_array(8, 8, sizeof(string),
				_MOV((string[8]){
					_SLIT("tid"),
					_SLIT("type_text"),
					_SLIT("name"),
					_SLIT("diff"),
					_SLIT("intro"),
					_SLIT("max_score"),
					_SLIT("score"),
					_SLIT("container"),
				})
			),
			.types = new_array_from_c_array(8, 8, sizeof(int),
				_MOV((int[8]){ 8, 21, 21, 21, 21, 8, 8, 19, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		// ORM where
		(orm__QueryData){
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.fields = new_array_from_c_array(1, 1, sizeof(string),
				_MOV((string[1]){
					_SLIT("tid"),
				})
			),
			.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
				_MOV((orm__Primitive[1]){
					orm__int_to_primitive(pf.parents_challenge),
				})
			),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
				_MOV((orm__OperationKind[1]){
					orm__OperationKind__eq,
				})
			),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		return 0;
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t5 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t7 = 0;
		Array_sql_db__Task _t6_array = __new_array(0, _t5.len, sizeof(sql_db__Task));
		for (; _t7 < _t5.len; _t7++) {
			sql_db__Task _t6 = (sql_db__Task) {.tid = 0, .type_text = (string){.str=(byteptr)"", .is_lit=1}, .flag = __new_array(0, 0, sizeof(sql_db__PostFlag)), .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag)), .name = (string){.str=(byteptr)"", .is_lit=1}, .diff = (string){.str=(byteptr)"", .is_lit=1}, .intro = (string){.str=(byteptr)"", .is_lit=1}, .max_score = 0, .score = 0, .container = 0};
			if (_t5.len > 0) {
				_t6.tid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 0))._int);
				_t6.type_text = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 1))._string);
				_result_Array_sql_db__PostFlag _t8;
				// sql { select from `post_flag` }
				_result_Array_Array_orm__Primitive _t9 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("post_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(2, 2, sizeof(string),
							_MOV((string[2]){
								_SLIT("parents_challenge"),
								_SLIT("flag"),
							})
						),
						.types = new_array_from_c_array(2, 2, sizeof(int),
							_MOV((int[2]){ 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t6.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t8.is_error = _t9.is_error;
				_t8.err = _t9.err;
				;
				if (_t8.is_error) {
				}
				if (!_t8.is_error) {
					Array_Array_orm__Primitive _t10 = (*(Array_Array_orm__Primitive*)_t9.data);
					int _t12 = 0;
					Array_sql_db__PostFlag _t11_array = __new_array(0, _t10.len, sizeof(sql_db__PostFlag));
					for (; _t12 < _t10.len; _t12++) {
						sql_db__PostFlag _t11 = (sql_db__PostFlag) {.parents_challenge = 0, .flag = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t10.len > 0) {
							_t11.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t10, _t12)), 0))._int);
							_t11.flag = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t10, _t12)), 1))._string);
							array_push(&_t11_array, _MOV((sql_db__PostFlag[]){ _t11 }));
						}
					}
					*(Array_sql_db__PostFlag*) _t8.data = _t11_array;
				}
				;
				if (!_t8.is_error) {
					_t6.flag = *(Array_sql_db__PostFlag*)_t8.data;
				}
				_result_Array_sql_db__PersonalFlag _t13;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t14 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t6.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t13.is_error = _t14.is_error;
				_t13.err = _t14.err;
				;
				if (_t13.is_error) {
				}
				if (!_t13.is_error) {
					Array_Array_orm__Primitive _t15 = (*(Array_Array_orm__Primitive*)_t14.data);
					int _t17 = 0;
					Array_sql_db__PersonalFlag _t16_array = __new_array(0, _t15.len, sizeof(sql_db__PersonalFlag));
					for (; _t17 < _t15.len; _t17++) {
						sql_db__PersonalFlag _t16 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t15.len > 0) {
							_t16.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t15, _t17)), 0))._int);
							_t16.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t15, _t17)), 1))._int);
							_t16.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t15, _t17)), 2))._string);
							array_push(&_t16_array, _MOV((sql_db__PersonalFlag[]){ _t16 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t13.data = _t16_array;
				}
				;
				if (!_t13.is_error) {
					_t6.challenge = *(Array_sql_db__PersonalFlag*)_t13.data;
				}
				_t6.name = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 2))._string);
				_t6.diff = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 3))._string);
				_t6.intro = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 4))._string);
				_t6.max_score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 5))._int);
				_t6.score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 6))._int);
				_t6.container = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 7))._bool);
				array_push(&_t6_array, _MOV((sql_db__Task[]){ _t6 }));
			}
		}
		*(Array_sql_db__Task*) _t2.data = _t6_array;
	}
		Array_sql_db__Task data =  *(Array_sql_db__Task*)_t2.data;
	return (*(sql_db__Task*)array_first(data)).score;
}
VV_LOCAL_SYMBOL void sql_db__create_db(db__sqlite__DB _v_toheap_db) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	// sql { create table `personal` }
	_result_void _t2 = orm__Connection_name_table[_t1._typ]._method_create(
		_t1._object, // Connection object
		_SLIT("personal"),
		new_array_from_c_array(6, 6, sizeof(orm__TableField),
			_MOV((orm__TableField[6]){
				// `personal`.`pid`
				(orm__TableField){
					.name = _SLIT("pid"),
					.typ = 8, // `int`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(2, 2, sizeof(VAttribute),
						_MOV((VAttribute[2]){(VAttribute){ .name = _SLIT("primary"), .has_arg = false, .arg = _SLIT(""), .kind = 0,},(VAttribute){ .name = _SLIT("sql"), .has_arg = true, .arg = _SLIT("serial"), .kind = 0,},})
					)
				},
				// `personal`.`id`
				(orm__TableField){
					.name = _SLIT("id"),
					.typ = 21, // `string`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `personal`.`email`
				(orm__TableField){
					.name = _SLIT("email"),
					.typ = 21, // `string`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `personal`.`passwd`
				(orm__TableField){
					.name = _SLIT("passwd"),
					.typ = 21, // `string`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `personal`.`whoami`
				(orm__TableField){
					.name = _SLIT("whoami"),
					.typ = 21, // `string`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `personal`.`challenge`
				(orm__TableField){
					.name = _SLIT("challenge"),
					.typ = 253, // `[]sql_db.PersonalFlag`
					.is_arr = true, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(1, 1, sizeof(VAttribute),
						_MOV((VAttribute[1]){(VAttribute){ .name = _SLIT("fkey"), .has_arg = true, .arg = _SLIT("parents_id"), .kind = 1,},})
					)
				},
			})
		)
	);
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		println(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__warn_log}}, {_SLIT(": \346\225\260\346\215\256\345\272\223\345\210\233\345\273\272\345\244\261\350\264\245, \345\217\257\350\203\275\345\267\262\345\255\230\345\234\250\346\225\260\346\215\256\345\272\223: data.db"), 0, { .d_c = 0 }}})));
	;
	}
	// sql { create table `challenge` }
	_result_void _t3 = orm__Connection_name_table[_t1._typ]._method_create(
		_t1._object, // Connection object
		_SLIT("challenge"),
		new_array_from_c_array(10, 10, sizeof(orm__TableField),
			_MOV((orm__TableField[10]){
				// `challenge`.`tid`
				(orm__TableField){
					.name = _SLIT("tid"),
					.typ = 8, // `int`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(2, 2, sizeof(VAttribute),
						_MOV((VAttribute[2]){(VAttribute){ .name = _SLIT("primary"), .has_arg = false, .arg = _SLIT(""), .kind = 0,},(VAttribute){ .name = _SLIT("sql"), .has_arg = true, .arg = _SLIT("serial"), .kind = 0,},})
					)
				},
				// `challenge`.`type_text`
				(orm__TableField){
					.name = _SLIT("type_text"),
					.typ = 21, // `string`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `challenge`.`flag`
				(orm__TableField){
					.name = _SLIT("flag"),
					.typ = 258, // `[]sql_db.PostFlag`
					.is_arr = true, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(1, 1, sizeof(VAttribute),
						_MOV((VAttribute[1]){(VAttribute){ .name = _SLIT("fkey"), .has_arg = true, .arg = _SLIT("parents_challenge"), .kind = 1,},})
					)
				},
				// `challenge`.`challenge`
				(orm__TableField){
					.name = _SLIT("challenge"),
					.typ = 253, // `[]sql_db.PersonalFlag`
					.is_arr = true, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(1, 1, sizeof(VAttribute),
						_MOV((VAttribute[1]){(VAttribute){ .name = _SLIT("fkey"), .has_arg = true, .arg = _SLIT("parents_challenge"), .kind = 1,},})
					)
				},
				// `challenge`.`name`
				(orm__TableField){
					.name = _SLIT("name"),
					.typ = 21, // `string`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `challenge`.`diff`
				(orm__TableField){
					.name = _SLIT("diff"),
					.typ = 21, // `string`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `challenge`.`intro`
				(orm__TableField){
					.name = _SLIT("intro"),
					.typ = 21, // `string`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `challenge`.`max_score`
				(orm__TableField){
					.name = _SLIT("max_score"),
					.typ = 8, // `int`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `challenge`.`score`
				(orm__TableField){
					.name = _SLIT("score"),
					.typ = 8, // `int`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `challenge`.`container`
				(orm__TableField){
					.name = _SLIT("container"),
					.typ = 19, // `bool`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
			})
		)
	);
	;
	if (_t3.is_error) {
		IError err = _t3.err;
		println(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__warn_log}}, {_SLIT(": \346\225\260\346\215\256\345\272\223\345\210\233\345\273\272\345\244\261\350\264\245, \345\217\257\350\203\275\345\267\262\345\255\230\345\234\250\346\225\260\346\215\256\345\272\223: data.db"), 0, { .d_c = 0 }}})));
	;
	}
	// sql { create table `post_flag` }
	_result_void _t4 = orm__Connection_name_table[_t1._typ]._method_create(
		_t1._object, // Connection object
		_SLIT("post_flag"),
		new_array_from_c_array(2, 2, sizeof(orm__TableField),
			_MOV((orm__TableField[2]){
				// `post_flag`.`parents_challenge`
				(orm__TableField){
					.name = _SLIT("parents_challenge"),
					.typ = 8, // `int`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `post_flag`.`flag`
				(orm__TableField){
					.name = _SLIT("flag"),
					.typ = 21, // `string`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
			})
		)
	);
	;
	if (_t4.is_error) {
		IError err = _t4.err;
		println(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__warn_log}}, {_SLIT(": \346\225\260\346\215\256\345\272\223\345\210\233\345\273\272\345\244\261\350\264\245, \345\217\257\350\203\275\345\267\262\345\255\230\345\234\250\346\225\260\346\215\256\345\272\223: data.db"), 0, { .d_c = 0 }}})));
	;
	}
	// sql { create table `personal_flag` }
	_result_void _t5 = orm__Connection_name_table[_t1._typ]._method_create(
		_t1._object, // Connection object
		_SLIT("personal_flag"),
		new_array_from_c_array(3, 3, sizeof(orm__TableField),
			_MOV((orm__TableField[3]){
				// `personal_flag`.`parents_id`
				(orm__TableField){
					.name = _SLIT("parents_id"),
					.typ = 8, // `int`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `personal_flag`.`parents_challenge`
				(orm__TableField){
					.name = _SLIT("parents_challenge"),
					.typ = 8, // `int`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
				// `personal_flag`.`complete`
				(orm__TableField){
					.name = _SLIT("complete"),
					.typ = 21, // `string`
					.is_arr = false, 
					.nullable = false,
					.default_val = (string){ .str = (byteptr) "", .is_lit = 1 },
					.attrs = new_array_from_c_array(0, 0, sizeof(VAttribute),
						NULL // No attrs
					)
				},
			})
		)
	);
	;
	if (_t5.is_error) {
		IError err = _t5.err;
		println(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__warn_log}}, {_SLIT(": \346\225\260\346\215\256\345\272\223\345\210\233\345\273\272\345\244\261\350\264\245, \345\217\257\350\203\275\345\267\262\345\255\230\345\234\250\346\225\260\346\215\256\345\272\223: data.db"), 0, { .d_c = 0 }}})));
	;
	}
}
void sql_db__test_main_function(db__sqlite__DB* db) {

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = db, ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Task _t2;
	// sql { select from `challenge` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("challenge"),
			.is_count = false,
			.has_where = false,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("tid"),
			.fields = new_array_from_c_array(8, 8, sizeof(string),
				_MOV((string[8]){
					_SLIT("tid"),
					_SLIT("type_text"),
					_SLIT("name"),
					_SLIT("diff"),
					_SLIT("intro"),
					_SLIT("max_score"),
					_SLIT("score"),
					_SLIT("container"),
				})
			),
			.types = new_array_from_c_array(8, 8, sizeof(int),
				_MOV((int[8]){ 8, 21, 21, 21, 21, 8, 8, 19, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0)
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Task*) _t2.data = __new_array_with_default(0, 0, sizeof(sql_db__Task), 0);
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Task _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Task));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Task _t5 = (sql_db__Task) {.tid = 0, .type_text = (string){.str=(byteptr)"", .is_lit=1}, .flag = __new_array(0, 0, sizeof(sql_db__PostFlag)), .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag)), .name = (string){.str=(byteptr)"", .is_lit=1}, .diff = (string){.str=(byteptr)"", .is_lit=1}, .intro = (string){.str=(byteptr)"", .is_lit=1}, .max_score = 0, .score = 0, .container = 0};
			if (_t4.len > 0) {
				_t5.tid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.type_text = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_result_Array_sql_db__PostFlag _t7;
				// sql { select from `post_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("post_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(2, 2, sizeof(string),
							_MOV((string[2]){
								_SLIT("parents_challenge"),
								_SLIT("flag"),
							})
						),
						.types = new_array_from_c_array(2, 2, sizeof(int),
							_MOV((int[2]){ 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PostFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PostFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PostFlag _t10 = (sql_db__PostFlag) {.parents_challenge = 0, .flag = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.flag = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._string);
							array_push(&_t10_array, _MOV((sql_db__PostFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PostFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.flag = *(Array_sql_db__PostFlag*)_t7.data;
				}
				_result_Array_sql_db__PersonalFlag _t12;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t13 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t12.is_error = _t13.is_error;
				_t12.err = _t13.err;
				;
				if (_t12.is_error) {
				}
				if (!_t12.is_error) {
					Array_Array_orm__Primitive _t14 = (*(Array_Array_orm__Primitive*)_t13.data);
					int _t16 = 0;
					Array_sql_db__PersonalFlag _t15_array = __new_array(0, _t14.len, sizeof(sql_db__PersonalFlag));
					for (; _t16 < _t14.len; _t16++) {
						sql_db__PersonalFlag _t15 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t14.len > 0) {
							_t15.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 0))._int);
							_t15.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 1))._int);
							_t15.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 2))._string);
							array_push(&_t15_array, _MOV((sql_db__PersonalFlag[]){ _t15 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t12.data = _t15_array;
				}
				;
				if (!_t12.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t12.data;
				}
				_t5.name = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.diff = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.intro = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_t5.max_score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 5))._int);
				_t5.score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 6))._int);
				_t5.container = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 7))._bool);
				array_push(&_t5_array, _MOV((sql_db__Task[]){ _t5 }));
			}
		}
		*(Array_sql_db__Task*) _t2.data = _t5_array;
	}
		Array_sql_db__Task the_data =  *(Array_sql_db__Task*)_t2.data;
	if (the_data.len != 0) {
		return;
	}
	Array_sql_db__Task data = new_array_from_c_array(2, 2, sizeof(sql_db__Task), _MOV((sql_db__Task[2]){((sql_db__Task){
		.tid = 0,
		.type_text = _SLIT("Crypto"),
		.flag = new_array_from_c_array(1, 1, sizeof(sql_db__PostFlag), _MOV((sql_db__PostFlag[1]){((sql_db__PostFlag){.parents_challenge = 0,.flag = _SLIT("vyctf{adwa_is_the_best_crypto_player}"),})})),
		.challenge = __new_array_with_default(0, 0, sizeof(sql_db__PersonalFlag), 0),
		.name = _SLIT("fast_attack"),
		.diff = _SLIT("normal"),
		.intro = _SLIT("basectf\347\232\204\347\262\276\347\245\236\345\273\266\347\273\255\n\345\207\272\351\242\230\344\272\272:sudopacman\n\351\231\204\344\273\266:https://wwtk.lanzoum.com/i44iq2dppize\n\350\277\234\347\250\213\347\216\257\345\242\203:139.155.139.109:10000"),
		.max_score = 300,
		.score = 300,
		.container = false,
	}), ((sql_db__Task){
		.tid = 0,
		.type_text = _SLIT("Crypto"),
		.flag = new_array_from_c_array(1, 1, sizeof(sql_db__PostFlag), _MOV((sql_db__PostFlag[1]){((sql_db__PostFlag){.parents_challenge = 0,.flag = _SLIT("vyctf{0010011100000101010011100001101111110101011001000101011111101001}"),})})),
		.challenge = __new_array_with_default(0, 0, sizeof(sql_db__PersonalFlag), 0),
		.name = _SLIT("Pell Company's A-level products"),
		.diff = _SLIT("normal"),
		.intro = _SLIT("\346\210\221\346\203\263\346\213\277\345\256\203\346\235\245\345\201\232hash\n\345\207\272\351\242\230\344\272\272:adwa\n\351\231\204\344\273\266:https://wwtk.lanzoum.com/iNvgK2dpql9c"),
		.max_score = 300,
		.score = 300,
		.container = false,
	})}));
	for (int _t17 = 0; _t17 < data.len; ++_t17) {
		sql_db__Task i = ((sql_db__Task*)data.data)[_t17];
		// ORM
		orm__Connection _t18 = (orm__Connection){._db__sqlite__DB = db, ._typ = _orm__Connection_db__sqlite__DB_index};
		Array_orm__Primitive _t20 = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0);
		// sql { insert into `challenge` }
		_result_void _t19 = orm__Connection_name_table[_t18._typ]._method_insert(
			_t18._object, // Connection object
			_SLIT("challenge"),
			(orm__QueryData){
				.fields = new_array_from_c_array(8, 8, sizeof(string),
					_MOV((string[8]){ 
						_SLIT("tid"),
						_SLIT("type_text"),
						_SLIT("name"),
						_SLIT("diff"),
						_SLIT("intro"),
						_SLIT("max_score"),
						_SLIT("score"),
						_SLIT("container"),
					})
				),
				.data = new_array_from_c_array(8, 8, sizeof(orm__Primitive),
					_MOV((orm__Primitive[8]){
						orm__int_to_primitive(i.tid),
						orm__string_to_primitive(i.type_text),
						orm__string_to_primitive(i.name),
						orm__string_to_primitive(i.diff),
						orm__string_to_primitive(i.intro),
						orm__int_to_primitive(i.max_score),
						orm__int_to_primitive(i.score),
						orm__bool_to_primitive(i.container),
					})
				),
				.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
				.auto_fields = new_array_from_c_array(1, 1, sizeof(int),
					_MOV((int[1]){ 0, })),
				.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
				.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			}
		);
		;
		if (_t19.is_error) {
			IError err = _t19.err;
			println(_SLIT("Error: \345\255\230\345\202\250\346\225\260\346\215\256\345\207\272\351\224\231"));
		;
		}
		orm__Primitive _t21 = orm__int_to_primitive(orm__Connection_name_table[_t18._typ]._method_last_id(_t18._object));
		for (int _t22 = 0; _t22 < i.flag.len; _t22++) {
			sql_db__PostFlag _t25 = (*(sql_db__PostFlag*)array_get(i.flag, _t22));
			// sql { insert into `post_flag` }
			_result_void _t24 = orm__Connection_name_table[_t18._typ]._method_insert(
				_t18._object, // Connection object
				_SLIT("post_flag"),
				(orm__QueryData){
					.fields = new_array_from_c_array(2, 2, sizeof(string),
						_MOV((string[2]){ 
							_SLIT("parents_challenge"),
							_SLIT("flag"),
						})
					),
					.data = new_array_from_c_array(2, 2, sizeof(orm__Primitive),
						_MOV((orm__Primitive[2]){
							_t21, 
							orm__string_to_primitive(_t25.flag),
						})
					),
					.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
					.auto_fields = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
					.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
					.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
				}
			);
			;
			if (_t24.is_error) {
				IError err = _t24.err;
				println(_SLIT("Error: \345\255\230\345\202\250\346\225\260\346\215\256\345\207\272\351\224\231"));
			;
			}
			;
			if (_t24.is_error) {
				IError err = _t24.err;
				println(_SLIT("Error: \345\255\230\345\202\250\346\225\260\346\215\256\345\207\272\351\224\231"));
			;
			}
		}
		for (int _t26 = 0; _t26 < i.challenge.len; _t26++) {
			sql_db__PersonalFlag _t29 = (*(sql_db__PersonalFlag*)array_get(i.challenge, _t26));
			// sql { insert into `personal_flag` }
			_result_void _t28 = orm__Connection_name_table[_t18._typ]._method_insert(
				_t18._object, // Connection object
				_SLIT("personal_flag"),
				(orm__QueryData){
					.fields = new_array_from_c_array(3, 3, sizeof(string),
						_MOV((string[3]){ 
							_SLIT("parents_id"),
							_SLIT("parents_challenge"),
							_SLIT("complete"),
						})
					),
					.data = new_array_from_c_array(3, 3, sizeof(orm__Primitive),
						_MOV((orm__Primitive[3]){
							orm__int_to_primitive(_t29.parents_id),
							_t21, 
							orm__string_to_primitive(_t29.complete),
						})
					),
					.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
					.auto_fields = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
					.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
					.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
				}
			);
			;
			if (_t28.is_error) {
				IError err = _t28.err;
				println(_SLIT("Error: \345\255\230\345\202\250\346\225\260\346\215\256\345\207\272\351\224\231"));
			;
			}
			;
			if (_t28.is_error) {
				IError err = _t28.err;
				println(_SLIT("Error: \345\255\230\345\202\250\346\225\260\346\215\256\345\207\272\351\224\231"));
			;
			}
		}
		;
		if (_t19.is_error) {
			IError err = _t19.err;
			println(_SLIT("Error: \345\255\230\345\202\250\346\225\260\346\215\256\345\207\272\351\224\231"));
		;
		}
	}
}
VV_LOCAL_SYMBOL Array_sql_db__Personal sql_db__personal_err(void) {
	println(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT("\346\237\245\350\257\242\351\224\231\350\257\257"), 0, { .d_c = 0 }}})));
	return __new_array_with_default(0, 0, sizeof(sql_db__Personal), 0);
}
sql_db__StatusReturn sql_db__login_status(db__sqlite__DB _v_toheap_db, string c_id, string c_pwd) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Personal _t2;
	// sql { select from `personal` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("personal"),
			.is_count = false,
			.has_where = true,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("pid"),
			.fields = new_array_from_c_array(5, 5, sizeof(string),
				_MOV((string[5]){
					_SLIT("pid"),
					_SLIT("id"),
					_SLIT("email"),
					_SLIT("passwd"),
					_SLIT("whoami"),
				})
			),
			.types = new_array_from_c_array(5, 5, sizeof(int),
				_MOV((int[5]){ 8, 21, 21, 21, 21, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		// ORM where
		(orm__QueryData){
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.fields = new_array_from_c_array(2, 2, sizeof(string),
				_MOV((string[2]){
					_SLIT("id"),
					_SLIT("passwd"),
				})
			),
			.data = new_array_from_c_array(2, 2, sizeof(orm__Primitive),
				_MOV((orm__Primitive[2]){
					orm__string_to_primitive(encoding__base64__url_encode_str(c_id)),
					orm__string_to_primitive(err_log__sha256_str(c_pwd)),
				})
			),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.kinds = new_array_from_c_array(2, 2, sizeof(orm__OperationKind),
				_MOV((orm__OperationKind[2]){
					orm__OperationKind__eq,
					orm__OperationKind__eq,
				})
			),
			.is_and = new_array_from_c_array(1, 1, sizeof(bool),_MOV((bool[1]){
					true,
				})),
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Personal*) _t2.data = sql_db__personal_err();
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Personal _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Personal));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Personal _t5 = (sql_db__Personal) {.pid = 0, .id = (string){.str=(byteptr)"", .is_lit=1}, .email = (string){.str=(byteptr)"", .is_lit=1}, .passwd = (string){.str=(byteptr)"", .is_lit=1}, .whoami = (string){.str=(byteptr)"", .is_lit=1}, .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag))};
			if (_t4.len > 0) {
				_t5.pid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_t5.email = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.passwd = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.whoami = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_result_Array_sql_db__PersonalFlag _t7;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_id"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.pid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PersonalFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PersonalFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PersonalFlag _t10 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._int);
							_t10.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 2))._string);
							array_push(&_t10_array, _MOV((sql_db__PersonalFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t7.data;
				}
				array_push(&_t5_array, _MOV((sql_db__Personal[]){ _t5 }));
			}
		}
		*(Array_sql_db__Personal*) _t2.data = _t5_array;
	}
		Array_sql_db__Personal id_check =  *(Array_sql_db__Personal*)_t2.data;
	if (id_check.len != 0 && true) {
		return ((sql_db__StatusReturn){.return_bool = true,.find_passwd = false,.id_check = id_check,});
	} else {
		return ((sql_db__StatusReturn){.return_bool = false,.find_passwd = false,.id_check = id_check,});
	}
	return (sql_db__StatusReturn){.return_bool = 0,.find_passwd = 0,.id_check = __new_array(0, 0, sizeof(sql_db__Personal)),};
}
sql_db__StatusReturn sql_db__login_root_status(db__sqlite__DB _v_toheap_db, string c_id, string c_pwd) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Personal _t2;
	// sql { select from `personal` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("personal"),
			.is_count = false,
			.has_where = true,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("pid"),
			.fields = new_array_from_c_array(5, 5, sizeof(string),
				_MOV((string[5]){
					_SLIT("pid"),
					_SLIT("id"),
					_SLIT("email"),
					_SLIT("passwd"),
					_SLIT("whoami"),
				})
			),
			.types = new_array_from_c_array(5, 5, sizeof(int),
				_MOV((int[5]){ 8, 21, 21, 21, 21, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		// ORM where
		(orm__QueryData){
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.fields = new_array_from_c_array(3, 3, sizeof(string),
				_MOV((string[3]){
					_SLIT("id"),
					_SLIT("passwd"),
					_SLIT("whoami"),
				})
			),
			.data = new_array_from_c_array(3, 3, sizeof(orm__Primitive),
				_MOV((orm__Primitive[3]){
					orm__string_to_primitive(encoding__base64__url_encode_str(c_id)),
					orm__string_to_primitive(err_log__sha256_str(c_pwd)),
					orm__string_to_primitive(_SLIT("member")),
				})
			),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.kinds = new_array_from_c_array(3, 3, sizeof(orm__OperationKind),
				_MOV((orm__OperationKind[3]){
					orm__OperationKind__eq,
					orm__OperationKind__eq,
					orm__OperationKind__neq,
				})
			),
			.is_and = new_array_from_c_array(2, 2, sizeof(bool),_MOV((bool[2]){
					true,
					true,
				})),
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Personal*) _t2.data = sql_db__personal_err();
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Personal _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Personal));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Personal _t5 = (sql_db__Personal) {.pid = 0, .id = (string){.str=(byteptr)"", .is_lit=1}, .email = (string){.str=(byteptr)"", .is_lit=1}, .passwd = (string){.str=(byteptr)"", .is_lit=1}, .whoami = (string){.str=(byteptr)"", .is_lit=1}, .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag))};
			if (_t4.len > 0) {
				_t5.pid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_t5.email = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.passwd = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.whoami = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_result_Array_sql_db__PersonalFlag _t7;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_id"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.pid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PersonalFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PersonalFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PersonalFlag _t10 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._int);
							_t10.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 2))._string);
							array_push(&_t10_array, _MOV((sql_db__PersonalFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t7.data;
				}
				array_push(&_t5_array, _MOV((sql_db__Personal[]){ _t5 }));
			}
		}
		*(Array_sql_db__Personal*) _t2.data = _t5_array;
	}
		Array_sql_db__Personal id_check =  *(Array_sql_db__Personal*)_t2.data;
	if (id_check.len != 0 && true) {
		return ((sql_db__StatusReturn){.return_bool = true,.find_passwd = false,.id_check = id_check,});
	} else {
		return ((sql_db__StatusReturn){.return_bool = false,.find_passwd = false,.id_check = id_check,});
	}
	return (sql_db__StatusReturn){.return_bool = 0,.find_passwd = 0,.id_check = __new_array(0, 0, sizeof(sql_db__Personal)),};
}
sql_db__StatusReturn sql_db__select_passwd_db(db__sqlite__DB _v_toheap_db, string ip, string email, string passwd) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	err_log__logs(str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__set_log}}, {_SLIT(": ip:"), 0xfe10, {.d_s = ip}}, {_SLIT(" email/id:"), 0xfe10, {.d_s = email}}, {_SLIT(" password:"), 0xfe10, {.d_s = passwd}}, {_SLIT(" \346\255\243\345\234\250\347\231\273\345\275\225."), 0, { .d_c = 0 }}})));

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Personal _t2;
	// sql { select from `personal` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("personal"),
			.is_count = false,
			.has_where = true,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("pid"),
			.fields = new_array_from_c_array(5, 5, sizeof(string),
				_MOV((string[5]){
					_SLIT("pid"),
					_SLIT("id"),
					_SLIT("email"),
					_SLIT("passwd"),
					_SLIT("whoami"),
				})
			),
			.types = new_array_from_c_array(5, 5, sizeof(int),
				_MOV((int[5]){ 8, 21, 21, 21, 21, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		// ORM where
		(orm__QueryData){
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.fields = new_array_from_c_array(2, 2, sizeof(string),
				_MOV((string[2]){
					_SLIT("id"),
					_SLIT("email"),
				})
			),
			.data = new_array_from_c_array(2, 2, sizeof(orm__Primitive),
				_MOV((orm__Primitive[2]){
					orm__string_to_primitive(encoding__base64__url_encode_str(email)),
					orm__string_to_primitive(encoding__base64__url_encode_str(email)),
				})
			),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.kinds = new_array_from_c_array(2, 2, sizeof(orm__OperationKind),
				_MOV((orm__OperationKind[2]){
					orm__OperationKind__eq,
					orm__OperationKind__eq,
				})
			),
			.is_and = new_array_from_c_array(1, 1, sizeof(bool),_MOV((bool[1]){
					false,
				})),
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Personal*) _t2.data = sql_db__personal_err();
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Personal _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Personal));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Personal _t5 = (sql_db__Personal) {.pid = 0, .id = (string){.str=(byteptr)"", .is_lit=1}, .email = (string){.str=(byteptr)"", .is_lit=1}, .passwd = (string){.str=(byteptr)"", .is_lit=1}, .whoami = (string){.str=(byteptr)"", .is_lit=1}, .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag))};
			if (_t4.len > 0) {
				_t5.pid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_t5.email = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.passwd = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.whoami = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_result_Array_sql_db__PersonalFlag _t7;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_id"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.pid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PersonalFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PersonalFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PersonalFlag _t10 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._int);
							_t10.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 2))._string);
							array_push(&_t10_array, _MOV((sql_db__PersonalFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t7.data;
				}
				array_push(&_t5_array, _MOV((sql_db__Personal[]){ _t5 }));
			}
		}
		*(Array_sql_db__Personal*) _t2.data = _t5_array;
	}
		Array_sql_db__Personal id_check =  *(Array_sql_db__Personal*)_t2.data;
	if (id_check.len == 0) {
		return ((sql_db__StatusReturn){.return_bool = true,.find_passwd = false,.id_check = id_check,});
	}
	bool not_passwd = true;
	for (int _t13 = 0; _t13 < id_check.len; ++_t13) {
		sql_db__Personal i = ((sql_db__Personal*)id_check.data)[_t13];
		if (string__eq(i.passwd, err_log__sha256_str(passwd))) {
			not_passwd = false;
			err_log__logs(str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__true_log}}, {_SLIT(": ip:"), 0xfe10, {.d_s = ip}}, {_SLIT(" pid:"), 0xfe07, {.d_i32 = i.pid}}, {_SLIT(" is login."), 0, { .d_c = 0 }}})));
		}
	}
	return ((sql_db__StatusReturn){.return_bool = false,.find_passwd = not_passwd,.id_check = id_check,});
}
bool sql_db__register_status(db__sqlite__DB _v_toheap_db, string id, string email, string passwd) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	bool return_bool = false;
	sql_db__Personal new_number = ((sql_db__Personal){.pid = 0,.id = encoding__base64__url_encode_str(id),.email = encoding__base64__url_encode_str(email),.passwd = err_log__sha256_str(passwd),.whoami = _SLIT("member"),.challenge = __new_array_with_default(0, 0, sizeof(sql_db__PersonalFlag), 0),});

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Personal _t2;
	// sql { select from `personal` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("personal"),
			.is_count = false,
			.has_where = true,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("pid"),
			.fields = new_array_from_c_array(5, 5, sizeof(string),
				_MOV((string[5]){
					_SLIT("pid"),
					_SLIT("id"),
					_SLIT("email"),
					_SLIT("passwd"),
					_SLIT("whoami"),
				})
			),
			.types = new_array_from_c_array(5, 5, sizeof(int),
				_MOV((int[5]){ 8, 21, 21, 21, 21, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		// ORM where
		(orm__QueryData){
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.fields = new_array_from_c_array(2, 2, sizeof(string),
				_MOV((string[2]){
					_SLIT("id"),
					_SLIT("email"),
				})
			),
			.data = new_array_from_c_array(2, 2, sizeof(orm__Primitive),
				_MOV((orm__Primitive[2]){
					orm__string_to_primitive(new_number.id),
					orm__string_to_primitive(new_number.email),
				})
			),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.kinds = new_array_from_c_array(2, 2, sizeof(orm__OperationKind),
				_MOV((orm__OperationKind[2]){
					orm__OperationKind__eq,
					orm__OperationKind__eq,
				})
			),
			.is_and = new_array_from_c_array(1, 1, sizeof(bool),_MOV((bool[1]){
					false,
				})),
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Personal*) _t2.data = sql_db__personal_err();
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Personal _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Personal));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Personal _t5 = (sql_db__Personal) {.pid = 0, .id = (string){.str=(byteptr)"", .is_lit=1}, .email = (string){.str=(byteptr)"", .is_lit=1}, .passwd = (string){.str=(byteptr)"", .is_lit=1}, .whoami = (string){.str=(byteptr)"", .is_lit=1}, .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag))};
			if (_t4.len > 0) {
				_t5.pid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_t5.email = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.passwd = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.whoami = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_result_Array_sql_db__PersonalFlag _t7;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_id"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.pid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PersonalFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PersonalFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PersonalFlag _t10 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._int);
							_t10.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 2))._string);
							array_push(&_t10_array, _MOV((sql_db__PersonalFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t7.data;
				}
				array_push(&_t5_array, _MOV((sql_db__Personal[]){ _t5 }));
			}
		}
		*(Array_sql_db__Personal*) _t2.data = _t5_array;
	}
		Array_sql_db__Personal id_check =  *(Array_sql_db__Personal*)_t2.data;
	if (id_check.len != 0 || (new_number.id).len == 0) {
		println(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT(": \346\243\200\346\265\213\345\210\260\346\217\220\344\272\244\346\227\240\346\225\210\346\225\260\346\215\256"), 0, { .d_c = 0 }}})));
		return_bool = true;
	}
	return return_bool;
}
bool sql_db__register_db(db__sqlite__DB _v_toheap_db, string id, string email, string passwd) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	bool return_bool = false;
	Array_sql_db__PersonalFlag personal_flag = __new_array_with_default(0, 0, sizeof(sql_db__PersonalFlag), 0);

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Task _t2;
	// sql { select from `challenge` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("challenge"),
			.is_count = false,
			.has_where = false,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("tid"),
			.fields = new_array_from_c_array(8, 8, sizeof(string),
				_MOV((string[8]){
					_SLIT("tid"),
					_SLIT("type_text"),
					_SLIT("name"),
					_SLIT("diff"),
					_SLIT("intro"),
					_SLIT("max_score"),
					_SLIT("score"),
					_SLIT("container"),
				})
			),
			.types = new_array_from_c_array(8, 8, sizeof(int),
				_MOV((int[8]){ 8, 21, 21, 21, 21, 8, 8, 19, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0)
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Task*) _t2.data = __new_array_with_default(0, 0, sizeof(sql_db__Task), 0);
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Task _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Task));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Task _t5 = (sql_db__Task) {.tid = 0, .type_text = (string){.str=(byteptr)"", .is_lit=1}, .flag = __new_array(0, 0, sizeof(sql_db__PostFlag)), .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag)), .name = (string){.str=(byteptr)"", .is_lit=1}, .diff = (string){.str=(byteptr)"", .is_lit=1}, .intro = (string){.str=(byteptr)"", .is_lit=1}, .max_score = 0, .score = 0, .container = 0};
			if (_t4.len > 0) {
				_t5.tid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.type_text = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_result_Array_sql_db__PostFlag _t7;
				// sql { select from `post_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("post_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(2, 2, sizeof(string),
							_MOV((string[2]){
								_SLIT("parents_challenge"),
								_SLIT("flag"),
							})
						),
						.types = new_array_from_c_array(2, 2, sizeof(int),
							_MOV((int[2]){ 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PostFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PostFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PostFlag _t10 = (sql_db__PostFlag) {.parents_challenge = 0, .flag = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.flag = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._string);
							array_push(&_t10_array, _MOV((sql_db__PostFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PostFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.flag = *(Array_sql_db__PostFlag*)_t7.data;
				}
				_result_Array_sql_db__PersonalFlag _t12;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t13 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t12.is_error = _t13.is_error;
				_t12.err = _t13.err;
				;
				if (_t12.is_error) {
				}
				if (!_t12.is_error) {
					Array_Array_orm__Primitive _t14 = (*(Array_Array_orm__Primitive*)_t13.data);
					int _t16 = 0;
					Array_sql_db__PersonalFlag _t15_array = __new_array(0, _t14.len, sizeof(sql_db__PersonalFlag));
					for (; _t16 < _t14.len; _t16++) {
						sql_db__PersonalFlag _t15 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t14.len > 0) {
							_t15.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 0))._int);
							_t15.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 1))._int);
							_t15.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 2))._string);
							array_push(&_t15_array, _MOV((sql_db__PersonalFlag[]){ _t15 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t12.data = _t15_array;
				}
				;
				if (!_t12.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t12.data;
				}
				_t5.name = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.diff = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.intro = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_t5.max_score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 5))._int);
				_t5.score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 6))._int);
				_t5.container = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 7))._bool);
				array_push(&_t5_array, _MOV((sql_db__Task[]){ _t5 }));
			}
		}
		*(Array_sql_db__Task*) _t2.data = _t5_array;
	}
		Array_sql_db__Task challenges =  *(Array_sql_db__Task*)_t2.data;
	for (int _t17 = 0; _t17 < challenges.len; ++_t17) {
		sql_db__Task i = ((sql_db__Task*)challenges.data)[_t17];
		array_push((array*)&personal_flag, _MOV((sql_db__PersonalFlag[]){ ((sql_db__PersonalFlag){.parents_id = 0,.parents_challenge = i.tid,.complete = _const_sql_db__unsolved,}) }));
	}
	sql_db__Personal new_number = ((sql_db__Personal){.pid = 0,.id = encoding__base64__url_encode_str(id),.email = encoding__base64__url_encode_str(email),.passwd = err_log__sha256_str(passwd),.whoami = _SLIT("member"),.challenge = personal_flag,});
	// ORM
	orm__Connection _t19 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	Array_orm__Primitive _t21 = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0);
	// sql { insert into `personal` }
	_result_void _t20 = orm__Connection_name_table[_t19._typ]._method_insert(
		_t19._object, // Connection object
		_SLIT("personal"),
		(orm__QueryData){
			.fields = new_array_from_c_array(5, 5, sizeof(string),
				_MOV((string[5]){ 
					_SLIT("pid"),
					_SLIT("id"),
					_SLIT("email"),
					_SLIT("passwd"),
					_SLIT("whoami"),
				})
			),
			.data = new_array_from_c_array(5, 5, sizeof(orm__Primitive),
				_MOV((orm__Primitive[5]){
					orm__int_to_primitive(new_number.pid),
					orm__string_to_primitive(new_number.id),
					orm__string_to_primitive(new_number.email),
					orm__string_to_primitive(new_number.passwd),
					orm__string_to_primitive(new_number.whoami),
				})
			),
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.auto_fields = new_array_from_c_array(1, 1, sizeof(int),
				_MOV((int[1]){ 0, })),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
		}
	);
	;
	if (_t20.is_error) {
		IError err = _t20.err;
		println(str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT(": \345\255\230\345\202\250\346\225\260\346\215\256\345\207\272\351\224\231"), 0xfe10, {.d_s = sql_db__Personal_str(new_number)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return_bool = true;
	}
	orm__Primitive _t22 = orm__int_to_primitive(orm__Connection_name_table[_t19._typ]._method_last_id(_t19._object));
	for (int _t23 = 0; _t23 < new_number.challenge.len; _t23++) {
		sql_db__PersonalFlag _t26 = (*(sql_db__PersonalFlag*)array_get(new_number.challenge, _t23));
		// sql { insert into `personal_flag` }
		_result_void _t25 = orm__Connection_name_table[_t19._typ]._method_insert(
			_t19._object, // Connection object
			_SLIT("personal_flag"),
			(orm__QueryData){
				.fields = new_array_from_c_array(3, 3, sizeof(string),
					_MOV((string[3]){ 
						_SLIT("parents_id"),
						_SLIT("parents_challenge"),
						_SLIT("complete"),
					})
				),
				.data = new_array_from_c_array(3, 3, sizeof(orm__Primitive),
					_MOV((orm__Primitive[3]){
						_t22, 
						orm__int_to_primitive(_t26.parents_challenge),
						orm__string_to_primitive(_t26.complete),
					})
				),
				.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
				.auto_fields = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
				.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
				.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			}
		);
		;
		if (_t25.is_error) {
			IError err = _t25.err;
			println(str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT(": \345\255\230\345\202\250\346\225\260\346\215\256\345\207\272\351\224\231"), 0xfe10, {.d_s = sql_db__Personal_str(new_number)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			return_bool = true;
		}
		;
		if (_t25.is_error) {
			IError err = _t25.err;
			println(str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT(": \345\255\230\345\202\250\346\225\260\346\215\256\345\207\272\351\224\231"), 0xfe10, {.d_s = sql_db__Personal_str(new_number)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			return_bool = true;
		}
	}
	;
	if (_t20.is_error) {
		IError err = _t20.err;
		println(str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT(": \345\255\230\345\202\250\346\225\260\346\215\256\345\207\272\351\224\231"), 0xfe10, {.d_s = sql_db__Personal_str(new_number)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return_bool = true;
	}
	return return_bool;
}
bool sql_db__id_check(db__sqlite__DB _v_toheap_db, string c_id, string oldpasswd, string newpasswd) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Personal _t2;
	// sql { select from `personal` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("personal"),
			.is_count = false,
			.has_where = true,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("pid"),
			.fields = new_array_from_c_array(5, 5, sizeof(string),
				_MOV((string[5]){
					_SLIT("pid"),
					_SLIT("id"),
					_SLIT("email"),
					_SLIT("passwd"),
					_SLIT("whoami"),
				})
			),
			.types = new_array_from_c_array(5, 5, sizeof(int),
				_MOV((int[5]){ 8, 21, 21, 21, 21, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		// ORM where
		(orm__QueryData){
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.fields = new_array_from_c_array(2, 2, sizeof(string),
				_MOV((string[2]){
					_SLIT("id"),
					_SLIT("passwd"),
				})
			),
			.data = new_array_from_c_array(2, 2, sizeof(orm__Primitive),
				_MOV((orm__Primitive[2]){
					orm__string_to_primitive(c_id),
					orm__string_to_primitive(err_log__sha256_str(oldpasswd)),
				})
			),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.kinds = new_array_from_c_array(2, 2, sizeof(orm__OperationKind),
				_MOV((orm__OperationKind[2]){
					orm__OperationKind__eq,
					orm__OperationKind__eq,
				})
			),
			.is_and = new_array_from_c_array(1, 1, sizeof(bool),_MOV((bool[1]){
					true,
				})),
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Personal*) _t2.data = sql_db__personal_err();
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Personal _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Personal));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Personal _t5 = (sql_db__Personal) {.pid = 0, .id = (string){.str=(byteptr)"", .is_lit=1}, .email = (string){.str=(byteptr)"", .is_lit=1}, .passwd = (string){.str=(byteptr)"", .is_lit=1}, .whoami = (string){.str=(byteptr)"", .is_lit=1}, .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag))};
			if (_t4.len > 0) {
				_t5.pid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_t5.email = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.passwd = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.whoami = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_result_Array_sql_db__PersonalFlag _t7;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_id"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.pid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PersonalFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PersonalFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PersonalFlag _t10 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._int);
							_t10.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 2))._string);
							array_push(&_t10_array, _MOV((sql_db__PersonalFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t7.data;
				}
				array_push(&_t5_array, _MOV((sql_db__Personal[]){ _t5 }));
			}
		}
		*(Array_sql_db__Personal*) _t2.data = _t5_array;
	}
		Array_sql_db__Personal id_check =  *(Array_sql_db__Personal*)_t2.data;
	if (id_check.len != 0) {
		err_log__logs(str_intp(3, _MOV((StrIntpData[]){{_SLIT("Setting: "), 0xfe10, {.d_s = c_id}}, {_SLIT("\345\260\206\344\277\256\346\224\271\345\257\206\347\240\201\344\270\272:"), 0xfe10, {.d_s = newpasswd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		// ORM
		orm__Connection _t12 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
		// sql { update `personal` }
		_result_void _t13 = orm__Connection_name_table[_t12._typ]._method_update(
			_t12._object, // Connection object
			_SLIT("personal"),
			(orm__QueryData){
				.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
				.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
				.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
				.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
				.fields = new_array_from_c_array(1, 1, sizeof(string),
					_MOV((string[1]){
						_SLIT("passwd"),
					})
				),
				.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
					_MOV((orm__Primitive[1]){
						orm__string_to_primitive(newpasswd),
					})
				),
			},
			// ORM where
			(orm__QueryData){
				.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
				.fields = new_array_from_c_array(2, 2, sizeof(string),
					_MOV((string[2]){
						_SLIT("id"),
						_SLIT("passwd"),
					})
				),
				.data = new_array_from_c_array(2, 2, sizeof(orm__Primitive),
					_MOV((orm__Primitive[2]){
						orm__string_to_primitive(c_id),
						orm__string_to_primitive(oldpasswd),
					})
				),
				.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
				.kinds = new_array_from_c_array(2, 2, sizeof(orm__OperationKind),
					_MOV((orm__OperationKind[2]){
						orm__OperationKind__eq,
						orm__OperationKind__eq,
					})
				),
				.is_and = new_array_from_c_array(1, 1, sizeof(bool),_MOV((bool[1]){
						true,
					})),
			}
		);
		;
		if (_t13.is_error) {
			IError err = _t13.err;
			err_log__logs(str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT(": "), 0xfe10, {.d_s = c_id}}, {_SLIT("\344\277\256\346\224\271\345\257\206\347\240\201\345\244\261\350\264\245"), 0, { .d_c = 0 }}})));
			return false;
		}
		return true;
	}
	return false;
}
VV_LOCAL_SYMBOL Array_sql_db__Task sql_db__challenge_err(void) {
	println(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__false_log}}, {_SLIT("\346\237\245\350\257\242\351\224\231\350\257\257"), 0, { .d_c = 0 }}})));
	return __new_array_with_default(0, 0, sizeof(sql_db__Task), 0);
}
VV_LOCAL_SYMBOL Array_sql_db__Task sql_db__challenge_db(db__sqlite__DB _v_toheap_db, string i) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);

	// ORM
	orm__Connection _t2 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Task _t3;
	// sql { select from `challenge` }
	_result_Array_Array_orm__Primitive _t4 = orm__Connection_name_table[_t2._typ]._method_select(
		_t2._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("challenge"),
			.is_count = false,
			.has_where = true,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("tid"),
			.fields = new_array_from_c_array(8, 8, sizeof(string),
				_MOV((string[8]){
					_SLIT("tid"),
					_SLIT("type_text"),
					_SLIT("name"),
					_SLIT("diff"),
					_SLIT("intro"),
					_SLIT("max_score"),
					_SLIT("score"),
					_SLIT("container"),
				})
			),
			.types = new_array_from_c_array(8, 8, sizeof(int),
				_MOV((int[8]){ 8, 21, 21, 21, 21, 8, 8, 19, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		// ORM where
		(orm__QueryData){
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.fields = new_array_from_c_array(1, 1, sizeof(string),
				_MOV((string[1]){
					_SLIT("type_text"),
				})
			),
			.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
				_MOV((orm__Primitive[1]){
					orm__string_to_primitive(i),
				})
			),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
				_MOV((orm__OperationKind[1]){
					orm__OperationKind__eq,
				})
			),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
		}
	);
	_t3.is_error = _t4.is_error;
	_t3.err = _t4.err;
	;
	if (_t3.is_error) {
		IError err = _t3.err;
		*(Array_sql_db__Task*) _t3.data = sql_db__challenge_err();
	}
	if (!_t3.is_error) {
		Array_Array_orm__Primitive _t5 = (*(Array_Array_orm__Primitive*)_t4.data);
		int _t7 = 0;
		Array_sql_db__Task _t6_array = __new_array(0, _t5.len, sizeof(sql_db__Task));
		for (; _t7 < _t5.len; _t7++) {
			sql_db__Task _t6 = (sql_db__Task) {.tid = 0, .type_text = (string){.str=(byteptr)"", .is_lit=1}, .flag = __new_array(0, 0, sizeof(sql_db__PostFlag)), .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag)), .name = (string){.str=(byteptr)"", .is_lit=1}, .diff = (string){.str=(byteptr)"", .is_lit=1}, .intro = (string){.str=(byteptr)"", .is_lit=1}, .max_score = 0, .score = 0, .container = 0};
			if (_t5.len > 0) {
				_t6.tid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 0))._int);
				_t6.type_text = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 1))._string);
				_result_Array_sql_db__PostFlag _t8;
				// sql { select from `post_flag` }
				_result_Array_Array_orm__Primitive _t9 = orm__Connection_name_table[_t2._typ]._method_select(
					_t2._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("post_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(2, 2, sizeof(string),
							_MOV((string[2]){
								_SLIT("parents_challenge"),
								_SLIT("flag"),
							})
						),
						.types = new_array_from_c_array(2, 2, sizeof(int),
							_MOV((int[2]){ 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t6.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t8.is_error = _t9.is_error;
				_t8.err = _t9.err;
				;
				if (_t8.is_error) {
				}
				if (!_t8.is_error) {
					Array_Array_orm__Primitive _t10 = (*(Array_Array_orm__Primitive*)_t9.data);
					int _t12 = 0;
					Array_sql_db__PostFlag _t11_array = __new_array(0, _t10.len, sizeof(sql_db__PostFlag));
					for (; _t12 < _t10.len; _t12++) {
						sql_db__PostFlag _t11 = (sql_db__PostFlag) {.parents_challenge = 0, .flag = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t10.len > 0) {
							_t11.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t10, _t12)), 0))._int);
							_t11.flag = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t10, _t12)), 1))._string);
							array_push(&_t11_array, _MOV((sql_db__PostFlag[]){ _t11 }));
						}
					}
					*(Array_sql_db__PostFlag*) _t8.data = _t11_array;
				}
				;
				if (!_t8.is_error) {
					_t6.flag = *(Array_sql_db__PostFlag*)_t8.data;
				}
				_result_Array_sql_db__PersonalFlag _t13;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t14 = orm__Connection_name_table[_t2._typ]._method_select(
					_t2._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t6.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t13.is_error = _t14.is_error;
				_t13.err = _t14.err;
				;
				if (_t13.is_error) {
				}
				if (!_t13.is_error) {
					Array_Array_orm__Primitive _t15 = (*(Array_Array_orm__Primitive*)_t14.data);
					int _t17 = 0;
					Array_sql_db__PersonalFlag _t16_array = __new_array(0, _t15.len, sizeof(sql_db__PersonalFlag));
					for (; _t17 < _t15.len; _t17++) {
						sql_db__PersonalFlag _t16 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t15.len > 0) {
							_t16.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t15, _t17)), 0))._int);
							_t16.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t15, _t17)), 1))._int);
							_t16.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t15, _t17)), 2))._string);
							array_push(&_t16_array, _MOV((sql_db__PersonalFlag[]){ _t16 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t13.data = _t16_array;
				}
				;
				if (!_t13.is_error) {
					_t6.challenge = *(Array_sql_db__PersonalFlag*)_t13.data;
				}
				_t6.name = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 2))._string);
				_t6.diff = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 3))._string);
				_t6.intro = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 4))._string);
				_t6.max_score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 5))._int);
				_t6.score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 6))._int);
				_t6.container = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t5, _t7)), 7))._bool);
				array_push(&_t6_array, _MOV((sql_db__Task[]){ _t6 }));
			}
		}
		*(Array_sql_db__Task*) _t3.data = _t6_array;
	}
		return  *(Array_sql_db__Task*)_t3.data;
}
Array_sql_db__Type sql_db__build_challenge(db__sqlite__DB _v_toheap_db) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	Array_sql_db__Type list_of_type = __new_array_with_default(0, 0, sizeof(sql_db__Type), 0);
	Array_string list = __new_array_with_default(0, 0, sizeof(string), 0);

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Task _t2;
	// sql { select from `challenge` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("challenge"),
			.is_count = false,
			.has_where = false,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("tid"),
			.fields = new_array_from_c_array(8, 8, sizeof(string),
				_MOV((string[8]){
					_SLIT("tid"),
					_SLIT("type_text"),
					_SLIT("name"),
					_SLIT("diff"),
					_SLIT("intro"),
					_SLIT("max_score"),
					_SLIT("score"),
					_SLIT("container"),
				})
			),
			.types = new_array_from_c_array(8, 8, sizeof(int),
				_MOV((int[8]){ 8, 21, 21, 21, 21, 8, 8, 19, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0)
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Task*) _t2.data = sql_db__challenge_err();
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Task _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Task));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Task _t5 = (sql_db__Task) {.tid = 0, .type_text = (string){.str=(byteptr)"", .is_lit=1}, .flag = __new_array(0, 0, sizeof(sql_db__PostFlag)), .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag)), .name = (string){.str=(byteptr)"", .is_lit=1}, .diff = (string){.str=(byteptr)"", .is_lit=1}, .intro = (string){.str=(byteptr)"", .is_lit=1}, .max_score = 0, .score = 0, .container = 0};
			if (_t4.len > 0) {
				_t5.tid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.type_text = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_result_Array_sql_db__PostFlag _t7;
				// sql { select from `post_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("post_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(2, 2, sizeof(string),
							_MOV((string[2]){
								_SLIT("parents_challenge"),
								_SLIT("flag"),
							})
						),
						.types = new_array_from_c_array(2, 2, sizeof(int),
							_MOV((int[2]){ 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PostFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PostFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PostFlag _t10 = (sql_db__PostFlag) {.parents_challenge = 0, .flag = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.flag = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._string);
							array_push(&_t10_array, _MOV((sql_db__PostFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PostFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.flag = *(Array_sql_db__PostFlag*)_t7.data;
				}
				_result_Array_sql_db__PersonalFlag _t12;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t13 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t12.is_error = _t13.is_error;
				_t12.err = _t13.err;
				;
				if (_t12.is_error) {
				}
				if (!_t12.is_error) {
					Array_Array_orm__Primitive _t14 = (*(Array_Array_orm__Primitive*)_t13.data);
					int _t16 = 0;
					Array_sql_db__PersonalFlag _t15_array = __new_array(0, _t14.len, sizeof(sql_db__PersonalFlag));
					for (; _t16 < _t14.len; _t16++) {
						sql_db__PersonalFlag _t15 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t14.len > 0) {
							_t15.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 0))._int);
							_t15.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 1))._int);
							_t15.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 2))._string);
							array_push(&_t15_array, _MOV((sql_db__PersonalFlag[]){ _t15 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t12.data = _t15_array;
				}
				;
				if (!_t12.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t12.data;
				}
				_t5.name = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.diff = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.intro = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_t5.max_score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 5))._int);
				_t5.score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 6))._int);
				_t5.container = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 7))._bool);
				array_push(&_t5_array, _MOV((sql_db__Task[]){ _t5 }));
			}
		}
		*(Array_sql_db__Task*) _t2.data = _t5_array;
	}
		Array_sql_db__Task challenge =  *(Array_sql_db__Task*)_t2.data;
	for (int _t17 = 0; _t17 < challenge.len; ++_t17) {
		sql_db__Task i = ((sql_db__Task*)challenge.data)[_t17];
		if ((Array_string_contains(list, i.type_text))) {
			continue;
		} else {
			array_push((array*)&list, _MOV((string[]){ string_clone(i.type_text) }));
		}
	}
	for (int _t19 = 0; _t19 < list.len; ++_t19) {
		string i = ((string*)list.data)[_t19];
		array_push((array*)&list_of_type, _MOV((sql_db__Type[]){ ((sql_db__Type){.name = i,.type_text = sql_db__challenge_db((*(db)), i),}) }));
	}
	return list_of_type;
}
bool sql_db__post_flag(db__sqlite__DB _v_toheap_db, string ip, int tid, string flag, int pid) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	err_log__logs(str_intp(6, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__set_log}}, {_SLIT("ip:"), 0xfe10, {.d_s = ip}}, {_SLIT(" pid:"), 0xfe07, {.d_i32 = pid}}, {_SLIT(" \346\217\220\344\272\244 tid:"), 0xfe07, {.d_i32 = tid}}, {_SLIT(" flag:"), 0xfe10, {.d_s = flag}}, {_SLIT0, 0, { .d_c = 0 }}})));

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Task _t2;
	// sql { select from `challenge` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("challenge"),
			.is_count = false,
			.has_where = true,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("tid"),
			.fields = new_array_from_c_array(8, 8, sizeof(string),
				_MOV((string[8]){
					_SLIT("tid"),
					_SLIT("type_text"),
					_SLIT("name"),
					_SLIT("diff"),
					_SLIT("intro"),
					_SLIT("max_score"),
					_SLIT("score"),
					_SLIT("container"),
				})
			),
			.types = new_array_from_c_array(8, 8, sizeof(int),
				_MOV((int[8]){ 8, 21, 21, 21, 21, 8, 8, 19, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		// ORM where
		(orm__QueryData){
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.fields = new_array_from_c_array(1, 1, sizeof(string),
				_MOV((string[1]){
					_SLIT("tid"),
				})
			),
			.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
				_MOV((orm__Primitive[1]){
					orm__int_to_primitive(tid),
				})
			),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
				_MOV((orm__OperationKind[1]){
					orm__OperationKind__eq,
				})
			),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Task*) _t2.data = sql_db__challenge_err();
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Task _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Task));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Task _t5 = (sql_db__Task) {.tid = 0, .type_text = (string){.str=(byteptr)"", .is_lit=1}, .flag = __new_array(0, 0, sizeof(sql_db__PostFlag)), .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag)), .name = (string){.str=(byteptr)"", .is_lit=1}, .diff = (string){.str=(byteptr)"", .is_lit=1}, .intro = (string){.str=(byteptr)"", .is_lit=1}, .max_score = 0, .score = 0, .container = 0};
			if (_t4.len > 0) {
				_t5.tid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.type_text = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_result_Array_sql_db__PostFlag _t7;
				// sql { select from `post_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("post_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(2, 2, sizeof(string),
							_MOV((string[2]){
								_SLIT("parents_challenge"),
								_SLIT("flag"),
							})
						),
						.types = new_array_from_c_array(2, 2, sizeof(int),
							_MOV((int[2]){ 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PostFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PostFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PostFlag _t10 = (sql_db__PostFlag) {.parents_challenge = 0, .flag = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.flag = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._string);
							array_push(&_t10_array, _MOV((sql_db__PostFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PostFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.flag = *(Array_sql_db__PostFlag*)_t7.data;
				}
				_result_Array_sql_db__PersonalFlag _t12;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t13 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_challenge"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.tid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t12.is_error = _t13.is_error;
				_t12.err = _t13.err;
				;
				if (_t12.is_error) {
				}
				if (!_t12.is_error) {
					Array_Array_orm__Primitive _t14 = (*(Array_Array_orm__Primitive*)_t13.data);
					int _t16 = 0;
					Array_sql_db__PersonalFlag _t15_array = __new_array(0, _t14.len, sizeof(sql_db__PersonalFlag));
					for (; _t16 < _t14.len; _t16++) {
						sql_db__PersonalFlag _t15 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t14.len > 0) {
							_t15.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 0))._int);
							_t15.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 1))._int);
							_t15.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t14, _t16)), 2))._string);
							array_push(&_t15_array, _MOV((sql_db__PersonalFlag[]){ _t15 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t12.data = _t15_array;
				}
				;
				if (!_t12.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t12.data;
				}
				_t5.name = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.diff = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.intro = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_t5.max_score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 5))._int);
				_t5.score = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 6))._int);
				_t5.container = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 7))._bool);
				array_push(&_t5_array, _MOV((sql_db__Task[]){ _t5 }));
			}
		}
		*(Array_sql_db__Task*) _t2.data = _t5_array;
	}
		Array_sql_db__Task challenge_flag =  *(Array_sql_db__Task*)_t2.data;
	if (challenge_flag.len == 0) {
		return false;
	}
	bool _t18 = (Array_sql_db__PostFlag_contains((*(sql_db__Task*)array_first(challenge_flag)).flag, ((sql_db__PostFlag){.parents_challenge = tid,.flag = flag,})));
	
	if (_t18) {
		int new_score = (int)((*(sql_db__Task*)array_first(challenge_flag)).score - (int)(300 / ((int)((int)((*(sql_db__Task*)array_first(challenge_flag)).max_score - (*(sql_db__Task*)array_first(challenge_flag)).score) + 10))));
		// ORM
		orm__Connection _t19 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
		// sql { update `personal_flag` }
		_result_void _t20 = orm__Connection_name_table[_t19._typ]._method_update(
			_t19._object, // Connection object
			_SLIT("personal_flag"),
			(orm__QueryData){
				.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
				.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
				.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
				.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
				.fields = new_array_from_c_array(1, 1, sizeof(string),
					_MOV((string[1]){
						_SLIT("complete"),
					})
				),
				.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
					_MOV((orm__Primitive[1]){
						orm__string_to_primitive(_const_sql_db__solved),
					})
				),
			},
			// ORM where
			(orm__QueryData){
				.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
				.fields = new_array_from_c_array(2, 2, sizeof(string),
					_MOV((string[2]){
						_SLIT("parents_challenge"),
						_SLIT("parents_id"),
					})
				),
				.data = new_array_from_c_array(2, 2, sizeof(orm__Primitive),
					_MOV((orm__Primitive[2]){
						orm__int_to_primitive(tid),
						orm__int_to_primitive(pid),
					})
				),
				.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
				.kinds = new_array_from_c_array(2, 2, sizeof(orm__OperationKind),
					_MOV((orm__OperationKind[2]){
						orm__OperationKind__eq,
						orm__OperationKind__eq,
					})
				),
				.is_and = new_array_from_c_array(1, 1, sizeof(bool),_MOV((bool[1]){
						true,
					})),
			}
		);
		;
		if (_t20.is_error) {
			IError err = _t20.err;
			err_log__logs(str_intp(2, _MOV((StrIntpData[]){{_SLIT("Flag: "), 0xfe10, {.d_s = flag}}, {_SLIT("\351\224\231\350\257\257"), 0, { .d_c = 0 }}})));
		;
		}
		// sql { update `challenge` }
		_result_void _t21 = orm__Connection_name_table[_t19._typ]._method_update(
			_t19._object, // Connection object
			_SLIT("challenge"),
			(orm__QueryData){
				.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
				.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
				.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
				.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
				.fields = new_array_from_c_array(1, 1, sizeof(string),
					_MOV((string[1]){
						_SLIT("score"),
					})
				),
				.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
					_MOV((orm__Primitive[1]){
						orm__int_to_primitive(new_score),
					})
				),
			},
			// ORM where
			(orm__QueryData){
				.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
				.fields = new_array_from_c_array(1, 1, sizeof(string),
					_MOV((string[1]){
						_SLIT("tid"),
					})
				),
				.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
					_MOV((orm__Primitive[1]){
						orm__int_to_primitive(tid),
					})
				),
				.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
				.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
					_MOV((orm__OperationKind[1]){
						orm__OperationKind__eq,
					})
				),
				.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			}
		);
		;
		if (_t21.is_error) {
			IError err = _t21.err;
			err_log__logs(str_intp(2, _MOV((StrIntpData[]){{_SLIT("Flag: "), 0xfe10, {.d_s = flag}}, {_SLIT("\351\224\231\350\257\257"), 0, { .d_c = 0 }}})));
		;
		}
		err_log__logs(str_intp(6, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_vlog__true_log}}, {_SLIT("ip:"), 0xfe10, {.d_s = ip}}, {_SLIT(" pid:"), 0xfe07, {.d_i32 = pid}}, {_SLIT(" \346\217\220\344\272\244\346\255\243\347\241\256 tid:"), 0xfe07, {.d_i32 = tid}}, {_SLIT(" flag:"), 0xfe10, {.d_s = flag}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return true;
	} else {
		err_log__logs(_SLIT("Flag: \344\277\256\346\224\271\345\207\272\351\224\231"));
	}
	return false;
}
sql_db__Personal sql_db__find_user(db__sqlite__DB _v_toheap_db, string id, string pwd) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);

	// ORM
	orm__Connection _t1 = (orm__Connection){._db__sqlite__DB = &(*(db)), ._typ = _orm__Connection_db__sqlite__DB_index};
	_result_Array_sql_db__Personal _t2;
	// sql { select from `personal` }
	_result_Array_Array_orm__Primitive _t3 = orm__Connection_name_table[_t1._typ]._method_select(
		_t1._object, // Connection object
		(orm__SelectConfig){
			.table = _SLIT("personal"),
			.is_count = false,
			.has_where = true,
			.has_order = false,
			.has_limit = false,
			.has_offset = false,
			.primary = _SLIT("pid"),
			.fields = new_array_from_c_array(5, 5, sizeof(string),
				_MOV((string[5]){
					_SLIT("pid"),
					_SLIT("id"),
					_SLIT("email"),
					_SLIT("passwd"),
					_SLIT("whoami"),
				})
			),
			.types = new_array_from_c_array(5, 5, sizeof(int),
				_MOV((int[5]){ 8, 21, 21, 21, 21, })
			),
		},
		(orm__QueryData) {
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
			.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
		)},
		// ORM where
		(orm__QueryData){
			.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
			.fields = new_array_from_c_array(2, 2, sizeof(string),
				_MOV((string[2]){
					_SLIT("id"),
					_SLIT("passwd"),
				})
			),
			.data = new_array_from_c_array(2, 2, sizeof(orm__Primitive),
				_MOV((orm__Primitive[2]){
					orm__string_to_primitive(id),
					orm__string_to_primitive(err_log__sha256_str(pwd)),
				})
			),
			.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
			.kinds = new_array_from_c_array(2, 2, sizeof(orm__OperationKind),
				_MOV((orm__OperationKind[2]){
					orm__OperationKind__eq,
					orm__OperationKind__eq,
				})
			),
			.is_and = new_array_from_c_array(1, 1, sizeof(bool),_MOV((bool[1]){
					true,
				})),
		}
	);
	_t2.is_error = _t3.is_error;
	_t2.err = _t3.err;
	;
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_sql_db__Personal*) _t2.data = sql_db__personal_err();
	}
	if (!_t2.is_error) {
		Array_Array_orm__Primitive _t4 = (*(Array_Array_orm__Primitive*)_t3.data);
		int _t6 = 0;
		Array_sql_db__Personal _t5_array = __new_array(0, _t4.len, sizeof(sql_db__Personal));
		for (; _t6 < _t4.len; _t6++) {
			sql_db__Personal _t5 = (sql_db__Personal) {.pid = 0, .id = (string){.str=(byteptr)"", .is_lit=1}, .email = (string){.str=(byteptr)"", .is_lit=1}, .passwd = (string){.str=(byteptr)"", .is_lit=1}, .whoami = (string){.str=(byteptr)"", .is_lit=1}, .challenge = __new_array(0, 0, sizeof(sql_db__PersonalFlag))};
			if (_t4.len > 0) {
				_t5.pid = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 0))._int);
				_t5.id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 1))._string);
				_t5.email = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 2))._string);
				_t5.passwd = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 3))._string);
				_t5.whoami = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t4, _t6)), 4))._string);
				_result_Array_sql_db__PersonalFlag _t7;
				// sql { select from `personal_flag` }
				_result_Array_Array_orm__Primitive _t8 = orm__Connection_name_table[_t1._typ]._method_select(
					_t1._object, // Connection object
					(orm__SelectConfig){
						.table = _SLIT("personal_flag"),
						.is_count = false,
						.has_where = true,
						.has_order = false,
						.has_limit = false,
						.has_offset = false,
						.fields = new_array_from_c_array(3, 3, sizeof(string),
							_MOV((string[3]){
								_SLIT("parents_id"),
								_SLIT("parents_challenge"),
								_SLIT("complete"),
							})
						),
						.types = new_array_from_c_array(3, 3, sizeof(int),
							_MOV((int[3]){ 8, 8, 21, })
						),
					},
					(orm__QueryData) {
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.kinds = __new_array_with_default_noscan(0, 0, sizeof(orm__OperationKind), 0),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.data = __new_array_with_default_noscan(0, 0, sizeof(orm__Primitive), 0
					)},
					// ORM where
					(orm__QueryData){
						.types = __new_array_with_default_noscan(0, 0, sizeof(int), 0),
						.fields = new_array_from_c_array(1, 1, sizeof(string),
							_MOV((string[1]){
								_SLIT("parents_id"),
							})
						),
						.data = new_array_from_c_array(1, 1, sizeof(orm__Primitive),
							_MOV((orm__Primitive[1]){
								orm__int_to_primitive(_t5.pid),
							})
						),
						.parentheses = __new_array_with_default_noscan(0, 0, sizeof(Array_int), 0),
						.kinds = new_array_from_c_array(1, 1, sizeof(orm__OperationKind),
							_MOV((orm__OperationKind[1]){
								orm__OperationKind__eq,
							})
						),
						.is_and = __new_array_with_default_noscan(0, 0, sizeof(bool), 0),
					}
				);
				_t7.is_error = _t8.is_error;
				_t7.err = _t8.err;
				;
				if (_t7.is_error) {
				}
				if (!_t7.is_error) {
					Array_Array_orm__Primitive _t9 = (*(Array_Array_orm__Primitive*)_t8.data);
					int _t11 = 0;
					Array_sql_db__PersonalFlag _t10_array = __new_array(0, _t9.len, sizeof(sql_db__PersonalFlag));
					for (; _t11 < _t9.len; _t11++) {
						sql_db__PersonalFlag _t10 = (sql_db__PersonalFlag) {.parents_id = 0, .parents_challenge = 0, .complete = (string){.str=(byteptr)"", .is_lit=1}};
						if (_t9.len > 0) {
							_t10.parents_id = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 0))._int);
							_t10.parents_challenge = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 1))._int);
							_t10.complete = *((*(orm__Primitive*) array_get((*(Array_orm__Primitive*) array_get(_t9, _t11)), 2))._string);
							array_push(&_t10_array, _MOV((sql_db__PersonalFlag[]){ _t10 }));
						}
					}
					*(Array_sql_db__PersonalFlag*) _t7.data = _t10_array;
				}
				;
				if (!_t7.is_error) {
					_t5.challenge = *(Array_sql_db__PersonalFlag*)_t7.data;
				}
				array_push(&_t5_array, _MOV((sql_db__Personal[]){ _t5 }));
			}
		}
		*(Array_sql_db__Personal*) _t2.data = _t5_array;
	}
		Array_sql_db__Personal pid =  *(Array_sql_db__Personal*)_t2.data;
	return (*(sql_db__Personal*)array_first(pid));
}
VV_LOCAL_SYMBOL void rand__deinit(void) {
	{ // Unsafe block
		rand__PRNG_name_table[default_rng->_typ]._method__v_free(default_rng->_object);
		_v_free(default_rng);
	}
}
VV_LOCAL_SYMBOL void rand__init(void) {
	default_rng = rand__new_default(((rand__config__PRNGConfigStruct){.seed_ = rand__seed__time_seed_array(2),}));
	_result_void _t1 = at_exit((voidptr)rand__deinit);
	(void)_t1;
 ;
}
inline _result_u32 rand__PRNG_u32n(rand__PRNG* rng, u32 max) {
	if (max == 0U) {
		return (_result_u32){ .is_error=true, .err=_v_error(_SLIT("max must be positive integer")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int bit_len = math__bits__len_32(max);
	if (_unlikely_(bit_len == 32)) {
		for (;;) {
			u32 value = rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object);
			if (value < max) {
				_result_u32 _t2 = {0};
				_result_ok(&(u32[]) { value }, (_result*)(&_t2), sizeof(u32));
				return _t2;
			}
		}
	} else {
		u32 mask = (_unlikely_(bit_len == 31) ? (((u32)(0x7FFFFFFFU))) : ((u32)(((((u32)(1U)) << ((int)(bit_len + 1)))) - 1U)));
		for (;;) {
			u32 value = (rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object) & mask);
			if (value < max) {
				_result_u32 _t3 = {0};
				_result_ok(&(u32[]) { value }, (_result*)(&_t3), sizeof(u32));
				return _t3;
			}
		}
	}
	_result_u32 _t4 = {0};
	_result_ok(&(u32[]) { ((u32)(0U)) }, (_result*)(&_t4), sizeof(u32));
	return _t4;
}
inline _result_int rand__PRNG_intn(rand__PRNG* rng, int max) {
	if (max <= 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("max has to be positive.")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_u32 _t3 = rand__PRNG_u32n(rng, ((u32)(max)));
	if (_t3.is_error) {
		_result_int _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_int _t2 = {0};
	_result_ok(&(int[]) { ((int)((*(u32*)_t3.data))) }, (_result*)(&_t2), sizeof(int));
	return _t2;
}
rand__PRNG* rand__new_default(rand__config__PRNGConfigStruct config_) {
	rand__wyrand__WyRandRNG* rng = ((rand__wyrand__WyRandRNG*)memdup(&(rand__wyrand__WyRandRNG){.PRNGBuffer = ((rand__buffer__PRNGBuffer){.bytes_left = 0,.buffer = 0,}),.state = rand__seed__time_seed_64(),.bytes_left = 0,.buffer = 0,}, sizeof(rand__wyrand__WyRandRNG)));
	rand__wyrand__WyRandRNG_seed(rng, config_.seed_);
	array_free(&config_.seed_);
	return HEAP(rand__PRNG, I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rng));
}
_result_int rand__intn(int max) {
	return rand__PRNG_intn(default_rng, max);
}
VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st(u32 n, u32 st) {
	u32 wsem = (n > 0U ? (n) : (1));
	u32 rsem = (n > 0U ? (((u32)(0U))) : (1));
	u8* rbuf = (n > 0U ? (_v_malloc(((int)((u32)(n * st))))) : (((u8*)(0))));
	u8* sbuf = (n > 0U ? (vcalloc_noscan(((int)((u32)(n * 2U))))) : (((u8*)(0))));
	sync__Channel *ch = HEAP(sync__Channel, (((sync__Channel){
		.ringbuf = rbuf,
		.statusbuf = sbuf,
		.objsize = st,
		.writesem = ((sync__Semaphore){EMPTY_STRUCT_INITIALIZATION}),
		.readsem = ((sync__Semaphore){EMPTY_STRUCT_INITIALIZATION}),
		.writesem_im = ((sync__Semaphore){EMPTY_STRUCT_INITIALIZATION}),
		.readsem_im = ((sync__Semaphore){EMPTY_STRUCT_INITIALIZATION}),
		.write_free = n,
		.read_avail = 0U,
		.buf_elem_write_idx = 0,
		.buf_elem_read_idx = 0,
		.write_subscriber = ((void*)0),
		.read_subscriber = ((void*)0),
		.write_sub_mtx = 0,
		.read_sub_mtx = 0,
		.closed = 0,
		.cap = n,
	})));
	sync__Semaphore_init(&(*(ch)).writesem, wsem);
	sync__Semaphore_init(&(*(ch)).readsem, rsem);
	sync__Semaphore_init(&(*(ch)).writesem_im, 0U);
	sync__Semaphore_init(&(*(ch)).readsem_im, 0U);
	return &(*(ch));
}
VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st_noscan(u32 n, u32 st) {
	#if defined(CUSTOM_DEFINE_gcboehm_opt)
	{
		u32 wsem = (n > 0U ? (n) : (1));
		u32 rsem = (n > 0U ? (((u32)(0U))) : (1));
		u8* rbuf = (n > 0U ? (malloc_noscan(((int)((u32)(n * st))))) : (((u8*)(0))));
		u8* sbuf = (n > 0U ? (vcalloc_noscan(((int)((u32)(n * 2U))))) : (((u8*)(0))));
		sync__Channel *ch = HEAP(sync__Channel, (((sync__Channel){
			.ringbuf = rbuf,
			.statusbuf = sbuf,
			.objsize = st,
			.writesem = ((sync__Semaphore){EMPTY_STRUCT_INITIALIZATION}),
			.readsem = ((sync__Semaphore){EMPTY_STRUCT_INITIALIZATION}),
			.writesem_im = ((sync__Semaphore){EMPTY_STRUCT_INITIALIZATION}),
			.readsem_im = ((sync__Semaphore){EMPTY_STRUCT_INITIALIZATION}),
			.write_free = n,
			.read_avail = 0U,
			.buf_elem_write_idx = 0,
			.buf_elem_read_idx = 0,
			.write_subscriber = ((void*)0),
			.read_subscriber = ((void*)0),
			.write_sub_mtx = 0,
			.read_sub_mtx = 0,
			.closed = 0,
			.cap = n,
		})));
		sync__Semaphore_init(&(*(ch)).writesem, wsem);
		sync__Semaphore_init(&(*(ch)).readsem, rsem);
		sync__Semaphore_init(&(*(ch)).writesem_im, 0U);
		sync__Semaphore_init(&(*(ch)).readsem_im, 0U);
		return &(*(ch));
	}
	#else
	{
	}
	#endif
	return 0;
}
string sync__Channel_auto_str(sync__Channel* ch, string __v_typename) {
	return str_intp(4, _MOV((StrIntpData[]){{_SLIT("chan "), 0xfe10, {.d_s = __v_typename}}, {_SLIT("{cap: "), 0xfe06, {.d_u32 = ch->cap}}, {_SLIT(", closed: "), 0xfe04, {.d_u16 = ch->closed}}, {_SLIT("}"), 0, { .d_c = 0 }}}));
}
void sync__Channel_close(sync__Channel* ch) {
	u16 open_val = ((u16)(0U));
	if (!atomic_compare_exchange_strong_u16(&ch->closed, &open_val, 1U)) {
		return;
	}
	voidptr nulladr = ((void*)0);
	for (;;) {
		if (!(!atomic_compare_exchange_weak_ptr(((voidptr)(&ch->adr_written)), ((voidptr)(&nulladr)), ((isize)(-1))))) break;
		nulladr = ((void*)0);
	}
	sync__Semaphore_post(&ch->readsem_im);
	sync__Semaphore_post(&ch->readsem);
	u16 null16 = ((u16)(0U));
	for (;;) {
		if (!(!atomic_compare_exchange_weak_u16(&ch->read_sub_mtx, &null16, ((u16)(1U))))) break;
		null16 = ((u16)(0U));
	}
	if (ch->read_subscriber != ((void*)0)) {
		sync__Semaphore_post(ch->read_subscriber->sem);
	}
	atomic_store_u16(&ch->read_sub_mtx, ((u16)(0U)));
	null16 = ((u16)(0U));
	for (;;) {
		if (!(!atomic_compare_exchange_weak_u16(&ch->write_sub_mtx, &null16, ((u16)(1U))))) break;
		null16 = ((u16)(0U));
	}
	if (ch->write_subscriber != ((void*)0)) {
		sync__Semaphore_post(ch->write_subscriber->sem);
	}
	atomic_store_u16(&ch->write_sub_mtx, ((u16)(0U)));
	sync__Semaphore_post(&ch->writesem);
	if (ch->cap == 0U) {
		atomic_store_ptr(((voidptr*)(&ch->read_adr)), ((void*)0));
	}
	sync__Semaphore_post(&ch->writesem_im);
}
inline int sync__Channel_len(sync__Channel* ch) {
	return ((int)(atomic_load_u32(&ch->read_avail)));
}
inline bool sync__Channel_closed(sync__Channel* ch) {
	return atomic_load_u16(&ch->closed) != 0U;
}
inline void sync__Channel_push(sync__Channel* ch, voidptr src) {
	if (sync__Channel_try_push_priv(ch, src, false) == ChanState__closed) {
		_v_panic(_SLIT("push on closed channel"));
		VUNREACHABLE();
	}
}
inline ChanState sync__Channel_try_push(sync__Channel* ch, voidptr src) {
	return sync__Channel_try_push_priv(ch, src, true);
}
VV_LOCAL_SYMBOL ChanState sync__Channel_try_push_priv(sync__Channel* ch, voidptr src, bool no_block) {
	if (atomic_load_u16(&ch->closed) != 0U) {
		return ChanState__closed;
	}
	multi_return_int_int mr_4763 = (no_block ? ((multi_return_int_int){.arg0=1,.arg1=1}) : ((multi_return_int_int){.arg0=_const_sync__spinloops,.arg1=_const_sync__spinloops_sem}));
	int spinloops_sem_ = mr_4763.arg0;
	int spinloops_ = mr_4763.arg1;
	bool have_swapped = false;
	for (;;) {
		bool got_sem = false;
		voidptr wradr = atomic_load_ptr(((voidptr*)(&ch->write_adr)));
		for (;;) {
			if (!(wradr != NULL)) break;
			if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->write_adr)), ((voidptr)(&wradr)), ((isize)(0)))) {
				memcpy(wradr, src, ch->objsize);
				voidptr nulladr = ((void*)0);
				for (;;) {
					if (!(!atomic_compare_exchange_weak_ptr(((voidptr)(&ch->adr_written)), ((voidptr)(&nulladr)), ((isize)(wradr))))) break;
					nulladr = ((void*)0);
				}
				sync__Semaphore_post(&ch->readsem_im);
				return ChanState__success;
			}
		}
		if (no_block && ch->cap == 0U) {
			return ChanState__not_ready;
		}
		for (int _t4 = 0; _t4 < spinloops_sem_; ++_t4) {
			if (got_sem) {
				break;
			}
			got_sem = sync__Semaphore_try_wait(&ch->writesem);
		}
		if (!got_sem) {
			if (no_block) {
				return ChanState__not_ready;
			}
			sync__Semaphore_wait(&ch->writesem);
		}
		if (atomic_load_u16(&ch->closed) != 0U) {
			sync__Semaphore_post(&ch->writesem);
			return ChanState__closed;
		}
		if (ch->cap == 0U) {
			bool read_in_progress = false;
			atomic_store_ptr(((voidptr*)(&ch->read_adr)), src);
			wradr = atomic_load_ptr(((voidptr*)(&ch->write_adr)));
			if (wradr != NULL) {
				voidptr src2 = src;
				if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->read_adr)), ((voidptr)(&src2)), ((isize)(0)))) {
					sync__Semaphore_post(&ch->writesem);
					continue;
				} else {
					read_in_progress = true;
				}
			}
			if (!read_in_progress) {
				u16 null16 = ((u16)(0U));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(((voidptr)(&ch->read_sub_mtx)), &null16, ((u16)(1U))))) break;
					null16 = ((u16)(0U));
				}
				if (ch->read_subscriber != ((void*)0)) {
					sync__Semaphore_post(ch->read_subscriber->sem);
				}
				atomic_store_u16(&ch->read_sub_mtx, ((u16)(0U)));
			}
			voidptr src2 = src;
			for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_) || read_in_progress; sp++) {
				if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->adr_read)), ((voidptr)(&src2)), ((isize)(0)))) {
					have_swapped = true;
					read_in_progress = true;
					break;
				}
				src2 = src;
			}
			bool got_im_sem = false;
			for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_sem_) || read_in_progress; sp++) {
				got_im_sem = sync__Semaphore_try_wait(&ch->writesem_im);
				if (got_im_sem) {
					break;
				}
			}
			for (;;) {
				if (got_im_sem) {
					got_im_sem = false;
				} else {
					sync__Semaphore_wait(&ch->writesem_im);
				}
				if (atomic_load_u16(&ch->closed) != 0U) {
					if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr)(&ch->adr_read)), ((voidptr)(&src2)), ((isize)(0)))) {
						sync__Semaphore_post(&ch->writesem);
						return ChanState__success;
					} else {
						return ChanState__closed;
					}
				}
				if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr)(&ch->adr_read)), ((voidptr)(&src2)), ((isize)(0)))) {
					sync__Semaphore_post(&ch->writesem);
					break;
				} else {
					sync__Semaphore_post(&ch->writesem_im);
					if (src2 == ((voidptr)(-1))) {
						sync__Semaphore_post(&ch->readsem);
						return ChanState__closed;
					}
					src2 = src;
				}
			}
			return ChanState__success;
		} else {
			bool space_in_queue = false;
			u32 wr_free = atomic_load_u32(&ch->write_free);
			for (;;) {
				if (!(wr_free > 0U)) break;
				space_in_queue = atomic_compare_exchange_weak_u32(&ch->write_free, &wr_free, (u32)(wr_free - 1U));
				if (space_in_queue) {
					break;
				}
			}
			if (space_in_queue) {
				u32 wr_idx = atomic_load_u32(&ch->buf_elem_write_idx);
				for (;;) {
					u32 new_wr_idx = (u32)(wr_idx + 1U);
					for (;;) {
						if (!(new_wr_idx >= ch->cap)) break;
						new_wr_idx -= ch->cap;
					}
					if (atomic_compare_exchange_strong_u32(&ch->buf_elem_write_idx, &wr_idx, new_wr_idx)) {
						break;
					}
				}
				u8* wr_ptr = ch->ringbuf;
				u8* status_adr = ch->statusbuf;
				{ // Unsafe block
					wr_ptr += ((u32)(wr_idx * ch->objsize));
					status_adr += (u32)(wr_idx * sizeof(u16));
				}
				u16 expected_status = ((u16)(sync__BufferElemStat__unused));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(status_adr, &expected_status, ((u16)(sync__BufferElemStat__writing))))) break;
					expected_status = ((u16)(sync__BufferElemStat__unused));
				}
				memcpy(wr_ptr, src, ch->objsize);
				atomic_store_u16(((u16*)(status_adr)), ((u16)(sync__BufferElemStat__written)));
				atomic_fetch_add_u32(((voidptr)(&ch->read_avail)), 1U);
				sync__Semaphore_post(&ch->readsem);
				u16 null16 = ((u16)(0U));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(&ch->read_sub_mtx, &null16, ((u16)(1U))))) break;
					null16 = ((u16)(0U));
				}
				if (ch->read_subscriber != ((void*)0)) {
					sync__Semaphore_post(ch->read_subscriber->sem);
				}
				atomic_store_u16(&ch->read_sub_mtx, ((u16)(0U)));
				return ChanState__success;
			} else {
				if (no_block) {
					return ChanState__not_ready;
				}
				sync__Semaphore_post(&ch->writesem);
			}
		}
	}
	_v_panic(_SLIT("unknown `try_push_priv` state"));
	VUNREACHABLE();
	return 0;
}
inline bool sync__Channel_pop(sync__Channel* ch, voidptr dest) {
	return sync__Channel_try_pop_priv(ch, dest, false) == ChanState__success;
}
inline ChanState sync__Channel_try_pop(sync__Channel* ch, voidptr dest) {
	return sync__Channel_try_pop_priv(ch, dest, true);
}
VV_LOCAL_SYMBOL ChanState sync__Channel_try_pop_priv(sync__Channel* ch, voidptr dest, bool no_block) {
	multi_return_int_int mr_9744 = (no_block ? ((multi_return_int_int){.arg0=1,.arg1=1}) : ((multi_return_int_int){.arg0=_const_sync__spinloops,.arg1=_const_sync__spinloops_sem}));
	int spinloops_sem_ = mr_9744.arg0;
	int spinloops_ = mr_9744.arg1;
	bool have_swapped = false;
	bool write_in_progress = false;
	for (;;) {
		bool got_sem = false;
		if (ch->cap == 0U) {
			voidptr rdadr = atomic_load_ptr(((voidptr*)(&ch->read_adr)));
			for (;;) {
				if (!(rdadr != NULL)) break;
				if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->read_adr)), ((voidptr)(&rdadr)), ((isize)(0)))) {
					memcpy(dest, rdadr, ch->objsize);
					voidptr nulladr = ((void*)0);
					for (;;) {
						if (!(!atomic_compare_exchange_weak_ptr(((voidptr)(&ch->adr_read)), ((voidptr)(&nulladr)), ((isize)(rdadr))))) break;
						nulladr = ((void*)0);
					}
					sync__Semaphore_post(&ch->writesem_im);
					return ChanState__success;
				}
			}
			if (no_block) {
				if (atomic_load_u16(&ch->closed) == 0U) {
					return ChanState__not_ready;
				} else {
					return ChanState__closed;
				}
			}
		}
		for (int _t4 = 0; _t4 < spinloops_sem_; ++_t4) {
			if (got_sem) {
				break;
			}
			got_sem = sync__Semaphore_try_wait(&ch->readsem);
		}
		if (!got_sem) {
			if (no_block) {
				if (atomic_load_u16(&ch->closed) == 0U) {
					return ChanState__not_ready;
				} else {
					return ChanState__closed;
				}
			}
			sync__Semaphore_wait(&ch->readsem);
		}
		if (ch->cap > 0U) {
			bool obj_in_queue = false;
			u32 rd_avail = atomic_load_u32(&ch->read_avail);
			for (;;) {
				if (!(rd_avail > 0U)) break;
				obj_in_queue = atomic_compare_exchange_weak_u32(&ch->read_avail, &rd_avail, (u32)(rd_avail - 1U));
				if (obj_in_queue) {
					break;
				}
			}
			if (obj_in_queue) {
				u32 rd_idx = atomic_load_u32(&ch->buf_elem_read_idx);
				for (;;) {
					u32 new_rd_idx = (u32)(rd_idx + 1U);
					for (;;) {
						if (!(new_rd_idx >= ch->cap)) break;
						new_rd_idx -= ch->cap;
					}
					if (atomic_compare_exchange_weak_u32(&ch->buf_elem_read_idx, &rd_idx, new_rd_idx)) {
						break;
					}
				}
				u8* rd_ptr = ch->ringbuf;
				u8* status_adr = ch->statusbuf;
				{ // Unsafe block
					rd_ptr += (u32)(rd_idx * ch->objsize);
					status_adr += (u32)(rd_idx * sizeof(u16));
				}
				u16 expected_status = ((u16)(sync__BufferElemStat__written));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(status_adr, &expected_status, ((u16)(sync__BufferElemStat__reading))))) break;
					expected_status = ((u16)(sync__BufferElemStat__written));
				}
				memcpy(dest, rd_ptr, ch->objsize);
				atomic_store_u16(((u16*)(status_adr)), ((u16)(sync__BufferElemStat__unused)));
				atomic_fetch_add_u32(((voidptr)(&ch->write_free)), 1U);
				sync__Semaphore_post(&ch->writesem);
				u16 null16 = ((u16)(0U));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(&ch->write_sub_mtx, &null16, ((u16)(1U))))) break;
					null16 = ((u16)(0U));
				}
				if (ch->write_subscriber != ((void*)0)) {
					sync__Semaphore_post(ch->write_subscriber->sem);
				}
				atomic_store_u16(&ch->write_sub_mtx, ((u16)(0U)));
				return ChanState__success;
			}
		}
		atomic_store_ptr(((voidptr*)(&ch->write_adr)), dest);
		if (ch->cap == 0U) {
			voidptr rdadr = atomic_load_ptr(((voidptr*)(&ch->read_adr)));
			if (rdadr != NULL) {
				voidptr dest2 = dest;
				if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->write_adr)), ((voidptr)(&dest2)), ((isize)(0)))) {
					sync__Semaphore_post(&ch->readsem);
					continue;
				} else {
					write_in_progress = true;
				}
			}
		}
		if (ch->cap == 0U && !write_in_progress) {
			u16 null16 = ((u16)(0U));
			for (;;) {
				if (!(!atomic_compare_exchange_weak_u16(&ch->write_sub_mtx, &null16, ((u16)(1U))))) break;
				null16 = ((u16)(0U));
			}
			if (ch->write_subscriber != ((void*)0)) {
				sync__Semaphore_post(ch->write_subscriber->sem);
			}
			atomic_store_u16(&ch->write_sub_mtx, ((u16)(0U)));
		}
		voidptr dest2 = dest;
		for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_) || write_in_progress; sp++) {
			if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->adr_written)), ((voidptr)(&dest2)), ((isize)(0)))) {
				have_swapped = true;
				break;
			} else if (dest2 == ((voidptr)(-1))) {
				sync__Semaphore_post(&ch->readsem);
				return ChanState__closed;
			}
			dest2 = dest;
		}
		bool got_im_sem = false;
		for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_sem_) || write_in_progress; sp++) {
			got_im_sem = sync__Semaphore_try_wait(&ch->readsem_im);
			if (got_im_sem) {
				break;
			}
		}
		for (;;) {
			if (got_im_sem) {
				got_im_sem = false;
			} else {
				sync__Semaphore_wait(&ch->readsem_im);
			}
			if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr)(&ch->adr_written)), ((voidptr)(&dest2)), ((isize)(0)))) {
				sync__Semaphore_post(&ch->readsem);
				break;
			} else {
				sync__Semaphore_post(&ch->readsem_im);
				if (dest2 == ((voidptr)(-1))) {
					sync__Semaphore_post(&ch->readsem);
					return ChanState__closed;
				}
				dest2 = dest;
			}
		}
		break;
	}
	return ChanState__success;
}
int sync__channel_select(Array_sync__Channel_ptr* channels, Array_sync__Direction dir, Array_voidptr* objrefs, time__Duration timeout) {
	Array_sync__Subscription subscr = __new_array_with_default(channels->len, 0, sizeof(sync__Subscription), (voidptr)&(sync__Subscription[]){(sync__Subscription){.sem = ((void*)0),.prev = ((void*)0),.nxt = ((void*)0),}}[0]);
	sync__Semaphore *sem = HEAP(sync__Semaphore, (((sync__Semaphore){EMPTY_STRUCT_INITIALIZATION})));
	sync__Semaphore_init(&(*(sem)), 0U);
	for (int i = 0; i < channels->len; ++i) {
		sync__Channel* ch = ((sync__Channel**)channels->data)[i];
		(*(sync__Subscription*)array_get(subscr, i)).sem = &(*(sem));
		multi_return_ref_u16_ref_sync__Subscription mr_15049 = ((*(sync__Direction*)array_get(dir, i)) == sync__Direction__push ? ((multi_return_ref_u16_ref_sync__Subscription){.arg0=&ch->write_sub_mtx,.arg1=&ch->write_subscriber}) : ((multi_return_ref_u16_ref_sync__Subscription){.arg0=&ch->read_sub_mtx,.arg1=&ch->read_subscriber}));
		u16* sub_mtx = mr_15049.arg0;
		sync__Subscription** subscriber = mr_15049.arg1;
		u16 null16 = ((u16)(0U));
		for (;;) {
			if (!(!atomic_compare_exchange_weak_u16(sub_mtx, &null16, ((u16)(1U))))) break;
			null16 = ((u16)(0U));
		}
		(*(sync__Subscription*)array_get(subscr, i)).prev = subscriber;
		{ // Unsafe block
			(*(sync__Subscription*)array_get(subscr, i)).nxt = ((sync__Subscription*)(atomic_exchange_ptr(((voidptr*)(subscriber)), &(*(sync__Subscription*)array_get(subscr, i)))));
		}
		if (((voidptr)((*(sync__Subscription*)array_get(subscr, i)).nxt)) != ((void*)0)) {
			(*(sync__Subscription*)array_get(subscr, i)).nxt->prev = &(*(sync__Subscription*)array_get(subscr, i)).nxt;
		}
		atomic_store_u16(sub_mtx, ((u16)(0U)));
	}
	time__StopWatch stopwatch = (timeout == _const_time__infinite || timeout <= 0 ? (((time__StopWatch){.elapsed = 0,.start = 0,.end = 0,})) : (time__new_stopwatch(((time__StopWatchOptions){.auto_start = true,}))));
	int event_idx = -1;
	outer:
	for (;;) {
		_result_int _t1 = rand__intn(channels->len);
		if (_t1.is_error) {
			IError err = _t1.err;
			*(int*) _t1.data = 0;
		}
		
 		int rnd = (*(int*)_t1.data);
		int num_closed = 0;
		for (int j = 0; j < channels->len; ++j) {
			int i = (int)(j + rnd);
			if (i >= channels->len) {
				i -= channels->len;
			}
			ChanState stat = ((*(sync__Direction*)array_get(dir, i)) == sync__Direction__push ? (sync__Channel_try_push_priv((*(sync__Channel**)array_get(*channels, i)), (*(voidptr*)array_get(*objrefs, i)), true)) : (sync__Channel_try_pop_priv((*(sync__Channel**)array_get(*channels, i)), (*(voidptr*)array_get(*objrefs, i)), true)));
			if (stat == ChanState__success) {
				event_idx = i;
				goto outer__break;
			} else if (stat == ChanState__closed) {
				num_closed++;
			}
		}
		if (num_closed == channels->len) {
			event_idx = -2;
			goto outer__break;
		}
		if (timeout <= 0) {
			goto outer__break;
		}
		if (timeout != _const_time__infinite) {
			time__Duration remaining = timeout - time__StopWatch_elapsed(stopwatch);
			if (!sync__Semaphore_timed_wait(&(*(sem)), remaining)) {
				goto outer__break;
			}
		} else {
			sync__Semaphore_wait(&(*(sem)));
		}
		outer__continue: {}
	}
	outer__break: {}
	for (int i = 0; i < channels->len; ++i) {
		sync__Channel* ch = ((sync__Channel**)channels->data)[i];
		u16* sub_mtx = ((*(sync__Direction*)array_get(dir, i)) == sync__Direction__push ? (&ch->write_sub_mtx) : (&ch->read_sub_mtx));
		u16 null16 = ((u16)(0U));
		for (;;) {
			if (!(!atomic_compare_exchange_weak_u16(sub_mtx, &null16, ((u16)(1U))))) break;
			null16 = ((u16)(0U));
		}
		{ // Unsafe block
			*(*(sync__Subscription*)array_get(subscr, i)).prev = (*(sync__Subscription*)array_get(subscr, i)).nxt;
		}
		if ((*(sync__Subscription*)array_get(subscr, i)).nxt != 0) {
			(*(sync__Subscription*)array_get(subscr, i)).nxt->prev = (*(sync__Subscription*)array_get(subscr, i)).prev;
			sync__Semaphore_post((*(sync__Subscription*)array_get(subscr, i)).nxt->sem);
		}
		atomic_store_u16(sub_mtx, ((u16)(0U)));
	}
	sync__Semaphore_destroy(&(*(sem)));
	return event_idx;
}
string sync__Mutex_str(sync__Mutex* m) {
	return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Mutex("), 0xfe11, {.d_p = (void*)(((voidptr)(m)))}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
}
string sync__RwMutex_str(sync__RwMutex* m) {
	return str_intp(2, _MOV((StrIntpData[]){{_SLIT("RwMutex("), 0xfe11, {.d_p = (void*)(((voidptr)(m)))}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
}
VNORETURN VV_LOCAL_SYMBOL void sync__cpanic(int res) {
	_v_panic(tos_clone(((u8*)(strerror(res)))));
	VUNREACHABLE();
	while(1);
}
VNORETURN VV_LOCAL_SYMBOL void sync__cpanic_errno(void) {
	sync__cpanic(errno);
	VUNREACHABLE();
	while(1);
}
VV_LOCAL_SYMBOL void sync__should_be_zero(int res) {
	if (res != 0) {
		sync__cpanic(res);
		VUNREACHABLE();
	}
}
void sync__WaitGroup_init(sync__WaitGroup* wg) {
	sync__Semaphore_init(&wg->sem, 0U);
}
#if !defined(__ANDROID__)
#endif
inline void sync__Mutex_init(sync__Mutex* m) {
	pthread_mutex_init(&m->mutex, NULL);
}
void sync__RwMutex_init(sync__RwMutex* m) {
	sync__RwMutexAttr a = ((sync__RwMutexAttr){EMPTY_STRUCT_INITIALIZATION});
	pthread_rwlockattr_init(&a.attr);
	pthread_rwlockattr_setkind_np(&a.attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);
	pthread_rwlockattr_setpshared(&a.attr, PTHREAD_PROCESS_PRIVATE);
	pthread_rwlock_init(&m->mutex, &a.attr);
	pthread_rwlockattr_destroy(&a.attr);
}
inline void sync__Mutex_lock(sync__Mutex* m) {
	pthread_mutex_lock(&m->mutex);
}
inline void sync__Mutex_unlock(sync__Mutex* m) {
	pthread_mutex_unlock(&m->mutex);
}
inline void sync__RwMutex_rlock(sync__RwMutex* m) {
	pthread_rwlock_rdlock(&m->mutex);
}
inline void sync__RwMutex_lock(sync__RwMutex* m) {
	pthread_rwlock_wrlock(&m->mutex);
}
inline void sync__RwMutex_runlock(sync__RwMutex* m) {
	pthread_rwlock_unlock(&m->mutex);
}
inline void sync__RwMutex_unlock(sync__RwMutex* m) {
	pthread_rwlock_unlock(&m->mutex);
}
inline void sync__Semaphore_init(sync__Semaphore* sem, u32 n) {
	sem_init(&sem->sem, 0, n);
}
inline void sync__Semaphore_post(sync__Semaphore* sem) {
	sem_post(&sem->sem);
}
void sync__Semaphore_wait(sync__Semaphore* sem) {
	for (;;) {
		if (sem_wait(&sem->sem) == 0) {
			return;
		}
		int e = errno;

		if (e == (EINTR)) {
			continue;
		}
		else {
			sync__cpanic_errno();
			VUNREACHABLE();
		}
	}
}
bool sync__Semaphore_try_wait(sync__Semaphore* sem) {
	#if !defined(_VDEBUG)
	{
		return sem_trywait(&sem->sem) == 0;
	}
	#else
	{
	}
	#endif
	return 0;
}
bool sync__Semaphore_timed_wait(sync__Semaphore* sem, time__Duration timeout) {
	struct timespec t_spec = time__Duration_timespec(timeout);
	for (;;) {
		#if !defined(__APPLE__)
		{
			if (sem_timedwait(&sem->sem, &t_spec) == 0) {
				return true;
			}
		}
		#endif
		int e = errno;

		if (e == (EINTR)) {
			continue;
		}
		else if (e == (ETIMEDOUT)) {
			break;
		}
		else {
			sync__cpanic(e);
			VUNREACHABLE();
		}
	}
	return false;
}
void sync__Semaphore_destroy(sync__Semaphore* sem) {
	sync__should_be_zero(sem_destroy(&sem->sem));
}
#if defined(_WIN32)
#else
#endif
net__Addr net__new_ip6(u16 port, Array_fixed_u8_16 addr) {
	u16 n_port = net__conv__hton16(port);
	net__Addr a = ((net__Addr){.f = ((u8)(net__AddrFamily__ip6)),.addr = ((net__AddrData){.Ip6 = ((net__Ip6){.port = n_port,.flow_info = 0,.addr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.scope_id = 0,}),}),});
	vmemcpy(&a.addr.Ip6.addr[0], &addr[0], 16);
	return a;
}
net__Addr net__new_ip(u16 port, Array_fixed_u8_4 addr) {
	u16 n_port = net__conv__hton16(port);
	net__Addr a = ((net__Addr){.f = ((u8)(net__AddrFamily__ip)),.addr = ((net__AddrData){.Ip = ((net__Ip){.port = n_port,.addr = {0, 0, 0, 0},.sin_pad = {0, 0, 0, 0, 0, 0, 0, 0},}),}),});
	vmemcpy(&a.addr.Ip.addr[0], &addr[0], 4);
	return a;
}
net__AddrFamily net__Addr_family(net__Addr a) {
	return ((net__AddrFamily)(a.f));
}
string net__Ip_str(net__Ip a) {
	Array_fixed_char_24 buf = {0};
	char* res = ((char*)(inet_ntop(net__AddrFamily__ip, &a.addr, &buf[0], 24)));
	if (res == 0) {
		return _SLIT("<Unknown>");
	}
	string saddr = cstring_to_vstring(&buf[0]);
	u16 port = net__conv__ntoh16(a.port);
	return str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = saddr}}, {_SLIT(":"), 0xfe04, {.d_u16 = port}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
string net__Ip6_str(net__Ip6 a) {
	Array_fixed_char_46 buf = {0};
	char* res = ((char*)(inet_ntop(net__AddrFamily__ip6, &a.addr, &buf[0], 46)));
	if (res == 0) {
		return _SLIT("<Unknown>");
	}
	string saddr = cstring_to_vstring(&buf[0]);
	u16 port = net__conv__ntoh16(a.port);
	return str_intp(3, _MOV((StrIntpData[]){{_SLIT("["), 0xfe10, {.d_s = saddr}}, {_SLIT("]:"), 0xfe04, {.d_u16 = port}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
u32 net__Addr_len(net__Addr a) {
	net__AddrFamily _t1 = net__Addr_family(a);
	
	if (_t1 == (net__AddrFamily__ip)) {
		return (u32)(sizeof(net__Ip) + _const_net__aoffset);
	}
	else if (_t1 == (net__AddrFamily__ip6)) {
		return (u32)(sizeof(net__Ip6) + _const_net__aoffset);
	}
	else if (_t1 == (net__AddrFamily__unix)) {
		return (u32)(sizeof(net__Unix) + _const_net__aoffset);
	}
	else {
		_v_panic(_SLIT("Unknown address family"));
		VUNREACHABLE();
	}
	return 0;
}
_result_Array_net__Addr net__resolve_addrs(string addr, net__AddrFamily family, net__SocketType typ) {

	if (family == (net__AddrFamily__ip) || family == (net__AddrFamily__ip6) || family == (net__AddrFamily__unspec)) {
		return net__resolve_ipaddrs(addr, family, typ);
	}
	else if (family == (net__AddrFamily__unix)) {
		net__Unix resolved = ((net__Unix){.path = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},});
		if (addr.len > 108) {
			return (_result_Array_net__Addr){ .is_error=true, .err=_v_error(_SLIT("net: resolve_addrs Unix socket address is too long")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		memcpy(&resolved.path, addr.str, addr.len);
		_result_Array_net__Addr _t3 = {0};
		_result_ok(&(Array_net__Addr[]) { new_array_from_c_array_noscan(1, 1, sizeof(net__Addr), _MOV((net__Addr[1]){((net__Addr){.f = ((u8)(net__AddrFamily__unix)),.addr = ((net__AddrData){.Unix = resolved,}),})})) }, (_result*)(&_t3), sizeof(Array_net__Addr));
		return _t3;
	}
	return (_result_Array_net__Addr){0};
}
_result_Array_net__Addr net__resolve_addrs_fuzzy(string addr, net__SocketType typ) {
	if (addr.len == 0) {
		return (_result_Array_net__Addr){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (string_contains(addr, _SLIT(":"))) {
		return net__resolve_addrs(addr, net__AddrFamily__unspec, typ);
	}
	return net__resolve_addrs(addr, net__AddrFamily__unix, typ);
}
_result_Array_net__Addr net__resolve_ipaddrs(string addr, net__AddrFamily family, net__SocketType typ) {
	bool net__resolve_ipaddrs_defer_0 = false;
	struct addrinfo* results;
	_result_multi_return_string_u16 _t1 = net__split_address(addr);
	if (_t1.is_error) {
		_result_Array_net__Addr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	multi_return_string_u16 mr_3968 = (*(multi_return_string_u16*)_t1.data);
	string address = mr_3968.arg0;
	u16 port = mr_3968.arg1;
	if (string_at(addr, 0) == ':') {

		if (family == (net__AddrFamily__ip6)) {
			_result_Array_net__Addr _t3 = {0};
			_result_ok(&(Array_net__Addr[]) { new_array_from_c_array_noscan(1, 1, sizeof(net__Addr), _MOV((net__Addr[1]){net__new_ip6(port, _const_net__addr_ip6_any)})) }, (_result*)(&_t3), sizeof(Array_net__Addr));
			return _t3;
		}
		else if (family == (net__AddrFamily__ip) || family == (net__AddrFamily__unspec)) {
			_result_Array_net__Addr _t4 = {0};
			_result_ok(&(Array_net__Addr[]) { new_array_from_c_array_noscan(1, 1, sizeof(net__Addr), _MOV((net__Addr[1]){net__new_ip(port, _const_net__addr_ip_any)})) }, (_result*)(&_t4), sizeof(Array_net__Addr));
			return _t4;
		}
		else {
		}
	}
	struct addrinfo hints;
	vmemset(&hints, 0, ((int)(sizeof(struct addrinfo))));
	hints.ai_family = ((int)(family));
	hints.ai_socktype = ((int)(typ));
	hints.ai_flags = AI_PASSIVE;
	results = ((struct addrinfo*)(((void*)0)));
	string sport = str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe04, {.d_u16 = port}}, {_SLIT0, 0, { .d_c = 0 }}}));
	#if defined(_WIN32)
	{
	}
	#else
	{
		int x = getaddrinfo(((char*)(address.str)), ((char*)(sport.str)), &hints, &results);
		_result_void _t6 = net__wrap_error(x);
		if (_t6.is_error) {
			_result_Array_net__Addr _t7;
			memcpy(&_t7, &_t6, sizeof(_result));
			return _t7;
		}
		
 ;
	}
	#endif
	net__resolve_ipaddrs_defer_0 = true;
	Array_net__Addr addresses = __new_array_with_default_noscan(0, 0, sizeof(net__Addr), 0);
	for (struct addrinfo* result = results; !isnil(result); result = result->ai_next) {
		net__AddrFamily _t8 = ((net__AddrFamily)(result->ai_family));
		
		if (_t8 == (net__AddrFamily__ip)) {
			net__Addr new_addr = ((net__Addr){.f = 0,.addr = ((net__AddrData){.Ip = ((net__Ip){.port = 0,.addr = {0, 0, 0, 0},.sin_pad = {0, 0, 0, 0, 0, 0, 0, 0},}),}),});
			memcpy(&new_addr, result->ai_addr, result->ai_addrlen);
			array_push_noscan((array*)&addresses, _MOV((net__Addr[]){ new_addr }));
		}
		else if (_t8 == (net__AddrFamily__ip6)) {
			net__Addr new_addr = ((net__Addr){.f = 0,.addr = ((net__AddrData){.Ip6 = ((net__Ip6){.port = 0,.flow_info = 0,.addr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.scope_id = 0,}),}),});
			memcpy(&new_addr, result->ai_addr, result->ai_addrlen);
			array_push_noscan((array*)&addresses, _MOV((net__Addr[]){ new_addr }));
		}
		else {
			_v_panic(string__plus(_SLIT("Unexpected address family "), int_str(result->ai_family)));
			VUNREACHABLE();
		}
	}
	_result_Array_net__Addr _t11 = {0};
	_result_ok(&(Array_net__Addr[]) { addresses }, (_result*)(&_t11), sizeof(Array_net__Addr));
	// Defer begin
	if (net__resolve_ipaddrs_defer_0) {
		freeaddrinfo(results);
	}
	// Defer end
	return _t11;
}
string net__Addr_str(net__Addr a) {
	net__AddrFamily _t1 = ((net__AddrFamily)(a.f));
	
	if (_t1 == (net__AddrFamily__ip)) {
		{ // Unsafe block
			return net__Ip_str(a.addr.Ip);
		}
	}
	else if (_t1 == (net__AddrFamily__ip6)) {
		{ // Unsafe block
			return net__Ip6_str(a.addr.Ip6);
		}
	}
	else if (_t1 == (net__AddrFamily__unix)) {
		{ // Unsafe block
			return tos_clone(array_slice(new_array_from_c_array_noscan(108, 108, sizeof(u8), a.addr.Unix.path), 0, _const_net__max_unix_path).data);
		}
	}
	else if (_t1 == (net__AddrFamily__unspec)) {
		return _SLIT("<.unspec>");
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
net__Addr net__addr_from_socket_handle(int handle) {
	net__Addr addr = ((net__Addr){.f = 0,.addr = ((net__AddrData){.Ip6 = ((net__Ip6){.port = 0,.flow_info = 0,.addr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.scope_id = 0,}),}),});
	u32 size = sizeof(net__Addr);
	getsockname(handle, ((voidptr)(&addr)), &size);
	return addr;
}
_result_net__Addr net__peer_addr_from_socket_handle(int handle) {
	net__Addr addr = ((net__Addr){.f = 0,.addr = ((net__AddrData){.Ip6 = ((net__Ip6){.port = 0,.flow_info = 0,.addr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.scope_id = 0,}),}),});
	u32 size = sizeof(net__Addr);
	_result_int _t1 = net__socket_error_message(getpeername(handle, ((voidptr)(&addr)), &size), _SLIT("peer_addr_from_socket_handle failed"));
	if (_t1.is_error) {
		_result_net__Addr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	_result_net__Addr _t3 = {0};
	_result_ok(&(net__Addr[]) { addr }, (_result*)(&_t3), sizeof(net__Addr));
	return _t3;
}
int net__shutdown(int handle, net__ShutdownConfig config) {
	int res = shutdown(handle, ((int)(config.how)));
	#if !defined(CUSTOM_DEFINE_net_nonblocking_sockets)
	{
		return res;
	}
	#else
	{
	}
	#endif
	return 0;
}
_result_void net__close(int handle) {
	int _t1;
	#if defined(_WIN32)
	#else
		_t1 = close(handle);
		;
	#endif
		int res = _t1;
	#if !defined(CUSTOM_DEFINE_net_nonblocking_sockets)
	{
		_result_int _t3 = net__socket_error(res);
		if (_t3.is_error) {
			_result_void _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 ;
		return (_result_void){0};
	}
	#else
	{
	}
	#endif
	return (_result_void){0};
}
VV_LOCAL_SYMBOL _result_bool net__select(int handle, net__Select test, time__Duration timeout) {
	fd_set set = ((fd_set){EMPTY_STRUCT_INITIALIZATION});
	FD_ZERO(&set);
	FD_SET(handle, &set);
	time__Duration seconds = timeout / _const_time__second;
	i64 microseconds = time__Duration_microseconds(((time__Duration)(timeout - (seconds * _const_time__second))));
	struct timeval *tt = HEAP(struct timeval, (((struct timeval){.tv_sec = ((u64)(seconds)),.tv_usec = ((u64)(microseconds)),})));
	struct timeval* timeval_timeout = &(*(tt));
	if (timeout == _const_net__infinite_timeout) {
		timeval_timeout = ((struct timeval*)(((void*)0)));
	}

	if (test == (net__Select__read)) {
		_result_int _t1 = net__socket_error(select((int)(handle + 1), &set, NULL, NULL, timeval_timeout));
		if (_t1.is_error) {
			_result_bool _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 ;
	}
	else if (test == (net__Select__write)) {
		_result_int _t3 = net__socket_error(select((int)(handle + 1), NULL, &set, NULL, timeval_timeout));
		if (_t3.is_error) {
			_result_bool _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 ;
	}
	else if (test == (net__Select__except)) {
		_result_int _t5 = net__socket_error(select((int)(handle + 1), NULL, NULL, &set, timeval_timeout));
		if (_t5.is_error) {
			_result_bool _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 ;
	}
	_result_bool _t7 = {0};
	_result_ok(&(bool[]) { FD_ISSET(handle, &set) != 0 }, (_result*)(&_t7), sizeof(bool));
	return _t7;
}
inline VV_LOCAL_SYMBOL _result_bool net__select_deadline(int handle, net__Select test, time__Time deadline) {
	bool infinite = time__Time_unix(deadline) == 0;
	for (;;) {
		if (!(infinite || !time__Time__lt(deadline, time__now()))) break;
		time__Duration timeout = (infinite ? (_const_net__infinite_timeout) : (time__Time__minus(deadline, time__now())));
		_result_bool _t1 = net__select(handle, test, timeout);
		if (_t1.is_error) {
			IError err = _t1.err;
			if (IError_name_table[err._typ]._method_code(err._object) == EINTR) {
				continue;
			}
			return (_result_bool){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		bool ready = (*(bool*)_t1.data);
		_result_bool _t3 = {0};
		_result_ok(&(bool[]) { ready }, (_result*)(&_t3), sizeof(bool));
		return _t3;
	}
	return (_result_bool){ .is_error=true, .err=_const_net__err_timed_out, .data={EMPTY_STRUCT_INITIALIZATION} };
}
VV_LOCAL_SYMBOL _result_void net__wait_for_common(int handle, time__Time deadline, time__Duration timeout, net__Select test) {
	time__Time _t1; /* if prepend */
	if (timeout == _const_net__infinite_timeout) {
		_t1 = time__unix(0);
	} else if (timeout == 0) {
		_t1 = deadline;
	} else if (timeout < 0) {
		_v_panic(_SLIT("invalid negative timeout"));
		VUNREACHABLE();
	} else {
		_t1 = time__Time_add(time__now(), timeout);
	}
	time__Time real_deadline = _t1;
	_result_bool _t2 = net__select_deadline(handle, test, real_deadline);
	if (_t2.is_error) {
		_result_void _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	bool ready = (*(bool*)_t2.data);
	if (ready) {
		return (_result_void){0};
	}
	return (_result_void){ .is_error=true, .err=_const_net__err_timed_out, .data={EMPTY_STRUCT_INITIALIZATION} };
}
VV_LOCAL_SYMBOL _result_void net__wait_for_write(int handle, time__Time deadline, time__Duration timeout) {
	return net__wait_for_common(handle, deadline, timeout, net__Select__write);
}
VV_LOCAL_SYMBOL _result_void net__wait_for_read(int handle, time__Time deadline, time__Duration timeout) {
	return net__wait_for_common(handle, deadline, timeout, net__Select__read);
}
_result_int net__socket_error_message(int potential_code, string s) {
	_result_int _t2 = net__socket_error(potential_code);
	if (_t2.is_error) {
		IError err = _t2.err;
		return (_result_int){ .is_error=true, .err=_v_error(str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("; "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	_result_int _t1 = {0};
	_result_ok(&(int[]) { (*(int*)_t2.data) }, (_result*)(&_t1), sizeof(int));
	return _t1;
}
_result_int net__socket_error(int potential_code) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		if (potential_code < 0) {
			int last_error = net__error_code();
			return (_result_int){ .is_error=true, .err=error_with_code(str_intp(2, _MOV((StrIntpData[]){{_SLIT("net: socket error: "), 0xfe07, {.d_i32 = last_error}}, {_SLIT0, 0, { .d_c = 0 }}})), last_error), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#endif
	_result_int _t3 = {0};
	_result_ok(&(int[]) { potential_code }, (_result*)(&_t3), sizeof(int));
	return _t3;
}
_result_void net__wrap_error(int error_code) {
	if (error_code == 0) {
		return (_result_void){0};
	}
	#if defined(_WIN32)
	{
	}
	#else
	{
		return (_result_void){ .is_error=true, .err=error_with_code(str_intp(2, _MOV((StrIntpData[]){{_SLIT("net: socket error: "), 0xfe07, {.d_i32 = error_code}}, {_SLIT0, 0, { .d_c = 0 }}})), error_code), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#endif
	return (_result_void){0};
}
int net__error_code(void) {
	return errno;
}
VV_LOCAL_SYMBOL void net__init(void) {
}
_result_net__Addr net__Socket_address(net__Socket* s) {
	_result_net__Addr _t1 = {0};
	_result_ok(&(net__Addr[]) { net__addr_from_socket_handle(s->handle) }, (_result*)(&_t1), sizeof(net__Addr));
	return _t1;
}
_result_net__Connection net__TCPDialer_dial(net__TCPDialer t, string address) {
	_result_net__TcpConn_ptr _t2 = net__dial_tcp(address);
	if (_t2.is_error) {
		_result_net__Connection _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_net__Connection _t1 = {0};
	_result_ok(&(net__Connection[]) { I_net__TcpConn_to_Interface_net__Connection((*(net__TcpConn**)_t2.data)) }, (_result*)(&_t1), sizeof(net__Connection));
	return _t1;
}
_result_net__TcpConn_ptr net__dial_tcp(string oaddress) {
	string address = oaddress;
	_result_Array_net__Addr _t1 = net__resolve_addrs_fuzzy(address, net__SocketType__tcp);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error(str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("; could not resolve address "), 0xfe10, {.d_s = address}}, {_SLIT(" in dial_tcp"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	Array_net__Addr addrs = (*(Array_net__Addr*)_t1.data);
	Array_IError errs = __new_array_with_default(0, 0, sizeof(IError), 0);
	for (int _t3 = 0; _t3 < addrs.len; ++_t3) {
		net__Addr addr = ((net__Addr*)addrs.data)[_t3];
		_result_net__TcpSocket _t4 = net__new_tcp_socket(net__Addr_family(addr));
		if (_t4.is_error) {
			IError err = _t4.err;
			return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("; could not create new tcp socket in dial_tcp"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		net__TcpSocket s = (*(net__TcpSocket*)_t4.data);
		_result_void _t6 = net__TcpSocket_connect(&s, addr);
		if (_t6.is_error) {
			IError err = _t6.err;
			array_push((array*)&errs, _MOV((IError[]){ err }));
			_result_void _t8 = net__TcpSocket_close(&s);
			if (_t8.is_error) {
				IError err = _t8.err;
				continue;
			}
			
 ;
			continue;
		}
		
 ;
		net__TcpConn* conn = ((net__TcpConn*)memdup(&(net__TcpConn){.sock = s,.handle = 0,.write_deadline = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.read_deadline = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.read_timeout = _const_net__tcp_default_read_timeout,.write_timeout = _const_net__tcp_default_write_timeout,.is_blocking = true,}, sizeof(net__TcpConn)));
		_result_net__TcpConn_ptr _t9 = {0};
		_result_ok(&(net__TcpConn*[]) { conn }, (_result*)(&_t9), sizeof(net__TcpConn*));
		return _t9;
	}
	strings__Builder err_builder = strings__new_builder(1024);
	{
		strings__Builder_write_string(&err_builder, _SLIT("dial_tcp failed for address "));
		strings__Builder_write_string(&err_builder, address);
		strings__Builder_write_string(&err_builder, _SLIT("\n"));
	}
	strings__Builder_write_string(&err_builder, _SLIT("tried addrs:\n"));
	for (int i = 0; i < errs.len; i++) {
		net__Addr addr = (*(net__Addr*)array_get(addrs, i));
		IError why = (*(IError*)array_get(errs, i));
		strings__Builder_write_string(&err_builder, str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), 0xfe10, {.d_s = net__Addr_str(addr)}}, {_SLIT(": "), 0xfe10, {.d_s = IError_str(why)}}, {_SLIT("\n"), 0, { .d_c = 0 }}})));
	}
	return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error(strings__Builder_str(&err_builder)), .data={EMPTY_STRUCT_INITIALIZATION} };
}
_result_void net__TcpConn_close(net__TcpConn* c) {
	_result_void _t1 = net__TcpSocket_close(&c->sock);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
_result_int net__TcpConn_read_ptr(net__TcpConn _v_toheap_c, u8* buf_ptr, int len) {
net__TcpConn* c = HEAP(net__TcpConn, _v_toheap_c);
	bool should_ewouldblock = false;
	int _t1;
	#if defined(CUSTOM_DEFINE_is_coroutine)
	#else
		{
			bool has_data = true;
			if ((*(c)).is_blocking) {
				_result_bool _t2;
				if (_t2 = net__select((*(c)).sock.Socket.handle, net__Select__read, 1), !_t2.is_error) {
					bool ok = *(bool*)_t2.data;
					has_data = ok;
				} else {
					IError err = _t2.err;
					false;
				}
			}
		int _t3; /* if prepend */
		if (has_data) {
			_t3 = recv((*(c)).sock.Socket.handle, ((voidptr)(buf_ptr)), len, _const_net__msg_dontwait);
		} else {
			should_ewouldblock = true;
			_t3 = -1;
		}
			_t1 = _t3;
		}
	#endif
		int res = _t1;
	if (res > 0) {
		_result_int _t4 = {0};
		_result_ok(&(int[]) { res }, (_result*)(&_t4), sizeof(int));
		return _t4;
	}
	int code = (should_ewouldblock ? (((int)(_const_net__error_ewouldblock))) : (net__error_code()));
	if (code == ((int)(_const_net__error_ewouldblock)) || code == ((int)(_const_net__error_eagain)) || code == EINTR) {
		_result_void _t5 = net__TcpConn_wait_for_read((*(c)));
		if (_t5.is_error) {
			_result_int _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 ;
		int _t7;
		#if defined(CUSTOM_DEFINE_is_coroutine)
		#else
			_t7 = recv((*(c)).sock.Socket.handle, ((voidptr)(buf_ptr)), len, _const_net__msg_dontwait);
			;
		#endif
				res = _t7;
		return net__socket_error(res);
	} else {
		_result_void _t9 = net__wrap_error(code);
		if (_t9.is_error) {
			_result_int _t10;
			memcpy(&_t10, &_t9, sizeof(_result));
			return _t10;
		}
		
 ;
	}
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}
_result_int net__TcpConn_read(net__TcpConn _v_toheap_c, Array_u8* buf) {
net__TcpConn* c = HEAP(net__TcpConn, _v_toheap_c);
	_result_int _t2 = net__TcpConn_read_ptr((*(c)), buf->data, buf->len);
	if (_t2.is_error) {
		_result_int _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_int _t1 = {0};
	_result_ok(&(int[]) { (*(int*)_t2.data) }, (_result*)(&_t1), sizeof(int));
	return _t1;
}
_result_time__Time net__TcpConn_read_deadline(net__TcpConn* c) {
	if (time__Time_unix(c->read_deadline) == 0) {
		_result_time__Time _t1 = {0};
		_result_ok(&(time__Time[]) { c->read_deadline }, (_result*)(&_t1), sizeof(time__Time));
		return _t1;
	}
	return (_result_time__Time){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}
_result_int net__TcpConn_write_ptr(net__TcpConn* c, u8* b, int len) {
	{ // Unsafe block
		u8* ptr_base = ((u8*)(b));
		int total_sent = 0;
		for (;;) {
			if (!(total_sent < len)) break;
			u8* ptr = ptr_base + total_sent;
			int remaining = (int)(len - total_sent);
			int _t1;
			#if defined(CUSTOM_DEFINE_is_coroutine)
			#else
				_t1 = send(c->sock.Socket.handle, ptr, remaining, _const_net__msg_nosignal);
				;
			#endif
						int sent = _t1;
			if (sent < 0) {
				int code = net__error_code();
				if (code == ((int)(_const_net__error_ewouldblock)) || code == ((int)(_const_net__error_eagain)) || code == EINTR) {
					_result_void _t2 = net__TcpConn_wait_for_write(c);
					if (_t2.is_error) {
						_result_int _t3;
						memcpy(&_t3, &_t2, sizeof(_result));
						return _t3;
					}
					
 ;
					continue;
				} else {
					_result_void _t4 = net__wrap_error(code);
					if (_t4.is_error) {
						_result_int _t5;
						memcpy(&_t5, &_t4, sizeof(_result));
						return _t5;
					}
					
 ;
				}
			}
			total_sent += sent;
		}
		_result_int _t6 = {0};
		_result_ok(&(int[]) { total_sent }, (_result*)(&_t6), sizeof(int));
		return _t6;
	}
	return (_result_int){0};
}
_result_int net__TcpConn_write(net__TcpConn* c, Array_u8 bytes) {
	return net__TcpConn_write_ptr(c, bytes.data, bytes.len);
}
_result_int net__TcpConn_write_string(net__TcpConn* c, string s) {
	return net__TcpConn_write_ptr(c, s.str, s.len);
}
_result_time__Time net__TcpConn_write_deadline(net__TcpConn* c) {
	if (time__Time_unix(c->write_deadline) == 0) {
		_result_time__Time _t1 = {0};
		_result_ok(&(time__Time[]) { c->write_deadline }, (_result*)(&_t1), sizeof(time__Time));
		return _t1;
	}
	return (_result_time__Time){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}
time__Duration net__TcpConn_read_timeout(net__TcpConn* c) {
	return c->read_timeout;
}
void net__TcpConn_set_read_timeout(net__TcpConn* c, time__Duration t) {
	c->read_timeout = t;
}
time__Duration net__TcpConn_write_timeout(net__TcpConn* c) {
	return c->write_timeout;
}
void net__TcpConn_set_write_timeout(net__TcpConn* c, time__Duration t) {
	c->write_timeout = t;
}
inline _result_void net__TcpConn_wait_for_read(net__TcpConn _v_toheap_c) {
net__TcpConn* c = HEAP(net__TcpConn, _v_toheap_c);
	return net__wait_for_read((*(c)).sock.Socket.handle, (*(c)).read_deadline, (*(c)).read_timeout);
}
inline _result_void net__TcpConn_wait_for_write(net__TcpConn* c) {
	return net__wait_for_write(c->sock.Socket.handle, c->write_deadline, c->write_timeout);
}
_result_net__Addr net__TcpConn_peer_addr(net__TcpConn* c) {
	return net__peer_addr_from_socket_handle(c->sock.Socket.handle);
}
_result_string net__TcpConn_peer_ip(net__TcpConn* c) {
	_result_net__Addr _t1 = net__TcpConn_peer_addr(c);
	if (_t1.is_error) {
		_result_string _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	string address = net__Addr_str((*(net__Addr*)_t1.data));
	if (string_contains(address, _SLIT("]:"))) {
		string ip = string_all_after(string_all_before(address, _SLIT("]:")), _SLIT("["));
		_result_string _t3 = {0};
		_result_ok(&(string[]) { ip }, (_result*)(&_t3), sizeof(string));
		return _t3;
	}
	string ip = string_all_before(address, _SLIT(":"));
	_result_string _t4 = {0};
	_result_ok(&(string[]) { ip }, (_result*)(&_t4), sizeof(string));
	return _t4;
}
_result_net__Addr net__TcpConn_addr(net__TcpConn* c) {
	return net__Socket_address(&c->sock.Socket);
}
string net__TcpConn_str(net__TcpConn _v_toheap_c) {
net__TcpConn* c = HEAP(net__TcpConn, _v_toheap_c);
	string s = string_replace(string_replace(net__TcpSocket_str((*(c)).sock), _SLIT("\n"), _SLIT(" ")), _SLIT("  "), _SLIT(" "));
	return str_intp(6, _MOV((StrIntpData[]){{_SLIT("TcpConn{ write_deadline: "), 0xfe10, {.d_s = time__Time_str((*(c)).write_deadline)}}, {_SLIT(", read_deadline: "), 0xfe10, {.d_s = time__Time_str((*(c)).read_deadline)}}, {_SLIT(", read_timeout: "), 0xfe10, {.d_s = time__Duration_str((*(c)).read_timeout)}}, {_SLIT(", write_timeout: "), 0xfe10, {.d_s = time__Duration_str((*(c)).write_timeout)}}, {_SLIT(", sock: "), 0xfe10, {.d_s = s}}, {_SLIT(" }"), 0, { .d_c = 0 }}}));
}
__NOINLINE _result_net__TcpSocket net__new_tcp_socket(net__AddrFamily family) {
	int _t1;
	#if defined(CUSTOM_DEFINE_is_coroutine)
	#else
_result_int _t2 = net__socket_error(socket(family, net__SocketType__tcp, 0));
		if (_t2.is_error) {
			_result_net__TcpSocket _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 		_t1 = (*(int*)_t2.data);
		;
	#endif
		int handle = _t1;
	net__TcpSocket s = ((net__TcpSocket){.Socket = ((net__Socket){.handle = handle,}),});
	_result_void _t4 = net__TcpSocket_set_default_options(&s);
	if (_t4.is_error) {
		_result_net__TcpSocket _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 ;
	_result_net__TcpSocket _t6 = {0};
	_result_ok(&(net__TcpSocket[]) { s }, (_result*)(&_t6), sizeof(net__TcpSocket));
	return _t6;
}
net__TcpSocket net__tcp_socket_from_handle_raw(int sockfd) {
	net__TcpSocket s = ((net__TcpSocket){.Socket = ((net__Socket){.handle = sockfd,}),});
	return s;
}
VV_LOCAL_SYMBOL _result_void net__TcpSocket_set_option(net__TcpSocket* s, int level, int opt, int value) {
	_result_int _t1 = net__socket_error(setsockopt(s->Socket.handle, level, opt, &value, sizeof(int)));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
_result_void net__TcpSocket_set_option_int(net__TcpSocket* s, net__SocketOption opt, int value) {
	_result_void _t1 = net__TcpSocket_set_option(s, SOL_SOCKET, ((int)(opt)), value);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
VV_LOCAL_SYMBOL _result_void net__TcpSocket_set_default_options(net__TcpSocket* s) {
	_result_void _t1 = net__TcpSocket_set_option_int(s, net__SocketOption__reuse_addr, 1);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	_result_void _t3 = net__TcpSocket_set_option(s, IPPROTO_TCP, TCP_NODELAY, 1);
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	return (_result_void){0};
}
VV_LOCAL_SYMBOL _result_void net__TcpSocket_close(net__TcpSocket* s) {
	net__shutdown(s->Socket.handle, ((net__ShutdownConfig){.how = net__ShutdownDirection__read_and_write,}));
	return net__close(s->Socket.handle);
}
VV_LOCAL_SYMBOL _result_void net__TcpSocket_connect(net__TcpSocket* s, net__Addr a) {
	#if defined(CUSTOM_DEFINE_net_nonblocking_sockets)
	{
	}
	#else
	{
		int _t2;
		#if defined(CUSTOM_DEFINE_is_coroutine)
		#else
			_t2 = connect(s->Socket.handle, ((voidptr)(&a)), net__Addr_len(a));
			;
		#endif
				int x = _t2;
		_result_int _t3 = net__socket_error(x);
		if (_t3.is_error) {
			_result_void _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 ;
	}
	#endif
	return (_result_void){0};
}
_result_int net__UdpConn_write_ptr(net__UdpConn* c, u8* b, int len) {
	_option_net__Addr _t1 = net__UdpSocket_remote(&c->sock);
	if (_t1.state != 0) {
		IError err = _t1.err;
		return (_result_int){ .is_error=true, .err=_const_net__err_no_udp_remote, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	net__Addr remote = (*(net__Addr*)_t1.data);
	return net__UdpConn_write_to_ptr(c, remote, b, len);
}
_result_int net__UdpConn_write(net__UdpConn* c, Array_u8 buf) {
	return net__UdpConn_write_ptr(c, buf.data, buf.len);
}
_result_int net__UdpConn_write_to_ptr(net__UdpConn* c, net__Addr addr, u8* b, int len) {
	int res = sendto(c->sock.Socket.handle, b, len, 0, ((voidptr)(&addr)), net__Addr_len(addr));
	if (res >= 0) {
		_result_int _t1 = {0};
		_result_ok(&(int[]) { res }, (_result*)(&_t1), sizeof(int));
		return _t1;
	}
	int code = net__error_code();
	if (code == ((int)(_const_net__error_ewouldblock))) {
		_result_void _t2 = net__UdpConn_wait_for_write(c);
		if (_t2.is_error) {
			_result_int _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 ;
		_result_int _t4 = net__socket_error(sendto(c->sock.Socket.handle, b, len, 0, ((voidptr)(&addr)), net__Addr_len(addr)));
		if (_t4.is_error) {
			_result_int _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 ;
	} else {
		_result_void _t6 = net__wrap_error(code);
		if (_t6.is_error) {
			_result_int _t7;
			memcpy(&_t7, &_t6, sizeof(_result));
			return _t7;
		}
		
 ;
	}
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}
_result_time__Time net__UdpConn_write_deadline(net__UdpConn* c) {
	if (time__Time_unix(c->write_deadline) == 0) {
		_result_time__Time _t1 = {0};
		_result_ok(&(time__Time[]) { c->write_deadline }, (_result*)(&_t1), sizeof(time__Time));
		return _t1;
	}
	return (_result_time__Time){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}
time__Duration net__UdpConn_write_timeout(net__UdpConn* c) {
	return c->write_timeout;
}
inline _result_void net__UdpConn_wait_for_write(net__UdpConn* c) {
	return net__wait_for_write(c->sock.Socket.handle, c->write_deadline, c->write_timeout);
}
string net__UdpConn_str(net__UdpConn* c) {
	return _SLIT("UdpConn");
}
_option_net__Addr net__UdpSocket_remote(net__UdpSocket* s) {
	if (s->has_r) {
		_option_net__Addr _t1;
		_option_ok(&(net__Addr[]) { s->r }, (_option*)(&_t1), sizeof(net__Addr));
		return _t1;
	}
	return (_option_net__Addr){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}
_result_u16 net__validate_port(int port) {
	if (port >= 0 && port <= 0xFFFF) {
		_result_u16 _t1 = {0};
		_result_ok(&(u16[]) { ((u16)(port)) }, (_result*)(&_t1), sizeof(u16));
		return _t1;
	} else {
		return (_result_u16){ .is_error=true, .err=_const_net__err_port_out_of_range, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_u16){0};
}
_result_multi_return_string_u16 net__split_address(string addr) {
	_option_int _t1;
	_option_int _t2;
	_option_int _t3;
	if (_t1 = string_index(addr, _SLIT("]")), _t1.state == 0) {
		string address = string_all_before_last(string_all_after(addr, _SLIT("[")), _SLIT("]"));
		int port = string_int(string_all_after_last(addr, _SLIT("]:")));
		_result_u16 _t4 = net__validate_port(port);
		if (_t4.is_error) {
			_result_multi_return_string_u16 _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 		u16 p = (*(u16*)_t4.data);
		_result_multi_return_string_u16 _t6;
		_result_ok(&(multi_return_string_u16[]) { (multi_return_string_u16){.arg0=address, .arg1=p} }, (_result*)(&_t6), sizeof(multi_return_string_u16));
		return _t6;
	} else if (_t2 = string_index(addr, _SLIT("::")), _t2.state == 0) {
		if (string_count(addr, _SLIT(":")) == 2 && (string_all_before_last(addr, _SLIT("::"))).len == 0) {
			_result_multi_return_string_u16 _t7;
			_result_ok(&(multi_return_string_u16[]) { (multi_return_string_u16){.arg0=addr, .arg1=0} }, (_result*)(&_t7), sizeof(multi_return_string_u16));
			return _t7;
		} else {
			string address = string_all_before_last(addr, _SLIT(":"));
			int port = string_int(string_all_after_last(addr, _SLIT(":")));
			_result_u16 _t8 = net__validate_port(port);
			if (_t8.is_error) {
				_result_multi_return_string_u16 _t9;
				memcpy(&_t9, &_t8, sizeof(_result));
				return _t9;
			}
			
 			u16 p = (*(u16*)_t8.data);
			_result_multi_return_string_u16 _t10;
			_result_ok(&(multi_return_string_u16[]) { (multi_return_string_u16){.arg0=address, .arg1=p} }, (_result*)(&_t10), sizeof(multi_return_string_u16));
			return _t10;
		}
	} else if (_t3 = string_index(addr, _SLIT(":")), _t3.state == 0) {
		string address = string_all_before_last(addr, _SLIT(":"));
		_result_u16 _t11 = net__validate_port(string_int(string_all_after_last(addr, _SLIT(":"))));
		if (_t11.is_error) {
			_result_multi_return_string_u16 _t12;
			memcpy(&_t12, &_t11, sizeof(_result));
			return _t12;
		}
		
 		u16 p = (*(u16*)_t11.data);
		_result_multi_return_string_u16 _t13;
		_result_ok(&(multi_return_string_u16[]) { (multi_return_string_u16){.arg0=address, .arg1=p} }, (_result*)(&_t13), sizeof(multi_return_string_u16));
		return _t13;
	} else {
		IError err = _t3.err;
		_result_multi_return_string_u16 _t14;
		_result_ok(&(multi_return_string_u16[]) { (multi_return_string_u16){.arg0=addr, .arg1=0} }, (_result*)(&_t14), sizeof(multi_return_string_u16));
		return _t14;
	}
	return (_result_multi_return_string_u16){0};
}
#if !defined(CUSTOM_DEFINE_musl)
#endif
_result_picoev__EpollLoop_ptr picoev__create_epoll_loop(int id) {
	picoev__EpollLoop* loop = ((picoev__EpollLoop*)memdup(&(picoev__EpollLoop){.id = id,.epoll_fd = 0,.events = {{0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}},.now = 0,}, sizeof(picoev__EpollLoop)));
	loop->epoll_fd = epoll_create(_const_picoev__max_fds);
	if (loop->epoll_fd == -1) {
		return (_result_picoev__EpollLoop_ptr){ .is_error=true, .err=_v_error(_SLIT("could not create epoll loop!")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_picoev__EpollLoop_ptr _t2 = {0};
	_result_ok(&(picoev__EpollLoop*[]) { loop }, (_result*)(&_t2), sizeof(picoev__EpollLoop*));
	return _t2;
}
VV_LOCAL_SYMBOL int picoev__Picoev_update_events(picoev__Picoev* pv, int fd, int events) {
	// assert
	if (!(fd < 1024)) {
		VAssertMetaInfo v_assert_meta_info__t1 = {0};
		v_assert_meta_info__t1.fpath = _SLIT("/mnt/d/work/file/vlang/vlang/vlib/picoev/loop_linux.c.v");
		v_assert_meta_info__t1.line_nr = 56;
		v_assert_meta_info__t1.fn_name = _SLIT("update_events");
		v_assert_meta_info__t1.src = _SLIT("fd < 1024");
		v_assert_meta_info__t1.op = _SLIT("<");
		v_assert_meta_info__t1.llabel = _SLIT("fd");
		v_assert_meta_info__t1.rlabel = _SLIT("1024");
		v_assert_meta_info__t1.lvalue = string_clone(int_str(fd));
		v_assert_meta_info__t1.rvalue = string_clone(int_str(1024));
		v_assert_meta_info__t1.has_msg = false;
		v_assert_meta_info__t1.message = _SLIT0;
		__print_assert_failure(&v_assert_meta_info__t1);
		// TODO
		// Maybe print all vars in a test function if it fails?
		_v_panic(_SLIT("Assertion failed..."));
	}
	picoev__Target* target = pv->file_descriptors[fd];
	struct epoll_event ev = ((struct epoll_event){.events = 0,.data = {0},});
	if (_us32_ne(target->events,(events & 0x20000000)) && target->loop_id != pv->loop->id) {
		return -1;
	}
	if (_us32_eq(target->events,(events & 3))) {
		return 0;
	}
	ev.events = ((u32)(((((events & 1) != 0 ? (EPOLLIN) : (0))) | (((events & 2) != 0 ? (EPOLLOUT) : (0))))));
	ev.data.fd = fd;
	if ((events & 0x20000000) != 0) {
	} else if ((events & 3) == 0) {
		int epoll_ret = epoll_ctl(pv->loop->epoll_fd, EPOLL_CTL_DEL, fd, &ev);
		// assert
		if (!(epoll_ret == 0)) {
			VAssertMetaInfo v_assert_meta_info__t4 = {0};
			v_assert_meta_info__t4.fpath = _SLIT("/mnt/d/work/file/vlang/vlang/vlib/picoev/loop_linux.c.v");
			v_assert_meta_info__t4.line_nr = 86;
			v_assert_meta_info__t4.fn_name = _SLIT("update_events");
			v_assert_meta_info__t4.src = _SLIT("epoll_ret == 0");
			v_assert_meta_info__t4.op = _SLIT("==");
			v_assert_meta_info__t4.llabel = _SLIT("epoll_ret");
			v_assert_meta_info__t4.rlabel = _SLIT("0");
			v_assert_meta_info__t4.lvalue = string_clone(int_str(epoll_ret));
			v_assert_meta_info__t4.rvalue = string_clone(int_str(0));
			v_assert_meta_info__t4.has_msg = false;
			v_assert_meta_info__t4.message = _SLIT0;
			__print_assert_failure(&v_assert_meta_info__t4);
			// TODO
			// Maybe print all vars in a test function if it fails?
			_v_panic(_SLIT("Assertion failed..."));
		}
	} else {
		int epoll_ret = epoll_ctl(pv->loop->epoll_fd, EPOLL_CTL_MOD, fd, &ev);
		if (epoll_ret != 0) {
			// assert
			if (!(errno == ENOENT)) {
				VAssertMetaInfo v_assert_meta_info__t5 = {0};
				v_assert_meta_info__t5.fpath = _SLIT("/mnt/d/work/file/vlang/vlang/vlib/picoev/loop_linux.c.v");
				v_assert_meta_info__t5.line_nr = 92;
				v_assert_meta_info__t5.fn_name = _SLIT("update_events");
				v_assert_meta_info__t5.src = _SLIT("C.errno == C.ENOENT");
				v_assert_meta_info__t5.op = _SLIT("==");
				v_assert_meta_info__t5.llabel = _SLIT("C.errno");
				v_assert_meta_info__t5.rlabel = _SLIT("C.ENOENT");
				v_assert_meta_info__t5.lvalue = string_clone(int_str(errno));
				v_assert_meta_info__t5.rvalue = string_clone(int_str(ENOENT));
				v_assert_meta_info__t5.has_msg = false;
				v_assert_meta_info__t5.message = _SLIT0;
				__print_assert_failure(&v_assert_meta_info__t5);
				// TODO
				// Maybe print all vars in a test function if it fails?
				_v_panic(_SLIT("Assertion failed..."));
			}
			epoll_ret = epoll_ctl(pv->loop->epoll_fd, EPOLL_CTL_ADD, fd, &ev);
			// assert
			if (!(epoll_ret == 0)) {
				VAssertMetaInfo v_assert_meta_info__t6 = {0};
				v_assert_meta_info__t6.fpath = _SLIT("/mnt/d/work/file/vlang/vlang/vlib/picoev/loop_linux.c.v");
				v_assert_meta_info__t6.line_nr = 96;
				v_assert_meta_info__t6.fn_name = _SLIT("update_events");
				v_assert_meta_info__t6.src = _SLIT("epoll_ret == 0");
				v_assert_meta_info__t6.op = _SLIT("==");
				v_assert_meta_info__t6.llabel = _SLIT("epoll_ret");
				v_assert_meta_info__t6.rlabel = _SLIT("0");
				v_assert_meta_info__t6.lvalue = string_clone(int_str(epoll_ret));
				v_assert_meta_info__t6.rvalue = string_clone(int_str(0));
				v_assert_meta_info__t6.has_msg = false;
				v_assert_meta_info__t6.message = _SLIT0;
				__print_assert_failure(&v_assert_meta_info__t6);
				// TODO
				// Maybe print all vars in a test function if it fails?
				_v_panic(_SLIT("Assertion failed..."));
			}
		}
	}
	target->events = ((u32)(events));
	return 0;
}
VV_LOCAL_SYMBOL int picoev__Picoev_poll_once(picoev__Picoev* pv, int max_wait_in_sec) {
	int nevents = epoll_wait(pv->loop->epoll_fd, &pv->loop->events[0], _const_picoev__max_fds, (int)(max_wait_in_sec * 1000));
	if (nevents == -1) {
		return -1;
	}
	for (int i = 0; i < nevents; i++) {
		struct epoll_event event = pv->loop->events[i];
		picoev__Target* target = pv->file_descriptors[event.data.fd];
		{ // Unsafe block
			// assert
			if (!(event.data.fd < 1024)) {
				VAssertMetaInfo v_assert_meta_info__t2 = {0};
				v_assert_meta_info__t2.fpath = _SLIT("/mnt/d/work/file/vlang/vlang/vlib/picoev/loop_linux.c.v");
				v_assert_meta_info__t2.line_nr = 118;
				v_assert_meta_info__t2.fn_name = _SLIT("poll_once");
				v_assert_meta_info__t2.src = _SLIT("event.data.fd < 1024");
				v_assert_meta_info__t2.op = _SLIT("<");
				v_assert_meta_info__t2.llabel = _SLIT("event.data.fd");
				v_assert_meta_info__t2.rlabel = _SLIT("1024");
				v_assert_meta_info__t2.lvalue = string_clone(int_str(event.data.fd));
				v_assert_meta_info__t2.rvalue = string_clone(int_str(1024));
				v_assert_meta_info__t2.has_msg = false;
				v_assert_meta_info__t2.message = _SLIT0;
				__print_assert_failure(&v_assert_meta_info__t2);
				// TODO
				// Maybe print all vars in a test function if it fails?
				_v_panic(_SLIT("Assertion failed..."));
			}
		}
		if (pv->loop->id == target->loop_id && (target->events & 3U) != 0U) {
			int read_events = 0;
			if ((event.events & ((u32)(EPOLLIN))) != 0U) {
				read_events |= _const_picoev__picoev_read;
			}
			if ((event.events & ((u32)(EPOLLOUT))) != 0U) {
				read_events |= _const_picoev__picoev_write;
			}
			if (read_events != 0) {
				target->cb(event.data.fd, read_events, pv);
			}
		} else {
			event.events = 0U;
			epoll_ctl(pv->loop->epoll_fd, EPOLL_CTL_DEL, event.data.fd, &event);
		}
	}
	return 0;
}
void picoev__Picoev_init(picoev__Picoev* pv) {
	pv->num_loops = 0;
	for (int i = 0; i < _const_picoev__max_fds; ++i) {
		pv->file_descriptors[v_fixed_index(i, 4096)] = ((picoev__Target*)memdup(&(picoev__Target){.fd = 0,.loop_id = -1,.events = 0,.cb = ((void*)0),.backend = 0,}, sizeof(picoev__Target)));
	}
}
int picoev__Picoev_add(picoev__Picoev* pv, int fd, int events, int timeout, voidptr callback) {
	if (pv == ((void*)0) || fd < 0 || fd >= 1024) {
		return -1;
	}
	picoev__Target* target = pv->file_descriptors[fd];
	target->fd = fd;
	target->cb = (voidptr)callback;
	target->loop_id = pv->loop->id;
	target->events = 0U;
	if (picoev__Picoev_update_events(pv, fd, (events | 0x40000000)) != 0) {
		if (picoev__Picoev_delete(pv, fd) != 0) {
			;
		}
		return -1;
	}
	picoev__Picoev_set_timeout(pv, fd, timeout);
	return 0;
}
int picoev__Picoev_delete(picoev__Picoev* pv, int fd) {
	if (fd < 0 || fd >= 1024) {
		return -1;
	}
	picoev__Target* target = pv->file_descriptors[fd];
	;
	if (picoev__Picoev_update_events(pv, fd, _const_picoev__picoev_del) != 0) {
		;
		return -1;
	}
	picoev__Picoev_set_timeout(pv, fd, 0);
	target->loop_id = -1;
	target->fd = 0;
	target->cb = (voidptr)((void*)0);
	return 0;
}
VV_LOCAL_SYMBOL int picoev__Picoev_loop_once(picoev__Picoev* pv, int max_wait_in_sec) {
	pv->loop->now = picoev__get_time();
	if (picoev__Picoev_poll_once(pv, max_wait_in_sec) != 0) {
		;
		return -1;
	}
	if (max_wait_in_sec == 0) {
		return 0;
	}
	pv->loop->now = picoev__get_time();
	picoev__Picoev_handle_timeout(pv);
	return 0;
}
inline VV_LOCAL_SYMBOL void picoev__Picoev_set_timeout(picoev__Picoev* pv, int fd, int secs) {
	// assert
	if (!(fd < 1024)) {
		VAssertMetaInfo v_assert_meta_info__t1 = {0};
		v_assert_meta_info__t1.fpath = _SLIT("/mnt/d/work/file/vlang/vlang/vlib/picoev/picoev.v");
		v_assert_meta_info__t1.line_nr = 151;
		v_assert_meta_info__t1.fn_name = _SLIT("set_timeout");
		v_assert_meta_info__t1.src = _SLIT("fd < 1024");
		v_assert_meta_info__t1.op = _SLIT("<");
		v_assert_meta_info__t1.llabel = _SLIT("fd");
		v_assert_meta_info__t1.rlabel = _SLIT("1024");
		v_assert_meta_info__t1.lvalue = string_clone(int_str(fd));
		v_assert_meta_info__t1.rvalue = string_clone(int_str(1024));
		v_assert_meta_info__t1.has_msg = false;
		v_assert_meta_info__t1.message = _SLIT0;
		__print_assert_failure(&v_assert_meta_info__t1);
		// TODO
		// Maybe print all vars in a test function if it fails?
		_v_panic(_SLIT("Assertion failed..."));
	}
	if (secs == 0) {
		map_delete(&pv->timeouts, &(int[]){fd});
	} else {
		map_set(&pv->timeouts, &(int[]){fd}, &(i64[]) { (i64)(pv->loop->now + secs) });
	}
}
inline VV_LOCAL_SYMBOL void picoev__Picoev_handle_timeout(picoev__Picoev* pv) {
	Array_int to_remove = __new_array_with_default_noscan(0, 0, sizeof(int), 0);
	Map_int_i64 _t1 = pv->timeouts;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		int fd = *(int*)DenseArray_key(&_t1.key_values, _t2);
		i64 timeout = (*(i64*)DenseArray_value(&_t1.key_values, _t2));
		if (timeout <= pv->loop->now) {
			array_push_noscan((array*)&to_remove, _MOV((int[]){ fd }));
		}
	}
	for (int _t6 = 0; _t6 < to_remove.len; ++_t6) {
		int fd = ((int*)to_remove.data)[_t6];
		picoev__Target* target = pv->file_descriptors[fd];
		// assert
		if (!(target->loop_id == pv->loop->id)) {
			VAssertMetaInfo v_assert_meta_info__t7 = {0};
			v_assert_meta_info__t7.fpath = _SLIT("/mnt/d/work/file/vlang/vlang/vlib/picoev/picoev.v");
			v_assert_meta_info__t7.line_nr = 172;
			v_assert_meta_info__t7.fn_name = _SLIT("handle_timeout");
			v_assert_meta_info__t7.src = _SLIT("target.loop_id == pv.loop.id");
			v_assert_meta_info__t7.op = _SLIT("==");
			v_assert_meta_info__t7.llabel = _SLIT("target.loop_id");
			v_assert_meta_info__t7.rlabel = _SLIT("pv.loop.id");
			v_assert_meta_info__t7.lvalue = string_clone(int_str(target->loop_id));
			v_assert_meta_info__t7.rvalue = string_clone(int_str(pv->loop->id));
			v_assert_meta_info__t7.has_msg = false;
			v_assert_meta_info__t7.message = _SLIT0;
			__print_assert_failure(&v_assert_meta_info__t7);
			// TODO
			// Maybe print all vars in a test function if it fails?
			_v_panic(_SLIT("Assertion failed..."));
		}
		map_delete(&pv->timeouts, &(int[]){fd});
		target->cb(fd, _const_picoev__picoev_timeout, pv);
	}
}
VV_LOCAL_SYMBOL void picoev__accept_callback(int listen_fd, int events, voidptr cb_arg) {
	picoev__Picoev* pv = ((picoev__Picoev*)(cb_arg));
	int accepted_fd = picoev__accept(listen_fd);
	if (accepted_fd == -1) {
		if (picoev__fatal_socket_error(accepted_fd) == false) {
			return;
		}
		;
		return;
	}
	if (accepted_fd >= 1024) {
		;
		picoev__close_socket(accepted_fd);
		return;
	}
	;
	_result_void _t1 = picoev__setup_sock(accepted_fd);
	if (_t1.is_error) {
		IError err = _t1.err;
		;
		pv->error_callback(pv->user_data, ((picohttpparser__Request){.prev_len = 0,.method = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.headers = {(picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.num_headers = 0,.body = (string){.str=(byteptr)"", .is_lit=1},}), ((picohttpparser__Response*)memdup(&(picohttpparser__Response){.fd = 0,.date = ((void*)0),.buf_start = ((void*)0),.buf = ((void*)0),}, sizeof(picohttpparser__Response))), err);
		picoev__close_socket(accepted_fd);
		return;
	}
	
 ;
	picoev__Picoev_add(pv, accepted_fd, _const_picoev__picoev_read, pv->timeout_secs, picoev__raw_callback);
}
inline void picoev__Picoev_close_conn(picoev__Picoev* pv, int fd) {
	if (picoev__Picoev_delete(pv, fd) != 0) {
		;
	}
	picoev__close_socket(fd);
}
VV_LOCAL_SYMBOL void picoev__raw_callback(int fd, int events, voidptr context) {
	bool picoev__raw_callback_defer_0 = false;
	picoev__Picoev* pv;
	pv = ((picoev__Picoev*)(context));
	picoev__raw_callback_defer_0 = true;
	if ((events & 4) != 0) {
		;
		if (!isnil(pv->raw_callback)) {
			pv->raw_callback(pv, fd, events);
			// Defer begin
			if (picoev__raw_callback_defer_0) {
				pv->idx[fd] = 0;
			}
			// Defer end
			return;
		}
		picoev__Picoev_close_conn(pv, fd);
		// Defer begin
		if (picoev__raw_callback_defer_0) {
			pv->idx[fd] = 0;
		}
		// Defer end
		return;
	} else if ((events & 1) != 0) {
		picoev__Picoev_set_timeout(pv, fd, pv->timeout_secs);
		if (!isnil(pv->raw_callback)) {
			pv->raw_callback(pv, fd, events);
			// Defer begin
			if (picoev__raw_callback_defer_0) {
				pv->idx[fd] = 0;
			}
			// Defer end
			return;
		}
		u8* request_buffer = pv->buf;
		{ // Unsafe block
			request_buffer += (int)(fd * pv->max_read);
		}
		picohttpparser__Request req = ((picohttpparser__Request){.prev_len = 0,.method = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.headers = {(picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.num_headers = 0,.body = (string){.str=(byteptr)"", .is_lit=1},});
		u8* response_buffer = pv->out;
		{ // Unsafe block
			response_buffer += (int)(fd * pv->max_write);
		}
		picohttpparser__Response res = ((picohttpparser__Response){.fd = fd,.date = pv->date.str,.buf_start = response_buffer,.buf = response_buffer,});
		for (;;) {
			int r = picoev__req_read(fd, request_buffer, pv->max_read, pv->idx[fd]);
			if (r == 0) {
				picoev__Picoev_close_conn(pv, fd);
				// Defer begin
				if (picoev__raw_callback_defer_0) {
					pv->idx[fd] = 0;
				}
				// Defer end
				return;
			} else if (r == -1) {
				if (picoev__fatal_socket_error(fd) == false) {
					// Defer begin
					if (picoev__raw_callback_defer_0) {
						pv->idx[fd] = 0;
					}
					// Defer end
					return;
				}
				;
				picoev__Picoev_close_conn(pv, fd);
				// Defer begin
				if (picoev__raw_callback_defer_0) {
					pv->idx[fd] = 0;
				}
				// Defer end
				return;
			}
			pv->idx[fd] += r;
			string s = tos(request_buffer, pv->idx[fd]);
			_result_int _t1 = picohttpparser__Request_parse_request(&req, s);
			if (_t1.is_error) {
				IError err = _t1.err;
				pv->error_callback(pv->user_data, req, &res, err);
				// Defer begin
				if (picoev__raw_callback_defer_0) {
					pv->idx[fd] = 0;
				}
				// Defer end
				return;
			}
			
 			int pret = (*(int*)_t1.data);
			if (pret > 0) {
				break;
			}
			// assert
			if (!(pret == -2)) {
				VAssertMetaInfo v_assert_meta_info__t2 = {0};
				v_assert_meta_info__t2.fpath = _SLIT("/mnt/d/work/file/vlang/vlang/vlib/picoev/picoev.v");
				v_assert_meta_info__t2.line_nr = 278;
				v_assert_meta_info__t2.fn_name = _SLIT("picoev.raw_callback");
				v_assert_meta_info__t2.src = _SLIT("pret == -2");
				v_assert_meta_info__t2.op = _SLIT("==");
				v_assert_meta_info__t2.llabel = _SLIT("pret");
				v_assert_meta_info__t2.rlabel = _SLIT("-2");
				v_assert_meta_info__t2.lvalue = string_clone(int_str(pret));
				v_assert_meta_info__t2.rvalue = string_clone(int_str(-2));
				v_assert_meta_info__t2.has_msg = false;
				v_assert_meta_info__t2.message = _SLIT0;
				__print_assert_failure(&v_assert_meta_info__t2);
				// TODO
				// Maybe print all vars in a test function if it fails?
				_v_panic(_SLIT("Assertion failed..."));
			}
			if (_us32_eq(sizeof(u8*),pv->idx[fd])) {
				pv->error_callback(pv->user_data, req, &res, _v_error(_SLIT("RequestIsTooLongError")));
				// Defer begin
				if (picoev__raw_callback_defer_0) {
					pv->idx[fd] = 0;
				}
				// Defer end
				return;
			}
		}
		pv->cb(pv->user_data, req, &res);
	} else if ((events & 2) != 0) {
		picoev__Picoev_set_timeout(pv, fd, pv->timeout_secs);
		if (!isnil(pv->raw_callback)) {
			pv->raw_callback(pv, fd, events);
			// Defer begin
			if (picoev__raw_callback_defer_0) {
				pv->idx[fd] = 0;
			}
			// Defer end
			return;
		}
	}
// Defer begin
if (picoev__raw_callback_defer_0) {
	pv->idx[fd] = 0;
}
// Defer end
}
VV_LOCAL_SYMBOL void picoev__default_error_callback(voidptr data, picohttpparser__Request req, picohttpparser__Response* res, IError __v_error) {
	;
	picohttpparser__Response_end(res);
}
_result_picoev__Picoev_ptr picoev__new(picoev__Config config) {
	_result_int _t1 = picoev__listen(config);
	if (_t1.is_error) {
		IError err = _t1.err;
		;
		return (_result_picoev__Picoev_ptr){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int listening_socket_fd = (*(int*)_t1.data);
	picoev__Picoev* pv = ((picoev__Picoev*)memdup(&(picoev__Picoev){.cb = (voidptr)config.cb,
		.error_callback = (voidptr)config.err_cb,
		.raw_callback = (voidptr)config.raw_cb,
		.timeout_secs = config.timeout_secs,
		.max_headers = config.max_headers,
		.max_read = config.max_read,
		.max_write = config.max_write,
		.loop = ((void*)0),
		.file_descriptors = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
		.timeouts = new_map_noscan_key_value(sizeof(int), sizeof(i64), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
		.num_loops = 1,
		.buf = ((void*)0),
		.idx = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
		.out = ((void*)0),
		.date = (string){.str=(byteptr)"", .is_lit=1},
		.user_data = config.user_data,
	}, sizeof(picoev__Picoev)));
	if (isnil(pv->raw_callback)) {
		pv->buf = malloc_noscan((int)((int)(1024 * config.max_read) + 1));
		pv->out = malloc_noscan((int)((int)(1024 * config.max_write) + 1));
	}
	#if defined(__linux__) || defined(__TERMUX__)
	{
		_result_picoev__EpollLoop_ptr _t4 = picoev__create_epoll_loop(0);
		if (_t4.is_error) {
			IError err = _t4.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 		pv->loop = (*(picoev__EpollLoop**)_t4.data);
	}
	#elif defined(__FreeBSD__) || defined(__APPLE__)
	{
	}
	#else
	{
	}
	#endif
	if (pv->loop == ((void*)0)) {
		;
		picoev__close_socket(listening_socket_fd);
		_result_picoev__Picoev_ptr _t5 = {0};
		_result_ok(&(picoev__Picoev*[]) { ((void*)0) }, (_result*)(&_t5), sizeof(picoev__Picoev*));
		return _t5;
	}
	picoev__Picoev_init(pv);
	picoev__Picoev_add(pv, listening_socket_fd, _const_picoev__picoev_read, 0, picoev__accept_callback);
	_result_picoev__Picoev_ptr _t6 = {0};
	_result_ok(&(picoev__Picoev*[]) { pv }, (_result*)(&_t6), sizeof(picoev__Picoev*));
	return _t6;
}
void picoev__Picoev_serve(picoev__Picoev* pv) {
	// start go
	thread_arg_picoev__update_date_string *arg__t1 = (thread_arg_picoev__update_date_string *) _v_malloc(sizeof(thread_arg_picoev__update_date_string));
	arg__t1->fn = picoev__update_date_string;
	arg__t1->arg1 = pv;
	pthread_t thread__t1;
	pthread_attr_t thread__t1_attributes;
	pthread_attr_init(&thread__t1_attributes);
	pthread_attr_setstacksize(&thread__t1_attributes, 8388608); // fn: picoev.update_date_string
	int _t1_thr_res = pthread_create(&thread__t1, &thread__t1_attributes, (void*)picoev__update_date_string_thread_wrapper, arg__t1);
	if (_t1_thr_res) panic_error_number(tos3("`go picoev__update_date_string()`: "), _t1_thr_res);
	pthread_detach(thread__t1);
	// end go
	;
	for (;;) {
		picoev__Picoev_loop_once(pv, 1);
	}
}
VV_LOCAL_SYMBOL void picoev__update_date_string(picoev__Picoev* pv) {
	for (;;) {
		time__Time gmt = time__utc();
		pv->date = time__Time_http_header_string(gmt);
		time__sleep(_const_time__second);
	}
}
#if defined(_WIN32)
#elif defined(__FreeBSD__) || defined(__APPLE__)
#else
#endif
inline VV_LOCAL_SYMBOL i64 picoev__get_time(void) {
	return ((i64)(time(NULL)));
}
inline VV_LOCAL_SYMBOL int picoev__accept(int fd) {
	return accept(fd, 0, 0);
}
inline VV_LOCAL_SYMBOL void picoev__close_socket(int fd) {
	;
	#if defined(_WIN32)
	{
	}
	#else
	{
		close(fd);
	}
	#endif
}
inline VV_LOCAL_SYMBOL _result_void picoev__setup_sock(int fd) {
	int flag = 1;
	if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(int)) < 0) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("setup_sock.setup_sock failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#if defined(__FreeBSD__)
	{
	}
	#elif defined(_WIN32)
	{
	}
	#else
	{
		if (fcntl(fd, F_SETFL, O_NONBLOCK) != 0) {
			return (_result_void){ .is_error=true, .err=_v_error(_SLIT("fcntl failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#endif
	return (_result_void){0};
}
inline VV_LOCAL_SYMBOL int picoev__req_read(int fd, u8* buffer, int max_len, int offset) {
	return recv(fd, buffer + offset, (int)(max_len - offset), 0);
}
VV_LOCAL_SYMBOL bool picoev__fatal_socket_error(int fd) {
	if (errno == EAGAIN) {
		return false;
	}
	#if defined(_WIN32)
	{
	}
	#else
	{
		if (errno == EWOULDBLOCK) {
			return false;
		}
	}
	#endif
	;
	return true;
}
VV_LOCAL_SYMBOL _result_int picoev__listen(picoev__Config config) {
	int fd = socket(config.family, net__SocketType__tcp, 0);
	if (fd == -1) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("Failed to create socket")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	;
	int flag = 1;
	int flag_zero = 0;
	_result_int _t2 = net__socket_error(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(int)));
	if (_t2.is_error) {
		_result_int _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 ;
	if (config.family == net__AddrFamily__ip6) {
		_result_int _t4 = net__socket_error(setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &flag_zero, sizeof(int)));
		if (_t4.is_error) {
			_result_int _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 ;
	}
	#if defined(__linux__) || defined(__TERMUX__)
	{
		_result_int _t7 = net__socket_error(setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &flag, sizeof(int)));
		if (_t7.is_error) {
			_result_int _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
 ;
		_result_int _t9 = net__socket_error(setsockopt(fd, IPPROTO_TCP, TCP_QUICKACK, &flag, sizeof(int)));
		if (_t9.is_error) {
			_result_int _t10;
			memcpy(&_t10, &_t9, sizeof(_result));
			return _t10;
		}
		
 ;
		#if !defined(CUSTOM_DEFINE_support_wsl1)
		{
			_result_int _t12 = net__socket_error(setsockopt(fd, IPPROTO_TCP, TCP_DEFER_ACCEPT, &config.timeout_secs, sizeof(int)));
			if (_t12.is_error) {
				_result_int _t13;
				memcpy(&_t13, &_t12, sizeof(_result));
				return _t13;
			}
			
 ;
			int queue_len = _const_picoev__max_queue;
			_result_int _t14 = net__socket_error(setsockopt(fd, IPPROTO_TCP, TCP_FASTOPEN, &queue_len, sizeof(int)));
			if (_t14.is_error) {
				_result_int _t15;
				memcpy(&_t15, &_t14, sizeof(_result));
				return _t15;
			}
			
 ;
		}
		#endif
	}
	#endif
	string saddr = str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = config.host}}, {_SLIT(":"), 0xfe07, {.d_i32 = config.port}}, {_SLIT0, 0, { .d_c = 0 }}}));
	_result_Array_net__Addr _t16 = net__resolve_addrs(saddr, config.family, net__SocketType__tcp);
	if (_t16.is_error) {
		IError err = _t16.err;
		_v_panic(str_intp(3, _MOV((StrIntpData[]){{_SLIT("Error while resolving `"), 0xfe10, {.d_s = saddr}}, {_SLIT("`, err: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
 	Array_net__Addr addrs = (*(Array_net__Addr*)_t16.data);
	net__Addr addr = (*(net__Addr*)array_get(addrs, 0));
	u32 alen = net__Addr_len(addr);
	_result_int _t17 = net__socket_error_message(bind(fd, ((voidptr)(&addr)), alen), str_intp(2, _MOV((StrIntpData[]){{_SLIT("binding to "), 0xfe10, {.d_s = saddr}}, {_SLIT(" failed"), 0, { .d_c = 0 }}})));
	if (_t17.is_error) {
		_result_int _t18;
		memcpy(&_t18, &_t17, sizeof(_result));
		return _t18;
	}
	
 ;
	_result_int _t19 = net__socket_error_message(listen(fd, SOMAXCONN), str_intp(3, _MOV((StrIntpData[]){{_SLIT("listening on "), 0xfe10, {.d_s = saddr}}, {_SLIT(" with maximum backlog pending queue of "), 0xfe07, {.d_i32 = SOMAXCONN}}, {_SLIT(", failed"), 0, { .d_c = 0 }}})));
	if (_t19.is_error) {
		_result_int _t20;
		memcpy(&_t20, &_t19, sizeof(_result));
		return _t20;
	}
	
 ;
	_result_void _t21 = picoev__setup_sock(fd);
	if (_t21.is_error) {
		IError err = _t21.err;
		config.err_cb(config.user_data, ((picohttpparser__Request){.prev_len = 0,.method = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.headers = {(picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (picohttpparser__Header){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.num_headers = 0,.body = (string){.str=(byteptr)"", .is_lit=1},}), ((picohttpparser__Response*)memdup(&(picohttpparser__Response){.fd = 0,.date = ((void*)0),.buf_start = ((void*)0),.buf = ((void*)0),}, sizeof(picohttpparser__Response))), err);
	;
	}
	
 ;
	_result_int _t22 = {0};
	_result_ok(&(int[]) { fd }, (_result*)(&_t22), sizeof(int));
	return _t22;
}
VV_LOCAL_SYMBOL void net__mbedtls__init(void) {
	{ // Unsafe block
		mbedtls_ctr_drbg_init(&_const_net__mbedtls__ctr_drbg);
		mbedtls_entropy_init(&_const_net__mbedtls__entropy);
		int ret = mbedtls_ctr_drbg_seed(&_const_net__mbedtls__ctr_drbg, (voidptr)mbedtls_entropy_func, &_const_net__mbedtls__entropy, 0, 0);
		if (ret != 0) {
			mbedtls_ctr_drbg_free(&_const_net__mbedtls__ctr_drbg);
			_v_panic(str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to seed ssl context: "), 0xfe07, {.d_i32 = ret}}, {_SLIT0, 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
}
net__mbedtls__SSLCerts* net__mbedtls__new_sslcerts(void) {
	net__mbedtls__SSLCerts *certs = HEAP(net__mbedtls__SSLCerts, (((net__mbedtls__SSLCerts){EMPTY_STRUCT_INITIALIZATION})));
	mbedtls_x509_crt_init(&(*(certs)).cacert);
	mbedtls_x509_crt_init(&(*(certs)).client_cert);
	mbedtls_pk_init(&(*(certs)).client_key);
	return &(*(certs));
}
_result_net__mbedtls__SSLCerts_ptr net__mbedtls__new_sslcerts_in_memory(string verify, string cert, string cert_key) {
	net__mbedtls__SSLCerts* certs = net__mbedtls__new_sslcerts();
	if ((verify).len != 0) {
		int ret = mbedtls_x509_crt_parse(&certs->cacert, verify.str, (int)(verify.len + 1));
		if (ret != 0) {
			return (_result_net__mbedtls__SSLCerts_ptr){ .is_error=true, .err=error_with_code(_SLIT("mbedtls_x509_crt_parse error"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	if ((cert).len != 0) {
		int ret = mbedtls_x509_crt_parse(&certs->client_cert, cert.str, (int)(cert.len + 1));
		if (ret != 0) {
			return (_result_net__mbedtls__SSLCerts_ptr){ .is_error=true, .err=error_with_code(_SLIT("mbedtls_x509_crt_parse error"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	if ((cert_key).len != 0) {
		{ // Unsafe block
			int ret = mbedtls_pk_parse_key(&certs->client_key, cert_key.str, (int)(cert_key.len + 1), 0, 0, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
			if (ret != 0) {
				return (_result_net__mbedtls__SSLCerts_ptr){ .is_error=true, .err=error_with_code(_SLIT("v error"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	_result_net__mbedtls__SSLCerts_ptr _t4 = {0};
	_result_ok(&(net__mbedtls__SSLCerts*[]) { certs }, (_result*)(&_t4), sizeof(net__mbedtls__SSLCerts*));
	return _t4;
}
_result_net__mbedtls__SSLCerts_ptr net__mbedtls__new_sslcerts_from_file(string verify, string cert, string cert_key) {
	net__mbedtls__SSLCerts* certs = net__mbedtls__new_sslcerts();
	if ((verify).len != 0) {
		int ret = mbedtls_x509_crt_parse_file(&certs->cacert, ((char*)(verify.str)));
		if (ret != 0) {
			return (_result_net__mbedtls__SSLCerts_ptr){ .is_error=true, .err=error_with_code(_SLIT("mbedtls_x509_crt_parse error"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	if ((cert).len != 0) {
		int ret = mbedtls_x509_crt_parse_file(&certs->client_cert, ((char*)(cert.str)));
		if (ret != 0) {
			return (_result_net__mbedtls__SSLCerts_ptr){ .is_error=true, .err=error_with_code(_SLIT("mbedtls_x509_crt_parse error"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	if ((cert_key).len != 0) {
		{ // Unsafe block
			int ret = mbedtls_pk_parse_keyfile(&certs->client_key, ((char*)(cert_key.str)), 0, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
			if (ret != 0) {
				return (_result_net__mbedtls__SSLCerts_ptr){ .is_error=true, .err=error_with_code(_SLIT("v error"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	_result_net__mbedtls__SSLCerts_ptr _t4 = {0};
	_result_ok(&(net__mbedtls__SSLCerts*[]) { certs }, (_result*)(&_t4), sizeof(net__mbedtls__SSLCerts*));
	return _t4;
}
void net__mbedtls__SSLCerts_cleanup(net__mbedtls__SSLCerts* c) {
	mbedtls_x509_crt_free(&c->cacert);
	mbedtls_x509_crt_free(&c->client_cert);
	mbedtls_pk_free(&c->client_key);
}
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLListener_init(net__mbedtls__SSLListener* l) {
	_result_multi_return_string_u16 _t1 = net__split_address(l->saddr);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	multi_return_string_u16 mr_4417 = (*(multi_return_string_u16*)_t1.data);
	string lhost = mr_4417.arg0;
	u16 lport = mr_4417.arg1;
	if ((l->config.cert).len == 0 || (l->config.cert_key).len == 0) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("No certificate or key provided")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (l->config.validate && (l->config.verify).len == 0) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("No root CA provided")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	mbedtls_net_init(&l->server_fd);
	mbedtls_ssl_init(&l->ssl);
	mbedtls_ssl_config_init(&l->conf);
	mbedtls_ssl_conf_read_timeout(&l->conf, _const_net__mbedtls__mbedtls_server_read_timeout_ms);
	l->certs = ((net__mbedtls__SSLCerts*)memdup(&(net__mbedtls__SSLCerts){EMPTY_STRUCT_INITIALIZATION}, sizeof(net__mbedtls__SSLCerts)));
	mbedtls_x509_crt_init(&l->certs->client_cert);
	mbedtls_pk_init(&l->certs->client_key);
	mbedtls_ssl_conf_rng(&l->conf, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
	int ret = 0;
	if (l->config.in_memory_verification) {
		_result_net__mbedtls__SSLCerts_ptr _t5 = net__mbedtls__new_sslcerts_in_memory(l->config.verify, l->config.cert, l->config.cert_key);
		if (_t5.is_error) {
			IError err = _t5.err;
			return (_result_void){ .is_error=true, .err=_v_error(_SLIT("Cert failure")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		l->certs = (*(net__mbedtls__SSLCerts**)_t5.data);
	} else {
		_result_net__mbedtls__SSLCerts_ptr _t7 = net__mbedtls__new_sslcerts_from_file(l->config.verify, l->config.cert, l->config.cert_key);
		if (_t7.is_error) {
			IError err = _t7.err;
			return (_result_void){ .is_error=true, .err=_v_error(_SLIT("Cert failure")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		l->certs = (*(net__mbedtls__SSLCerts**)_t7.data);
	}
	if (l->config.validate) {
		mbedtls_ssl_conf_authmode(&l->conf, MBEDTLS_SSL_VERIFY_REQUIRED);
	}
	voidptr bind_ip = ((void*)0);
	if ((lhost).len != 0) {
		bind_ip = ((voidptr)(lhost.str));
	}
	string bind_port = u16_str(lport);
	ret = mbedtls_net_bind(&l->server_fd, bind_ip, ((voidptr)(bind_port.str)), MBEDTLS_NET_PROTO_TCP);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(str_intp(2, _MOV((StrIntpData[]){{_SLIT("can't bind to "), 0xfe10, {.d_s = l->saddr}}, {_SLIT0, 0, { .d_c = 0 }}})), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	ret = mbedtls_ssl_config_defaults(&l->conf, MBEDTLS_SSL_IS_SERVER, MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("can't to set config defaults"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	mbedtls_ssl_conf_ca_chain(&l->conf, &l->certs->cacert, ((void*)0));
	ret = mbedtls_ssl_conf_own_cert(&l->conf, &l->certs->client_cert, &l->certs->client_key);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("can't load certificate"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	ret = mbedtls_ssl_setup(&l->ssl, &l->conf);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("can't setup ssl"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_option_anon_fn_mut_net__mbedtls__ssllistener_string__result_net__mbedtls__SSLCerts _t13;
	if (_t13 = l->config.get_certificate, _t13.state == 0) {
		anon_fn_mut_net__mbedtls__ssllistener_string__result_net__mbedtls__SSLCerts get_cert_callback = *(anon_fn_mut_net__mbedtls__ssllistener_string__result_net__mbedtls__SSLCerts*)_t13.data;
		net__mbedtls__SSLListener_init_sni(l, (voidptr)get_cert_callback);
	}
	return (_result_void){0};
}
VV_LOCAL_SYMBOL void net__mbedtls__SSLListener_init_sni(net__mbedtls__SSLListener* l, _result_net__mbedtls__SSLCerts_ptr (*get_cert_callback)(net__mbedtls__SSLListener* , string )) {
	mbedtls_ssl_conf_sni(&l->conf, (voidptr)	__closure_create(anon_fn_2d57aea9634ebb26_voidptr_c__mbedtls_ssl_context_char_int__int_6734, (struct _V_anon_fn_2d57aea9634ebb26_voidptr_c__mbedtls_ssl_context_char_int__int_6734_Ctx*) memdup_uncollectable(&(struct _V_anon_fn_2d57aea9634ebb26_voidptr_c__mbedtls_ssl_context_char_int__int_6734_Ctx){.get_cert_callback = get_cert_callback,
		.l = l,
	}, sizeof(struct _V_anon_fn_2d57aea9634ebb26_voidptr_c__mbedtls_ssl_context_char_int__int_6734_Ctx))), &l->conf);
}
_result_net__mbedtls__SSLConn_ptr net__mbedtls__new_ssl_conn(net__mbedtls__SSLConnectConfig config) {
	net__mbedtls__SSLConn* conn = ((net__mbedtls__SSLConn*)memdup(&(net__mbedtls__SSLConn){.config = config,.server_fd = {0},.certs = ((void*)0),.handle = 0,.duration = 0,.opened = 0,.ip = (string){.str=(byteptr)"", .is_lit=1},.owns_socket = 0,}, sizeof(net__mbedtls__SSLConn)));
	_result_void _t1 = net__mbedtls__SSLConn_init(conn);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__mbedtls__SSLConn_ptr){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 ;
	_result_net__mbedtls__SSLConn_ptr _t3 = {0};
	_result_ok(&(net__mbedtls__SSLConn*[]) { conn }, (_result*)(&_t3), sizeof(net__mbedtls__SSLConn*));
	return _t3;
}
_result_void net__mbedtls__SSLConn_close(net__mbedtls__SSLConn* s) {
	_result_void _t1 = net__mbedtls__SSLConn_shutdown(s);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
_result_void net__mbedtls__SSLConn_shutdown(net__mbedtls__SSLConn* s) {
	if (!s->opened) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("ssl connection not open")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (s->certs != ((void*)0)) {
		mbedtls_x509_crt_free(&s->certs->cacert);
		mbedtls_x509_crt_free(&s->certs->client_cert);
		mbedtls_pk_free(&s->certs->client_key);
	}
	mbedtls_ssl_free(&s->ssl);
	mbedtls_ssl_config_free(&s->conf);
	if (s->owns_socket) {
		net__shutdown(s->handle, ((net__ShutdownConfig){.how = net__ShutdownDirection__read_and_write,}));
		_result_void _t2 = net__close(s->handle);
		if (_t2.is_error) {
			_result_void _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 ;
	}
	return (_result_void){0};
}
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_init(net__mbedtls__SSLConn* s) {
	mbedtls_net_init(&s->server_fd);
	mbedtls_ssl_init(&s->ssl);
	mbedtls_ssl_config_init(&s->conf);
	int ret = 0;
	ret = mbedtls_ssl_config_defaults(&s->conf, MBEDTLS_SSL_IS_CLIENT, MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to set SSL configuration"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	mbedtls_ssl_conf_read_timeout(&s->conf, _const_net__mbedtls__mbedtls_client_read_timeout_ms);
	mbedtls_ssl_conf_rng(&s->conf, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
	if ((s->config.verify).len != 0 || (s->config.cert).len != 0 || (s->config.cert_key).len != 0) {
		s->certs = ((net__mbedtls__SSLCerts*)memdup(&(net__mbedtls__SSLCerts){EMPTY_STRUCT_INITIALIZATION}, sizeof(net__mbedtls__SSLCerts)));
		mbedtls_x509_crt_init(&s->certs->cacert);
		mbedtls_x509_crt_init(&s->certs->client_cert);
		mbedtls_pk_init(&s->certs->client_key);
	}
	if (s->config.in_memory_verification) {
		if ((s->config.verify).len != 0) {
			ret = mbedtls_x509_crt_parse(&s->certs->cacert, s->config.verify.str, (int)(s->config.verify.len + 1));
		}
		if ((s->config.cert).len != 0) {
			ret = mbedtls_x509_crt_parse(&s->certs->client_cert, s->config.cert.str, (int)(s->config.cert.len + 1));
		}
		if ((s->config.cert_key).len != 0) {
			{ // Unsafe block
				ret = mbedtls_pk_parse_key(&s->certs->client_key, s->config.cert_key.str, (int)(s->config.cert_key.len + 1), 0, 0, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
			}
		}
	} else {
		if ((s->config.verify).len != 0) {
			ret = mbedtls_x509_crt_parse_file(&s->certs->cacert, ((char*)(s->config.verify.str)));
		}
		if ((s->config.cert).len != 0) {
			ret = mbedtls_x509_crt_parse_file(&s->certs->client_cert, ((char*)(s->config.cert.str)));
		}
		if ((s->config.cert_key).len != 0) {
			{ // Unsafe block
				ret = mbedtls_pk_parse_keyfile(&s->certs->client_key, ((char*)(s->config.cert_key.str)), 0, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
			}
		}
	}
	if (ret < 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to set certificates"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (s->certs != ((void*)0)) {
		mbedtls_ssl_conf_ca_chain(&s->conf, &s->certs->cacert, 0);
		mbedtls_ssl_conf_own_cert(&s->conf, &s->certs->client_cert, &s->certs->client_key);
	}
	if (s->config.validate) {
		mbedtls_ssl_conf_authmode(&s->conf, MBEDTLS_SSL_VERIFY_REQUIRED);
	} else {
		mbedtls_ssl_conf_authmode(&s->conf, MBEDTLS_SSL_VERIFY_OPTIONAL);
	}
	ret = mbedtls_ssl_setup(&s->ssl, &s->conf);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to setup SSL connection"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}
_result_void net__mbedtls__SSLConn_connect(net__mbedtls__SSLConn* s, net__TcpConn* tcp_conn, string hostname) {
	if (s->opened) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("ssl connection already open")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	s->handle = tcp_conn->sock.Socket.handle;
	s->duration = 30 * _const_time__second;
	int ret = mbedtls_ssl_set_hostname(&s->ssl, ((char*)(hostname.str)));
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to set hostname"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	s->server_fd.fd = s->handle;
	mbedtls_ssl_set_bio(&s->ssl, &s->server_fd, mbedtls_net_send, mbedtls_net_recv, mbedtls_net_recv_timeout);
	ret = mbedtls_ssl_handshake(&s->ssl);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("SSL handshake failed"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	s->opened = true;
	return (_result_void){0};
}
_result_void net__mbedtls__SSLConn_dial(net__mbedtls__SSLConn* s, string hostname, int port) {
	s->owns_socket = true;
	if (s->opened) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("ssl connection already open")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	s->duration = 30 * _const_time__second;
	int ret = mbedtls_ssl_set_hostname(&s->ssl, ((char*)(hostname.str)));
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to set hostname"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string port_str = int_str(port);
	ret = mbedtls_net_connect(&s->server_fd, ((char*)(hostname.str)), ((char*)(port_str.str)), MBEDTLS_NET_PROTO_TCP);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to connect to host"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	mbedtls_ssl_set_bio(&s->ssl, &s->server_fd, mbedtls_net_send, mbedtls_net_recv, mbedtls_net_recv_timeout);
	s->handle = s->server_fd.fd;
	ret = mbedtls_ssl_handshake(&s->ssl);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("SSL handshake failed"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	s->opened = true;
	return (_result_void){0};
}
_result_net__Addr net__mbedtls__SSLConn_addr(net__mbedtls__SSLConn* s) {
	_result_net__Addr _t1 = {0};
	_result_ok(&(net__Addr[]) { net__addr_from_socket_handle(s->handle) }, (_result*)(&_t1), sizeof(net__Addr));
	return _t1;
}
_result_net__Addr net__mbedtls__SSLConn_peer_addr(net__mbedtls__SSLConn* s) {
	return net__peer_addr_from_socket_handle(s->handle);
}
_result_int net__mbedtls__SSLConn_socket_read_into_ptr(net__mbedtls__SSLConn* s, u8* buf_ptr, int len) {
	int res = 0;
	time__Time deadline = time__Time_add(time__now(), s->duration);
	for (;;) {
		res = mbedtls_ssl_read(&s->ssl, buf_ptr, len);
		if (res > 0) {
			_result_int _t1 = {0};
			_result_ok(&(int[]) { res }, (_result*)(&_t1), sizeof(int));
			return _t1;
		} else if (res == 0) {
			return (_result_int){ .is_error=true, .err=I_io__Eof_to_Interface_IError(((io__Eof*)memdup(&(io__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(io__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		} else {

			if (res == (MBEDTLS_ERR_SSL_WANT_READ)) {
				_result_void _t3 = net__mbedtls__SSLConn_wait_for_read(s, time__Time__minus(deadline, time__now()));
				if (_t3.is_error) {
					IError err = _t3.err;
					return (_result_int){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 ;
			}
			else if (res == (MBEDTLS_ERR_SSL_WANT_WRITE)) {
				_result_void _t5 = net__mbedtls__SSLConn_wait_for_write(s, time__Time__minus(deadline, time__now()));
				if (_t5.is_error) {
					IError err = _t5.err;
					return (_result_int){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 ;
			}
			else if (res == (MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY)) {
				_result_int _t7 = {0};
				_result_ok(&(int[]) { 0 }, (_result*)(&_t7), sizeof(int));
				return _t7;
			}
			else {
				return (_result_int){ .is_error=true, .err=error_with_code(_SLIT("Could not read using SSL"), res), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("Unknown error")), .data={EMPTY_STRUCT_INITIALIZATION} };
}
_result_int net__mbedtls__SSLConn_read(net__mbedtls__SSLConn* s, Array_u8* buffer) {
	return net__mbedtls__SSLConn_socket_read_into_ptr(s, ((u8*)(buffer->data)), buffer->len);
}
_result_int net__mbedtls__SSLConn_write_ptr(net__mbedtls__SSLConn* s, u8* bytes, int len) {
	int total_sent = 0;
	time__Time deadline = time__Time_add(time__now(), s->duration);
	{ // Unsafe block
		u8* ptr_base = bytes;
		for (;;) {
			if (!(total_sent < len)) break;
			u8* ptr = ptr_base + total_sent;
			int remaining = (int)(len - total_sent);
			int sent = mbedtls_ssl_write(&s->ssl, ptr, remaining);
			if (sent <= 0) {

				if (sent == (MBEDTLS_ERR_SSL_WANT_READ)) {
					_result_void _t1 = net__mbedtls__SSLConn_wait_for_read(s, time__Time__minus(deadline, time__now()));
					if (_t1.is_error) {
						_result_int _t2;
						memcpy(&_t2, &_t1, sizeof(_result));
						return _t2;
					}
					
 ;
					continue;
				}
				else if (sent == (MBEDTLS_ERR_SSL_WANT_WRITE)) {
					_result_void _t3 = net__mbedtls__SSLConn_wait_for_write(s, time__Time__minus(deadline, time__now()));
					if (_t3.is_error) {
						_result_int _t4;
						memcpy(&_t4, &_t3, sizeof(_result));
						return _t4;
					}
					
 ;
					continue;
				}
				else {
					return (_result_int){ .is_error=true, .err=error_with_code(_SLIT("Could not write using SSL"), sent), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
			}
			total_sent += sent;
		}
	}
	_result_int _t6 = {0};
	_result_ok(&(int[]) { total_sent }, (_result*)(&_t6), sizeof(int));
	return _t6;
}
_result_int net__mbedtls__SSLConn_write(net__mbedtls__SSLConn* s, Array_u8 bytes) {
	return net__mbedtls__SSLConn_write_ptr(s, ((u8*)(bytes.data)), bytes.len);
}
_result_int net__mbedtls__SSLConn_write_string(net__mbedtls__SSLConn* s, string str) {
	return net__mbedtls__SSLConn_write_ptr(s, str.str, str.len);
}
VV_LOCAL_SYMBOL _result_bool net__mbedtls__select(int handle, net__mbedtls__Select test, time__Duration timeout) {
	fd_set set = ((fd_set){EMPTY_STRUCT_INITIALIZATION});
	FD_ZERO(&set);
	FD_SET(handle, &set);
	time__Time deadline = time__Time_add(time__now(), timeout);
	i64 remaining_time = time__Duration_milliseconds(timeout);
	for (;;) {
		if (!(remaining_time > 0)) break;
		i64 seconds = (i64)(remaining_time / 1000);
		i64 microseconds = (i64)(((i64)(remaining_time % 1000)) * 1000);
		struct timeval *tt = HEAP(struct timeval, (((struct timeval){.tv_sec = ((u64)(seconds)),.tv_usec = ((u64)(microseconds)),})));
		struct timeval* timeval_timeout = (timeout < 0 ? (((struct timeval*)(((void*)0)))) : (&(*(tt))));
		int res = -1;

		if (test == (net__mbedtls__Select__read)) {
			_result_int _t1 = net__socket_error(select((int)(handle + 1), &set, NULL, NULL, timeval_timeout));
			if (_t1.is_error) {
				_result_bool _t2;
				memcpy(&_t2, &_t1, sizeof(_result));
				return _t2;
			}
			
 			res = (*(int*)_t1.data);
		}
		else if (test == (net__mbedtls__Select__write)) {
			_result_int _t3 = net__socket_error(select((int)(handle + 1), NULL, &set, NULL, timeval_timeout));
			if (_t3.is_error) {
				_result_bool _t4;
				memcpy(&_t4, &_t3, sizeof(_result));
				return _t4;
			}
			
 			res = (*(int*)_t3.data);
		}
		else if (test == (net__mbedtls__Select__except)) {
			_result_int _t5 = net__socket_error(select((int)(handle + 1), NULL, NULL, &set, timeval_timeout));
			if (_t5.is_error) {
				_result_bool _t6;
				memcpy(&_t6, &_t5, sizeof(_result));
				return _t6;
			}
			
 			res = (*(int*)_t5.data);
		}
		if (res < 0) {
			if (errno == EINTR) {
				remaining_time = time__Duration_milliseconds((time__Time__minus(deadline, time__now())));
				continue;
			}
			return (_result_bool){ .is_error=true, .err=error_with_code(str_intp(2, _MOV((StrIntpData[]){{_SLIT("Select failed: "), 0xfe07, {.d_i32 = res}}, {_SLIT0, 0, { .d_c = 0 }}})), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
		} else if (res == 0) {
			return (_result_bool){ .is_error=true, .err=_const_net__err_timed_out, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		res = FD_ISSET(handle, &set);
		_result_bool _t9 = {0};
		_result_ok(&(bool[]) { res != 0 }, (_result*)(&_t9), sizeof(bool));
		return _t9;
	}
	return (_result_bool){ .is_error=true, .err=_const_net__err_timed_out, .data={EMPTY_STRUCT_INITIALIZATION} };
}
VV_LOCAL_SYMBOL _result_void net__mbedtls__wait_for(int handle, net__mbedtls__Select what, time__Duration timeout) {
	_result_bool _t1 = net__mbedtls__select(handle, what, timeout);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	bool ready = (*(bool*)_t1.data);
	if (ready) {
		return (_result_void){0};
	}
	return (_result_void){ .is_error=true, .err=_const_net__err_timed_out, .data={EMPTY_STRUCT_INITIALIZATION} };
}
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_wait_for_write(net__mbedtls__SSLConn* s, time__Duration timeout) {
	return net__mbedtls__wait_for(s->handle, net__mbedtls__Select__write, timeout);
}
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_wait_for_read(net__mbedtls__SSLConn* s, time__Duration timeout) {
	return net__mbedtls__wait_for(s->handle, net__mbedtls__Select__read, timeout);
}
_result_net__Connection net__ssl__SSLDialer_dial(net__ssl__SSLDialer d, string address) {
	_result_net__ssl__SSLConn_ptr _t2 = net__ssl__new_ssl_conn(d.config);
	if (_t2.is_error) {
		_result_net__Connection _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_net__Connection _t1 = {0};
	_result_ok(&(net__Connection[]) { I_net__ssl__SSLConn_to_Interface_net__Connection((*(net__ssl__SSLConn**)_t2.data)) }, (_result*)(&_t1), sizeof(net__Connection));
	return _t1;
}
_result_net__ssl__SSLConn_ptr net__ssl__new_ssl_conn(net__ssl__SSLConnectConfig config) {
	_result_net__mbedtls__SSLConn_ptr _t1 = net__mbedtls__new_ssl_conn(config.SSLConnectConfig);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__ssl__SSLConn_ptr){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	net__mbedtls__SSLConn* c = (*(net__mbedtls__SSLConn**)_t1.data);
	_result_net__ssl__SSLConn_ptr _t3 = {0};
	_result_ok(&(net__ssl__SSLConn*[]) { ((net__ssl__SSLConn*)memdup(&(net__ssl__SSLConn){.SSLConn = *c,}, sizeof(net__ssl__SSLConn))) }, (_result*)(&_t3), sizeof(net__ssl__SSLConn*));
	return _t3;
}
_result_net__Connection net__socks__SOCKS5Dialer_dial(net__socks__SOCKS5Dialer sd, string address) {
	_result_net__Connection _t1 = net__Dialer_name_table[sd.dialer._typ]._method_dial(sd.dialer._object, sd.proxy_address);
	if (_t1.is_error) {
		_result_net__Connection _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__Connection conn = (*(net__Connection*)_t1.data);
	_result_net__Connection _t4 = net__socks__handshake(&conn, address, sd.username, sd.password);
	if (_t4.is_error) {
		_result_net__Connection _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	_result_net__Connection _t3 = {0};
	_result_ok(&(net__Connection[]) { (*(net__Connection*)_t4.data) }, (_result*)(&_t3), sizeof(net__Connection));
	return _t3;
}
VV_LOCAL_SYMBOL _result_net__Connection net__socks__handshake(net__Connection* con, string host, string username, string password) {
	Array_u8 v = new_array_from_c_array_noscan(2, 2, sizeof(u8), _MOV((u8[2]){_const_net__socks__socks_version5, 1}));
	if (username.len > 0) {
		array_push_noscan((array*)&v, _MOV((u8[]){ _const_net__socks__auth_user_password }));
	} else {
		array_push_noscan((array*)&v, _MOV((u8[]){ _const_net__socks__no_auth }));
	}
	_result_int _t3 = net__Connection_name_table[con->_typ]._method_write(con->_object, v);
	if (_t3.is_error) {
		_result_net__Connection _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	Array_u8 bf = __new_array_with_default_noscan(2, 0, sizeof(u8), 0);
	_result_int _t5 = net__Connection_name_table[con->_typ]._method_read(con->_object, &bf);
	if (_t5.is_error) {
		_result_net__Connection _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 ;
	if ((*(u8*)array_get(bf, 0)) != _const_net__socks__socks_version5) {
		_result_void _t7 = net__Connection_name_table[con->_typ]._method_close(con->_object);
		if (_t7.is_error) {
			_result_net__Connection _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
 ;
		return (_result_net__Connection){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected protocol version "), 0xfe02, {.d_u8 = (*(u8*)array_get(bf, 0))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (username.len == 0) {
		if ((*(u8*)array_get(bf, 1)) != 0) {
			_result_void _t10 = net__Connection_name_table[con->_typ]._method_close(con->_object);
			if (_t10.is_error) {
				_result_net__Connection _t11;
				memcpy(&_t11, &_t10, sizeof(_result));
				return _t11;
			}
			
 ;
			return (_result_net__Connection){ .is_error=true, .err=_v_error(net__socks__reply((*(u8*)array_get(bf, 1)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	if (username.len > 0) {
		array_clear(&v);
		array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)(1)) }));
		array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)(username.len)) }));
		_PUSH_MANY_noscan(&v, (string_bytes(username)), _t15, Array_u8);
		array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)(password.len)) }));
		_PUSH_MANY_noscan(&v, (string_bytes(password)), _t17, Array_u8);
		_result_int _t18 = net__Connection_name_table[con->_typ]._method_write(con->_object, v);
		if (_t18.is_error) {
			_result_net__Connection _t19;
			memcpy(&_t19, &_t18, sizeof(_result));
			return _t19;
		}
		
 ;
		Array_u8 resp = __new_array_with_default_noscan(2, 0, sizeof(u8), 0);
		_result_int _t20 = net__Connection_name_table[con->_typ]._method_read(con->_object, &resp);
		if (_t20.is_error) {
			_result_net__Connection _t21;
			memcpy(&_t21, &_t20, sizeof(_result));
			return _t21;
		}
		
 ;
		if ((*(u8*)array_get(resp, 0)) != 1) {
			_result_void _t22 = net__Connection_name_table[con->_typ]._method_close(con->_object);
			if (_t22.is_error) {
				_result_net__Connection _t23;
				memcpy(&_t23, &_t22, sizeof(_result));
				return _t23;
			}
			
 ;
			return (_result_net__Connection){ .is_error=true, .err=_v_error(_SLIT("server does not support user/password version 1")), .data={EMPTY_STRUCT_INITIALIZATION} };
		} else if ((*(u8*)array_get(resp, 1)) != 0) {
			_result_void _t25 = net__Connection_name_table[con->_typ]._method_close(con->_object);
			if (_t25.is_error) {
				_result_net__Connection _t26;
				memcpy(&_t26, &_t25, sizeof(_result));
				return _t26;
			}
			
 ;
			return (_result_net__Connection){ .is_error=true, .err=_v_error(_SLIT("user/password login failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	array_clear(&v);
	v = new_array_from_c_array_noscan(3, 3, sizeof(u8), _MOV((u8[3]){_const_net__socks__socks_version5, 1, 0}));
	u64 port = string_u64(string_all_after_last(host, _SLIT(":")));
	if (port == 0U) {
		port = ((u64)(80U));
	}
	string address = string_all_before_last(host, _SLIT(":"));
	if (string_contains_only(address, _SLIT(".1234567890"))) {
		array_push_noscan((array*)&v, _MOV((u8[]){ _const_net__socks__addr_type_ipv4 }));
		_result_Array_u8 _t30 = net__socks__parse_ipv4(address);
		if (_t30.is_error) {
			_result_net__Connection _t31;
			memcpy(&_t31, &_t30, sizeof(_result));
			return _t31;
		}
		
 		_PUSH_MANY_noscan(&v, ((*(Array_u8*)_t30.data)), _t29, Array_u8);
	} else if (string_contains_only(address, _SLIT(":1234567890abcdf"))) {
	} else {
		if (address.len > 255) {
			return (_result_net__Connection){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = address}}, {_SLIT(" is too long"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		} else {
			array_push_noscan((array*)&v, _MOV((u8[]){ _const_net__socks__addr_type_fqdn }));
			array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)(address.len)) }));
			_PUSH_MANY_noscan(&v, (string_bytes(address)), _t35, Array_u8);
		}
	}
	array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)((port >> 8U))) }));
	array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)(port)) }));
	_result_int _t38 = net__Connection_name_table[con->_typ]._method_write(con->_object, v);
	if (_t38.is_error) {
		_result_net__Connection _t39;
		memcpy(&_t39, &_t38, sizeof(_result));
		return _t39;
	}
	
 ;
	Array_u8 bff = __new_array_with_default_noscan(v.len, 0, sizeof(u8), 0);
	_result_int _t40 = net__Connection_name_table[con->_typ]._method_read(con->_object, &bff);
	if (_t40.is_error) {
		_result_net__Connection _t41;
		memcpy(&_t41, &_t40, sizeof(_result));
		return _t41;
	}
	
 ;
	if ((*(u8*)array_get(bff, 1)) != 0) {
		_result_void _t42 = net__Connection_name_table[con->_typ]._method_close(con->_object);
		if (_t42.is_error) {
			_result_net__Connection _t43;
			memcpy(&_t43, &_t42, sizeof(_result));
			return _t43;
		}
		
 ;
		return (_result_net__Connection){ .is_error=true, .err=_v_error(net__socks__reply((*(u8*)array_get(bff, 1)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_net__Connection _t45 = {0};
	_result_ok(&(net__Connection[]) { *con }, (_result*)(&_t45), sizeof(net__Connection));
	return _t45;
}
VV_LOCAL_SYMBOL string net__socks__reply(u8 code) {
	switch (code) {
		case 0: {
				return _SLIT("succeeded");
		}
		case 1: {
				return _SLIT("general SOCKS server failure");
		}
		case 2: {
				return _SLIT("connection not allowed by ruleset");
		}
		case 3: {
				return _SLIT("network unreachable");
		}
		case 4: {
				return _SLIT("host unreachable");
		}
		case 5: {
				return _SLIT("connection refused");
		}
		case 6: {
				return _SLIT("TTL expired");
		}
		case 7: {
				return _SLIT("command not supported");
		}
		case 8: {
				return _SLIT("address type not supported");
		}
		default: {
				return str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown code: "), 0xfe02, {.d_u8 = code}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
	}
	
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOCAL_SYMBOL _result_Array_u8 net__socks__parse_ipv4(string addr) {
	Array_u8 ip = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
	Array_string _t1 = string_split(addr, _SLIT("."));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string part = ((string*)_t1.data)[_t2];
		array_push_noscan((array*)&ip, _MOV((u8[]){ string_u8(part) }));
	}
	_result_Array_u8 _t4 = {0};
	_result_ok(&(Array_u8[]) { ip }, (_result*)(&_t4), sizeof(Array_u8));
	return _t4;
}
Array_net__http__Cookie_ptr net__http__read_cookies(net__http__Header h, string filter) {
	Array_string lines = net__http__Header_values(h, net__http__CommonHeader__cookie);
	if (lines.len == 0) {
		return __new_array_with_default(0, 0, sizeof(net__http__Cookie*), 0);
	}
	Array_net__http__Cookie_ptr cookies = __new_array_with_default(0, 0, sizeof(net__http__Cookie*), 0);
	for (int _t2 = 0; _t2 < lines.len; ++_t2) {
		string line_ = ((string*)lines.data)[_t2];
		string line = string_trim_space(line_);
		string part = _SLIT("");
		for (;;) {
			if (!(line.len > 0)) break;
			int semicolon_position = string_index_any(line, _SLIT(";"));
			if (semicolon_position > 0) {
				Array_string line_parts = string_split(string_substr(line, 0, semicolon_position), _SLIT(";"));
				line = string_substr(line, ((int)(semicolon_position + 1)), 2147483647);
				part = (*(string*)array_get(line_parts, 0));
			} else {
				part = line;
				line = _SLIT("");
			}
			part = string_trim_space(part);
			if (part.len == 0) {
				continue;
			}
			_option_multi_return_string_string _t3 = string_split_once(part, _SLIT("="));
			if (_t3.state != 0) {
				IError err = _t3.err;
				*(multi_return_string_string*) _t3.data = (multi_return_string_string){.arg0=part,.arg1=_SLIT("")};
			}
			
 			multi_return_string_string mr_2293 = (*(multi_return_string_string*)_t3.data);
			string name = mr_2293.arg0;
			string val = mr_2293.arg1;
			if (!net__http__is_cookie_name_valid(name)) {
				continue;
			}
			if ((filter).len != 0 && !string__eq(filter, name)) {
				continue;
			}
			_result_string _t4 = net__http__parse_cookie_value(val, true);
			if (_t4.is_error) {
				IError err = _t4.err;
				continue;
			}
			
 			val = (*(string*)_t4.data);
			array_push((array*)&cookies, _MOV((net__http__Cookie*[]){ ((net__http__Cookie*)memdup(&(net__http__Cookie){.name = name,.value = val,.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}, sizeof(net__http__Cookie))) }));
		}
	}
	return cookies;
}
string net__http__Cookie_str(net__http__Cookie* c) {
	if (!net__http__is_cookie_name_valid(c->name)) {
		return _SLIT("");
	}
	int extra_cookie_length = 110;
	strings__Builder b = strings__new_builder((int)((int)((int)((int)(c->name.len + c->value.len) + c->domain.len) + c->path.len) + extra_cookie_length));
	strings__Builder_write_string(&b, c->name);
	strings__Builder_write_string(&b, _SLIT("="));
	strings__Builder_write_string(&b, net__http__sanitize_cookie_value(c->value));
	if (c->path.len > 0) {
		strings__Builder_write_string(&b, _SLIT("; path="));
		strings__Builder_write_string(&b, net__http__sanitize_cookie_path(c->path));
	}
	if (c->domain.len > 0) {
		if (net__http__valid_cookie_domain(c->domain)) {
			string d = c->domain;
			if (string_at(d, 0) == '.') {
				d = string_substr(d, 1, d.len);
			}
			strings__Builder_write_string(&b, _SLIT("; domain="));
			strings__Builder_write_string(&b, d);
		} else {
		}
	}
	if (c->expires.year > 1600) {
		string time_str = time__Time_http_header_string(c->expires);
		strings__Builder_write_string(&b, _SLIT("; expires="));
		strings__Builder_write_string(&b, time_str);
	}
	if (c->max_age > 0) {
		strings__Builder_write_string(&b, _SLIT("; Max-Age="));
		strings__Builder_write_string(&b, int_str(c->max_age));
	} else if (c->max_age < 0) {
		strings__Builder_write_string(&b, _SLIT("; Max-Age=0"));
	}
	if (c->http_only) {
		strings__Builder_write_string(&b, _SLIT("; HttpOnly"));
	}
	if (c->secure) {
		strings__Builder_write_string(&b, _SLIT("; Secure"));
	}

	if (c->same_site == (net__http__SameSite__same_site_not_set)) {
	}
	else if (c->same_site == (net__http__SameSite__same_site_default_mode)) {
		strings__Builder_write_string(&b, _SLIT("; SameSite"));
	}
	else if (c->same_site == (net__http__SameSite__same_site_none_mode)) {
		strings__Builder_write_string(&b, _SLIT("; SameSite=None"));
	}
	else if (c->same_site == (net__http__SameSite__same_site_lax_mode)) {
		strings__Builder_write_string(&b, _SLIT("; SameSite=Lax"));
	}
	else if (c->same_site == (net__http__SameSite__same_site_strict_mode)) {
		strings__Builder_write_string(&b, _SLIT("; SameSite=Strict"));
	}
	return strings__Builder_str(&b);
}
VV_LOCAL_SYMBOL string net__http__sanitize(bool (*valid)(u8 ), string v) {
	bool ok = true;
	for (int i = 0; i < v.len; ++i) {
		if (valid(string_at(v, i))) {
			continue;
		}
		ok = false;
		break;
	}
	if (ok) {
		return string_clone(v);
	}
	Array_u8 _t3 = {0};
	Array_u8 _t3_orig = string_bytes(v);
	int _t3_len = _t3_orig.len;
	_t3 = __new_array_noscan(0, _t3_len, sizeof(u8));

	for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
		u8 it = ((u8*) _t3_orig.data)[_t4];
		if (valid(it)) {
			array_push_noscan((array*)&_t3, &it);
		}
	}
	return Array_u8_bytestr( _t3);
}
string net__http__sanitize_cookie_value(string v) {
	string val = net__http__sanitize((voidptr)net__http__valid_cookie_value_byte, v);
	if (v.len == 0) {
		return v;
	}
	if (string_starts_with(val, _SLIT(" ")) || string_ends_with(val, _SLIT(" ")) || string_starts_with(val, _SLIT(",")) || string_ends_with(val, _SLIT(","))) {
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), 0xfe10, {.d_s = v}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
	}
	return v;
}
VV_LOCAL_SYMBOL string net__http__sanitize_cookie_path(string v) {
	return net__http__sanitize((voidptr)net__http__valid_cookie_path_byte, v);
}
VV_LOCAL_SYMBOL bool net__http__valid_cookie_value_byte(u8 b) {
	return 0x20 <= b && b < 0x7f && b != '"' && b != ';' && b != '\\';
}
VV_LOCAL_SYMBOL bool net__http__valid_cookie_path_byte(u8 b) {
	return 0x20 <= b && b < 0x7f && b != '!';
}
VV_LOCAL_SYMBOL bool net__http__valid_cookie_domain(string v) {
	if (net__http__is_cookie_domain_name(v)) {
		return true;
	}
	return false;
}
bool net__http__is_cookie_domain_name(string _s) {
	string s = _s;
	if (s.len == 0) {
		return false;
	}
	if (s.len > 255) {
		return false;
	}
	if (string_at(s, 0) == '.') {
		s = string_substr(s, 1, s.len);
	}
	rune last = '.';
	bool ok = false;
	int part_len = 0;
	for (int i = 0; i < s.len; ++i) {
		u8 c = string_at(s, i);
		if (u8_is_letter(c)) {
			ok = true;
			part_len++;
		} else if ('0' <= c && c <= '9') {
			part_len++;
		} else if (c == '-') {
			if (last == '.') {
				return false;
			}
			part_len++;
		} else if (c == '.') {
			if (last == '.' || last == '-') {
				return false;
			}
			if (part_len > 63 || part_len == 0) {
				return false;
			}
			part_len = 0;
		} else {
			return false;
		}
		last = c;
	}
	if (last == '-' || part_len > 63) {
		return false;
	}
	return ok;
}
VV_LOCAL_SYMBOL _result_string net__http__parse_cookie_value(string _raw, bool allow_double_quote) {
	string raw = _raw;
	if (allow_double_quote && raw.len > 1 && string_at(raw, 0) == '"' && string_at(raw, (int)(raw.len - 1)) == '"') {
		raw = string_substr(raw, 1, (int)(raw.len - 1));
	}
	for (int i = 0; i < raw.len; ++i) {
		if (!net__http__valid_cookie_value_byte(string_at(raw, i))) {
			return (_result_string){ .is_error=true, .err=_v_error(_SLIT("http.cookie: invalid cookie value")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	_result_string _t2 = {0};
	_result_ok(&(string[]) { raw }, (_result*)(&_t2), sizeof(string));
	return _t2;
}
VV_LOCAL_SYMBOL bool net__http__is_cookie_name_valid(string name) {
	if ((name).len == 0) {
		return false;
	}
	for (int _t2 = 0; _t2 < name.len; ++_t2) {
		u8 b = name.str[_t2];
		if (b < 33 || b > 126) {
			return false;
		}
	}
	return true;
}
_result_void net__http__SilentStreamingDownloader_on_start(net__http__SilentStreamingDownloader* d, net__http__Request* request, string path) {
	d->path = path;
	_result_os__File _t1 = os__create(path);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	d->f = (*(os__File*)_t1.data);
	return (_result_void){0};
}
_result_void net__http__SilentStreamingDownloader_on_chunk(net__http__SilentStreamingDownloader* d, net__http__Request* request, Array_u8 chunk, u64 already_received, u64 expected) {
	_result_int _t1 = os__File_write(&d->f, chunk);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
_result_void net__http__SilentStreamingDownloader_on_finish(net__http__SilentStreamingDownloader* d, net__http__Request* request, net__http__Response* response) {
	os__File_close(&d->f);
	return (_result_void){0};
}
_result_void net__http__TerminalStreamingDownloader_on_start(net__http__TerminalStreamingDownloader* d, net__http__Request* request, string path) {
	_result_void _t1 = net__http__SilentStreamingDownloader_on_start(&d->SilentStreamingDownloader, request, path);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	d->start_time = time__now();
	d->past_time = time__now();
	return (_result_void){0};
}
_result_void net__http__TerminalStreamingDownloader_on_chunk(net__http__TerminalStreamingDownloader* d, net__http__Request* request, Array_u8 chunk, u64 already_received, u64 expected) {
	time__Time now = time__now();
	time__Duration elapsed = time__Time__minus(now, d->start_time);
	d->past_time = now;
	d->past_received = already_received;
	f64 ratio = (f64)(((f64)(already_received)) / ((f64)(expected)));
	f64 res = (f64)(((f64)(elapsed)) / ratio);
	time__Duration estimated = ((_const_max_i64));
	if (((f64)(_const_min_i64)) < res && res < ((f64)(_const_max_i64))) {
		estimated = ((i64)(res));
	}
	f64 speed = (f64)((f64)(((f64)(_const_time__millisecond)) * ((f64)(already_received))) / ((f64)(elapsed)));
	f64 elapsed_s = time__Duration_seconds(elapsed);
	f64 estimated_s = time__Duration_seconds(estimated);
	f64 eta_s = f64_max((f64)(estimated_s - elapsed_s), 0.0);
	_result_void _t1 = net__http__SilentStreamingDownloader_on_chunk(&d->SilentStreamingDownloader, request, chunk, already_received, expected);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	print(str_intp(8, _MOV((StrIntpData[]){{_SLIT("\rDownloading to `"), 0xfe10, {.d_s = d->SilentStreamingDownloader.path}}, {_SLIT("` "), 0xc042d, {.d_f64 = (f64)(((f64)(100.0)) * ratio)}}, {_SLIT("%, "), 0xe062d, {.d_f64 = (f64)(((f64)(already_received)) / ((int_literal)(1024 * 1024)))}}, {_SLIT("/"), 0xe060d, {.d_f64 = (f64)(((f64)(expected)) / ((int_literal)(1024 * 1024)))}}, {_SLIT("MB, "), 0xc002d, {.d_f64 = speed}}, {_SLIT("KB/s, elapsed: "), 0xc002d, {.d_f64 = elapsed_s}}, {_SLIT("s, eta: "), 0xc002d, {.d_f64 = eta_s}}, {_SLIT("s"), 0, { .d_c = 0 }}})));
	flush_stdout();
	return (_result_void){0};
}
_result_void net__http__TerminalStreamingDownloader_on_finish(net__http__TerminalStreamingDownloader* d, net__http__Request* request, net__http__Response* response) {
	_result_void _t1 = net__http__SilentStreamingDownloader_on_finish(&d->SilentStreamingDownloader, request, response);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	println(_SLIT(""));
	flush_stdout();
	return (_result_void){0};
}
string net__http__CommonHeader_str(net__http__CommonHeader h) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (h) {
		case net__http__CommonHeader__accept: {
				_t2 = _SLIT("Accept");
				break;
		}
		case net__http__CommonHeader__accept_ch: {
				_t2 = _SLIT("Accept-CH");
				break;
		}
		case net__http__CommonHeader__accept_charset: {
				_t2 = _SLIT("Accept-Charset");
				break;
		}
		case net__http__CommonHeader__accept_ch_lifetime: {
				_t2 = _SLIT("Accept-CH-Lifetime");
				break;
		}
		case net__http__CommonHeader__accept_encoding: {
				_t2 = _SLIT("Accept-Encoding");
				break;
		}
		case net__http__CommonHeader__accept_language: {
				_t2 = _SLIT("Accept-Language");
				break;
		}
		case net__http__CommonHeader__accept_patch: {
				_t2 = _SLIT("Accept-Patch");
				break;
		}
		case net__http__CommonHeader__accept_post: {
				_t2 = _SLIT("Accept-Post");
				break;
		}
		case net__http__CommonHeader__accept_ranges: {
				_t2 = _SLIT("Accept-Ranges");
				break;
		}
		case net__http__CommonHeader__access_control_allow_credentials: {
				_t2 = _SLIT("Access-Control-Allow-Credentials");
				break;
		}
		case net__http__CommonHeader__access_control_allow_headers: {
				_t2 = _SLIT("Access-Control-Allow-Headers");
				break;
		}
		case net__http__CommonHeader__access_control_allow_methods: {
				_t2 = _SLIT("Access-Control-Allow-Methods");
				break;
		}
		case net__http__CommonHeader__access_control_allow_origin: {
				_t2 = _SLIT("Access-Control-Allow-Origin");
				break;
		}
		case net__http__CommonHeader__access_control_expose_headers: {
				_t2 = _SLIT("Access-Control-Expose-Headers");
				break;
		}
		case net__http__CommonHeader__access_control_max_age: {
				_t2 = _SLIT("Access-Control-Max-Age");
				break;
		}
		case net__http__CommonHeader__access_control_request_headers: {
				_t2 = _SLIT("Access-Control-Request-Headers");
				break;
		}
		case net__http__CommonHeader__access_control_request_method: {
				_t2 = _SLIT("Access-Control-Request-Method");
				break;
		}
		case net__http__CommonHeader__age: {
				_t2 = _SLIT("Age");
				break;
		}
		case net__http__CommonHeader__allow: {
				_t2 = _SLIT("Allow");
				break;
		}
		case net__http__CommonHeader__alt_svc: {
				_t2 = _SLIT("Alt-Svc");
				break;
		}
		case net__http__CommonHeader__authorization: {
				_t2 = _SLIT("Authorization");
				break;
		}
		case net__http__CommonHeader__authority: {
				_t2 = _SLIT("Authority");
				break;
		}
		case net__http__CommonHeader__cache_control: {
				_t2 = _SLIT("Cache-Control");
				break;
		}
		case net__http__CommonHeader__clear_site_data: {
				_t2 = _SLIT("Clear-Site-Data");
				break;
		}
		case net__http__CommonHeader__connection: {
				_t2 = _SLIT("Connection");
				break;
		}
		case net__http__CommonHeader__content_disposition: {
				_t2 = _SLIT("Content-Disposition");
				break;
		}
		case net__http__CommonHeader__content_encoding: {
				_t2 = _SLIT("Content-Encoding");
				break;
		}
		case net__http__CommonHeader__content_language: {
				_t2 = _SLIT("Content-Language");
				break;
		}
		case net__http__CommonHeader__content_length: {
				_t2 = _SLIT("Content-Length");
				break;
		}
		case net__http__CommonHeader__content_location: {
				_t2 = _SLIT("Content-Location");
				break;
		}
		case net__http__CommonHeader__content_range: {
				_t2 = _SLIT("Content-Range");
				break;
		}
		case net__http__CommonHeader__content_security_policy: {
				_t2 = _SLIT("Content-Security-Policy");
				break;
		}
		case net__http__CommonHeader__content_security_policy_report_only: {
				_t2 = _SLIT("Content-Security-Policy-Report-Only");
				break;
		}
		case net__http__CommonHeader__content_type: {
				_t2 = _SLIT("Content-Type");
				break;
		}
		case net__http__CommonHeader__cookie: {
				_t2 = _SLIT("Cookie");
				break;
		}
		case net__http__CommonHeader__cross_origin_embedder_policy: {
				_t2 = _SLIT("Cross-Origin-Embedder-Policy");
				break;
		}
		case net__http__CommonHeader__cross_origin_opener_policy: {
				_t2 = _SLIT("Cross-Origin-Opener-Policy");
				break;
		}
		case net__http__CommonHeader__cross_origin_resource_policy: {
				_t2 = _SLIT("Cross-Origin-Resource-Policy");
				break;
		}
		case net__http__CommonHeader__date: {
				_t2 = _SLIT("Date");
				break;
		}
		case net__http__CommonHeader__device_memory: {
				_t2 = _SLIT("Device-Memory");
				break;
		}
		case net__http__CommonHeader__digest: {
				_t2 = _SLIT("Digest");
				break;
		}
		case net__http__CommonHeader__dnt: {
				_t2 = _SLIT("DNT");
				break;
		}
		case net__http__CommonHeader__early_data: {
				_t2 = _SLIT("Early-Data");
				break;
		}
		case net__http__CommonHeader__etag: {
				_t2 = _SLIT("ETag");
				break;
		}
		case net__http__CommonHeader__expect: {
				_t2 = _SLIT("Expect");
				break;
		}
		case net__http__CommonHeader__expect_ct: {
				_t2 = _SLIT("Expect-CT");
				break;
		}
		case net__http__CommonHeader__expires: {
				_t2 = _SLIT("Expires");
				break;
		}
		case net__http__CommonHeader__feature_policy: {
				_t2 = _SLIT("Feature-Policy");
				break;
		}
		case net__http__CommonHeader__forwarded: {
				_t2 = _SLIT("Forwarded");
				break;
		}
		case net__http__CommonHeader__from: {
				_t2 = _SLIT("From");
				break;
		}
		case net__http__CommonHeader__host: {
				_t2 = _SLIT("Host");
				break;
		}
		case net__http__CommonHeader__if_match: {
				_t2 = _SLIT("If-Match");
				break;
		}
		case net__http__CommonHeader__if_modified_since: {
				_t2 = _SLIT("If-Modified-Since");
				break;
		}
		case net__http__CommonHeader__if_none_match: {
				_t2 = _SLIT("If-None-Match");
				break;
		}
		case net__http__CommonHeader__if_range: {
				_t2 = _SLIT("If-Range");
				break;
		}
		case net__http__CommonHeader__if_unmodified_since: {
				_t2 = _SLIT("If-Unmodified-Since");
				break;
		}
		case net__http__CommonHeader__index: {
				_t2 = _SLIT("Index");
				break;
		}
		case net__http__CommonHeader__keep_alive: {
				_t2 = _SLIT("Keep-Alive");
				break;
		}
		case net__http__CommonHeader__large_allocation: {
				_t2 = _SLIT("Large-Allocation");
				break;
		}
		case net__http__CommonHeader__last_modified: {
				_t2 = _SLIT("Last-Modified");
				break;
		}
		case net__http__CommonHeader__link: {
				_t2 = _SLIT("Link");
				break;
		}
		case net__http__CommonHeader__location: {
				_t2 = _SLIT("Location");
				break;
		}
		case net__http__CommonHeader__nel: {
				_t2 = _SLIT("NEL");
				break;
		}
		case net__http__CommonHeader__origin: {
				_t2 = _SLIT("Origin");
				break;
		}
		case net__http__CommonHeader__pragma: {
				_t2 = _SLIT("Pragma");
				break;
		}
		case net__http__CommonHeader__proxy_authenticate: {
				_t2 = _SLIT("Proxy-Authenticate");
				break;
		}
		case net__http__CommonHeader__proxy_authorization: {
				_t2 = _SLIT("Proxy-Authorization");
				break;
		}
		case net__http__CommonHeader__range: {
				_t2 = _SLIT("Range");
				break;
		}
		case net__http__CommonHeader__referer: {
				_t2 = _SLIT("Referer");
				break;
		}
		case net__http__CommonHeader__referrer_policy: {
				_t2 = _SLIT("Referrer-Policy");
				break;
		}
		case net__http__CommonHeader__retry_after: {
				_t2 = _SLIT("Retry-After");
				break;
		}
		case net__http__CommonHeader__save_data: {
				_t2 = _SLIT("Save-Data");
				break;
		}
		case net__http__CommonHeader__sec_fetch_dest: {
				_t2 = _SLIT("Sec-Fetch-Dest");
				break;
		}
		case net__http__CommonHeader__sec_fetch_mode: {
				_t2 = _SLIT("Sec-Fetch-Mode");
				break;
		}
		case net__http__CommonHeader__sec_fetch_site: {
				_t2 = _SLIT("Sec-Fetch-Site");
				break;
		}
		case net__http__CommonHeader__sec_fetch_user: {
				_t2 = _SLIT("Sec-Fetch-User");
				break;
		}
		case net__http__CommonHeader__sec_websocket_accept: {
				_t2 = _SLIT("Sec-WebSocket-Accept");
				break;
		}
		case net__http__CommonHeader__sec_websocket_key: {
				_t2 = _SLIT("Sec-WebSocket-Key");
				break;
		}
		case net__http__CommonHeader__server: {
				_t2 = _SLIT("Server");
				break;
		}
		case net__http__CommonHeader__server_timing: {
				_t2 = _SLIT("Server-Timing");
				break;
		}
		case net__http__CommonHeader__set_cookie: {
				_t2 = _SLIT("Set-Cookie");
				break;
		}
		case net__http__CommonHeader__sourcemap: {
				_t2 = _SLIT("SourceMap");
				break;
		}
		case net__http__CommonHeader__strict_transport_security: {
				_t2 = _SLIT("Strict-Transport-Security");
				break;
		}
		case net__http__CommonHeader__te: {
				_t2 = _SLIT("TE");
				break;
		}
		case net__http__CommonHeader__timing_allow_origin: {
				_t2 = _SLIT("Timing-Allow-Origin");
				break;
		}
		case net__http__CommonHeader__tk: {
				_t2 = _SLIT("Tk");
				break;
		}
		case net__http__CommonHeader__trailer: {
				_t2 = _SLIT("Trailer");
				break;
		}
		case net__http__CommonHeader__transfer_encoding: {
				_t2 = _SLIT("Transfer-Encoding");
				break;
		}
		case net__http__CommonHeader__upgrade: {
				_t2 = _SLIT("Upgrade");
				break;
		}
		case net__http__CommonHeader__upgrade_insecure_requests: {
				_t2 = _SLIT("Upgrade-Insecure-Requests");
				break;
		}
		case net__http__CommonHeader__user_agent: {
				_t2 = _SLIT("User-Agent");
				break;
		}
		case net__http__CommonHeader__vary: {
				_t2 = _SLIT("Vary");
				break;
		}
		case net__http__CommonHeader__via: {
				_t2 = _SLIT("Via");
				break;
		}
		case net__http__CommonHeader__want_digest: {
				_t2 = _SLIT("Want-Digest");
				break;
		}
		case net__http__CommonHeader__warning: {
				_t2 = _SLIT("Warning");
				break;
		}
		case net__http__CommonHeader__www_authenticate: {
				_t2 = _SLIT("WWW-Authenticate");
				break;
		}
		case net__http__CommonHeader__x_content_type_options: {
				_t2 = _SLIT("X-Content-Type-Options");
				break;
		}
		case net__http__CommonHeader__x_dns_prefetch_control: {
				_t2 = _SLIT("X-DNS-Prefetch-Control");
				break;
		}
		case net__http__CommonHeader__x_forwarded_for: {
				_t2 = _SLIT("X-Forwarded-For");
				break;
		}
		case net__http__CommonHeader__x_forwarded_host: {
				_t2 = _SLIT("X-Forwarded-Host");
				break;
		}
		case net__http__CommonHeader__x_forwarded_proto: {
				_t2 = _SLIT("X-Forwarded-Proto");
				break;
		}
		case net__http__CommonHeader__x_frame_options: {
				_t2 = _SLIT("X-Frame-Options");
				break;
		}
		case net__http__CommonHeader__x_xss_protection: {
				_t2 = _SLIT("X-XSS-Protection");
				break;
		}
	}
	return _t2;
}
void net__http__Header_free(net__http__Header* h) {
	{ // Unsafe block
	}
}
net__http__Header net__http__new_header(Array_net__http__HeaderConfig kvs) {
	net__http__Header h = ((net__http__Header){.data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.cur_pos = 0,});
	for (int i = 0; i < kvs.len; ++i) {
		net__http__HeaderConfig kv = ((net__http__HeaderConfig*)kvs.data)[i];
		h.data[v_fixed_index(i, 50)] = ((net__http__HeaderKV){.key = net__http__CommonHeader_str(kv.key),.value = kv.value,});
	}
	h.cur_pos = kvs.len;
	return h;
}
_result_net__http__Header net__http__new_custom_header_from_map(Map_string_string kvs) {
	net__http__Header h = net__http__new_header(__new_array(0, 0, sizeof(net__http__HeaderConfig)));
	_result_void _t1 = net__http__Header_add_custom_map(&h, kvs);
	if (_t1.is_error) {
		_result_net__http__Header _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	_result_net__http__Header _t3 = {0};
	_result_ok(&(net__http__Header[]) { h }, (_result*)(&_t3), sizeof(net__http__Header));
	return _t3;
}
void net__http__Header_add(net__http__Header* h, net__http__CommonHeader key, string value) {
	string k = net__http__CommonHeader_str(key);
	h->data[v_fixed_index(h->cur_pos, 50)] = ((net__http__HeaderKV){.key = k,.value = value,});
	h->cur_pos++;
}
_result_void net__http__Header_add_custom(net__http__Header* h, string key, string value) {
	_result_void _t1 = net__http__is_valid(key);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	h->data[v_fixed_index(h->cur_pos, 50)] = ((net__http__HeaderKV){.key = key,.value = value,});
	h->cur_pos++;
	return (_result_void){0};
}
_result_void net__http__Header_add_custom_map(net__http__Header* h, Map_string_string kvs) {
	int _t2 = kvs.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = kvs.key_values.len - _t2;
		_t2 = kvs.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&kvs.key_values, _t1)) {continue;}
		string k = *(string*)DenseArray_key(&kvs.key_values, _t1);
		k = string_clone(k);
		string v = (*(string*)DenseArray_value(&kvs.key_values, _t1));
		_result_void _t4 = net__http__Header_add_custom(h, k, v);
		if (_t4.is_error) {
			_result_void _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 ;
	}
	return (_result_void){0};
}
void net__http__Header_set(net__http__Header* h, net__http__CommonHeader key, string value) {
	string key_str = net__http__CommonHeader_str(key);
	for (int i = 0; i < h->cur_pos; i++) {
		if (string__eq(h->data[v_fixed_index(i, 50)].key, key_str)) {
			h->data[v_fixed_index(i, 50)] = ((net__http__HeaderKV){.key = key_str,.value = value,});
			return;
		}
	}
	h->data[v_fixed_index(h->cur_pos, 50)] = ((net__http__HeaderKV){.key = key_str,.value = value,});
	h->cur_pos++;
}
_result_void net__http__Header_set_custom(net__http__Header* h, string key, string value) {
	_result_void _t1 = net__http__is_valid(key);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	bool set = false;
for (int i = 0; i != 50; ++i) {
		net__http__HeaderKV kv = h->data[i];
		if (string__eq(kv.key, key)) {
			if (!set) {
				h->data[v_fixed_index(i, 50)] = ((net__http__HeaderKV){.key = key,.value = value,});
				set = true;
			} else {
				h->data[v_fixed_index(i, 50)] = ((net__http__HeaderKV){.key = key,.value = _SLIT(""),});
			}
		}
	}
	if (set) {
		return (_result_void){0};
	}
	h->data[v_fixed_index(h->cur_pos, 50)] = ((net__http__HeaderKV){.key = key,.value = value,});
	h->cur_pos++;
	return (_result_void){0};
}
bool net__http__Header_contains(net__http__Header h, net__http__CommonHeader key) {
	if (h.cur_pos == 0) {
		return false;
	}
	string key_str = net__http__CommonHeader_str(key);
	for (int i = 0; i < h.cur_pos; i++) {
		if (string__eq(h.data[v_fixed_index(i, 50)].key, key_str)) {
			return true;
		}
	}
	return false;
}
_result_string net__http__Header_get(net__http__Header h, net__http__CommonHeader key) {
	return net__http__Header_get_custom(h, net__http__CommonHeader_str(key), ((net__http__HeaderQueryConfig){.exact = 0,}));
}
_result_string net__http__Header_get_custom(net__http__Header h, string key, net__http__HeaderQueryConfig flags) {
	if (flags.exact) {
		for (int i = 0; i < h.cur_pos; i++) {
			net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
			if (string__eq(kv.key, key)) {
				_result_string _t1 = {0};
				_result_ok(&(string[]) { kv.value }, (_result*)(&_t1), sizeof(string));
				return _t1;
			}
		}
	} else {
		string lower_key = string_to_lower(key);
		for (int i = 0; i < h.cur_pos; i++) {
			net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
			if (string__eq(string_to_lower(kv.key), lower_key)) {
				_result_string _t2 = {0};
				_result_ok(&(string[]) { kv.value }, (_result*)(&_t2), sizeof(string));
				return _t2;
			}
		}
	}
	return (_result_string){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}
Array_string net__http__Header_values(net__http__Header h, net__http__CommonHeader key) {
	return net__http__Header_custom_values(h, net__http__CommonHeader_str(key), ((net__http__HeaderQueryConfig){.exact = 0,}));
}
Array_string net__http__Header_custom_values(net__http__Header h, string key, net__http__HeaderQueryConfig flags) {
	if (h.cur_pos == 0) {
		return __new_array_with_default(0, 0, sizeof(string), 0);
	}
	Array_string res = __new_array_with_default(0, 2, sizeof(string), 0);
	if (flags.exact) {
		for (int i = 0; i < h.cur_pos; i++) {
			net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
			if (string__eq(kv.key, key) && (kv.value).len != 0) {
				array_push((array*)&res, _MOV((string[]){ string_clone(kv.value) }));
			}
		}
		return res;
	} else {
		string lower_key = string_to_lower(key);
		for (int i = 0; i < h.cur_pos; i++) {
			net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
			if (string__eq(string_to_lower(kv.key), lower_key) && (kv.value).len != 0) {
				array_push((array*)&res, _MOV((string[]){ string_clone(kv.value) }));
			}
		}
		return res;
	}
	return __new_array(0, 0, sizeof(string));
}
Array_string net__http__Header_keys(net__http__Header h) {
	Array_string res = __new_array_with_default(0, h.cur_pos, sizeof(string), 0);
	for (int i = 0; i < h.cur_pos; i++) {
		if ((h.data[v_fixed_index(i, 50)].value).len == 0) {
			continue;
		}
		array_push((array*)&res, _MOV((string[]){ string_clone(h.data[v_fixed_index(i, 50)].key) }));
	}
	return arrays__uniq_T_string(res);
}
string net__http__Header_render(net__http__Header h, net__http__HeaderRenderConfig flags) {
	strings__Builder sb = strings__new_builder((int)(50 * 48));
	net__http__Header_render_into_sb(h, (voidptr)&sb, flags);
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
void net__http__Header_render_into_sb(net__http__Header h, strings__Builder* sb, net__http__HeaderRenderConfig flags) {
	for (int i = 0; i < h.cur_pos; i++) {
		net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
		string key = (flags.version == net__http__Version__v2_0 ? (string_to_lower(kv.key)) : flags.canonicalize ? (net__http__canonicalize(string_to_lower(kv.key))) : (kv.key));
		strings__Builder_write_string(sb, key);
		strings__Builder_write_string(sb, _SLIT(": "));
		strings__Builder_write_string(sb, kv.value);
		strings__Builder_write_string(sb, _SLIT("\r\n"));
	}
}
net__http__Header net__http__Header_join(net__http__Header h, net__http__Header other) {
	net__http__Header combined = ((net__http__Header){.data = {h.data[0], h.data[1], h.data[2], h.data[3], h.data[4], h.data[5], h.data[6], h.data[7], h.data[8], h.data[9], h.data[10], h.data[11], h.data[12], h.data[13], h.data[14], h.data[15], 
	h.data[16], h.data[17], h.data[18], h.data[19], h.data[20], h.data[21], h.data[22], h.data[23], h.data[24], h.data[25], h.data[26], h.data[27], h.data[28], h.data[29], h.data[30], h.data[31], 
	h.data[32], h.data[33], h.data[34], h.data[35], h.data[36], h.data[37], h.data[38], h.data[39], h.data[40], h.data[41], h.data[42], h.data[43], h.data[44], h.data[45], h.data[46], h.data[47], h.data[48], h.data[49]},.cur_pos = h.cur_pos,});
	Array_string _t1 = net__http__Header_keys(other);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string k = ((string*)_t1.data)[_t2];
		Array_string _t3 = net__http__Header_custom_values(other, k, ((net__http__HeaderQueryConfig){.exact = true,}));
		for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
			string v = ((string*)_t3.data)[_t4];
			_result_void _t5 = net__http__Header_add_custom(&combined, k, v);
			if (_t5.is_error) {
				IError err = _t5.err;
				_v_panic(string__plus(_SLIT("unexpected error: "), IError_str(err)));
				VUNREACHABLE();
			;
			}
			
 ;
		}
	}
	return combined;
}
VV_LOCAL_SYMBOL string net__http__canonicalize(string name) {
	if (_IN_MAP(ADDR(string, name), ADDR(map, _const_net__http__common_header_map))) {
		return net__http__CommonHeader_str((*(net__http__CommonHeader*)map_get(ADDR(map, _const_net__http__common_header_map), &(string[]){name}, &(net__http__CommonHeader[]){ 0 })));
	}
	Array_string _t3 = {0};
	Array_string _t3_orig = string_split(name, _SLIT("-"));
	int _t3_len = _t3_orig.len;
	_t3 = __new_array(0, _t3_len, sizeof(string));

	for (int _t5 = 0; _t5 < _t3_len; ++_t5) {
		string it = ((string*) _t3_orig.data)[_t5];
		string _t4 = string_capitalize(it);
		array_push((array*)&_t3, &_t4);
	}
	return Array_string_join( _t3, _SLIT("-"));
}
string net__http__HeaderKeyError_msg(net__http__HeaderKeyError err) {
	return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid header key: '"), 0xfe10, {.d_s = err.header}}, {_SLIT("'"), 0, { .d_c = 0 }}}));
}
int net__http__HeaderKeyError_code(net__http__HeaderKeyError err) {
	return err.code;
}
VV_LOCAL_SYMBOL _result_void net__http__is_valid(string header) {
	for (int _t1 = 0; _t1 < header.len; ++_t1) {
		u8 c = header.str[_t1];
		if (((int)(c)) >= 128 || !net__http__is_token(c)) {
			return (_result_void){ .is_error=true, .err=I_net__http__HeaderKeyError_to_Interface_IError(((net__http__HeaderKeyError*)memdup(&(net__http__HeaderKeyError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),.code = 1,.header = header,.invalid_char = c,}, sizeof(net__http__HeaderKeyError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	if (header.len == 0) {
		return (_result_void){ .is_error=true, .err=I_net__http__HeaderKeyError_to_Interface_IError(((net__http__HeaderKeyError*)memdup(&(net__http__HeaderKeyError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),.code = 2,.header = header,.invalid_char = 0,}, sizeof(net__http__HeaderKeyError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}
VV_LOCAL_SYMBOL bool net__http__is_token(u8 b) {
	return ((b == (33) || (b >= 35 && b <= 39) || b == (42) || b == (43) || b == (45) || b == (46) || (b >= 48 && b <= 57) || (b >= 65 && b <= 90) || (b >= 94 && b <= 122) || b == (124) || b == (126))? (true) : (false));
}
string net__http__Header_str(net__http__Header h) {
	return net__http__Header_render(h, ((net__http__HeaderRenderConfig){.version = net__http__Version__v1_1,.coerce = 0,.canonicalize = 0,}));
}
VV_LOCAL_SYMBOL _result_int net__http__parse_header_fast(string s) {
	_option_int _t1 = string_index(s, _SLIT(":"));
	if (_t1.state != 0) {
		IError err = _t1.err;
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("missing colon in header")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int pos = (*(int*)_t1.data);
	_result_int _t3 = {0};
	_result_ok(&(int[]) { pos }, (_result*)(&_t3), sizeof(int));
	return _t3;
}
string net__http__Method_str(net__http__Method m) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (m) {
		case net__http__Method__get: {
				_t2 = _SLIT("GET");
				break;
		}
		case net__http__Method__head: {
				_t2 = _SLIT("HEAD");
				break;
		}
		case net__http__Method__post: {
				_t2 = _SLIT("POST");
				break;
		}
		case net__http__Method__put: {
				_t2 = _SLIT("PUT");
				break;
		}
		case net__http__Method__acl: {
				_t2 = _SLIT("ACL");
				break;
		}
		case net__http__Method__baseline_control: {
				_t2 = _SLIT("BASELINE-CONTROL");
				break;
		}
		case net__http__Method__bind: {
				_t2 = _SLIT("BIND");
				break;
		}
		case net__http__Method__checkin: {
				_t2 = _SLIT("CHECKIN");
				break;
		}
		case net__http__Method__checkout: {
				_t2 = _SLIT("CHECKOUT");
				break;
		}
		case net__http__Method__connect: {
				_t2 = _SLIT("CONNECT");
				break;
		}
		case net__http__Method__copy: {
				_t2 = _SLIT("COPY");
				break;
		}
		case net__http__Method__delete: {
				_t2 = _SLIT("DELETE");
				break;
		}
		case net__http__Method__label: {
				_t2 = _SLIT("LABEL");
				break;
		}
		case net__http__Method__link: {
				_t2 = _SLIT("LINK");
				break;
		}
		case net__http__Method__lock: {
				_t2 = _SLIT("LOCK");
				break;
		}
		case net__http__Method__merge: {
				_t2 = _SLIT("MERGE");
				break;
		}
		case net__http__Method__mkactivity: {
				_t2 = _SLIT("MKACTIVITY");
				break;
		}
		case net__http__Method__mkcalendar: {
				_t2 = _SLIT("MKCALENDAR");
				break;
		}
		case net__http__Method__mkcol: {
				_t2 = _SLIT("MKCOL");
				break;
		}
		case net__http__Method__mkredirectref: {
				_t2 = _SLIT("MKREDIRECTREF");
				break;
		}
		case net__http__Method__mkworkspace: {
				_t2 = _SLIT("MKWORKSPACE");
				break;
		}
		case net__http__Method__move: {
				_t2 = _SLIT("MOVE");
				break;
		}
		case net__http__Method__options: {
				_t2 = _SLIT("OPTIONS");
				break;
		}
		case net__http__Method__orderpatch: {
				_t2 = _SLIT("ORDERPATCH");
				break;
		}
		case net__http__Method__patch: {
				_t2 = _SLIT("PATCH");
				break;
		}
		case net__http__Method__pri: {
				_t2 = _SLIT("PRI");
				break;
		}
		case net__http__Method__propfind: {
				_t2 = _SLIT("PROPFIND");
				break;
		}
		case net__http__Method__proppatch: {
				_t2 = _SLIT("PROPPATCH");
				break;
		}
		case net__http__Method__rebind: {
				_t2 = _SLIT("REBIND");
				break;
		}
		case net__http__Method__report: {
				_t2 = _SLIT("REPORT");
				break;
		}
		case net__http__Method__search: {
				_t2 = _SLIT("SEARCH");
				break;
		}
		case net__http__Method__trace: {
				_t2 = _SLIT("TRACE");
				break;
		}
		case net__http__Method__unbind: {
				_t2 = _SLIT("UNBIND");
				break;
		}
		case net__http__Method__uncheckout: {
				_t2 = _SLIT("UNCHECKOUT");
				break;
		}
		case net__http__Method__unlink: {
				_t2 = _SLIT("UNLINK");
				break;
		}
		case net__http__Method__unlock: {
				_t2 = _SLIT("UNLOCK");
				break;
		}
		case net__http__Method__update: {
				_t2 = _SLIT("UPDATE");
				break;
		}
		case net__http__Method__updateredirectref: {
				_t2 = _SLIT("UPDATEREDIRECTREF");
				break;
		}
		case net__http__Method__version_control: {
				_t2 = _SLIT("VERSION-CONTROL");
				break;
		}
	}
	return _t2;
}
net__http__Method net__http__method_from_str(string m) {
	return ((_SLIT_EQ(m.str, m.len, "GET"))? (net__http__Method__get) : (_SLIT_EQ(m.str, m.len, "HEAD"))? (net__http__Method__head) : (_SLIT_EQ(m.str, m.len, "POST"))? (net__http__Method__post) : (_SLIT_EQ(m.str, m.len, "PUT"))? (net__http__Method__put) : (_SLIT_EQ(m.str, m.len, "ACL"))? (net__http__Method__acl) : (_SLIT_EQ(m.str, m.len, "BASELINE-CONTROL"))? (net__http__Method__baseline_control) : (_SLIT_EQ(m.str, m.len, "BIND"))? (net__http__Method__bind) : (_SLIT_EQ(m.str, m.len, "CHECKIN"))? (net__http__Method__checkin) : (_SLIT_EQ(m.str, m.len, "CHECKOUT"))? (net__http__Method__checkout) : (_SLIT_EQ(m.str, m.len, "CONNECT"))? (net__http__Method__connect) : (_SLIT_EQ(m.str, m.len, "COPY"))? (net__http__Method__copy) : (_SLIT_EQ(m.str, m.len, "DELETE"))? (net__http__Method__delete) : (_SLIT_EQ(m.str, m.len, "LABEL"))? (net__http__Method__label) : (_SLIT_EQ(m.str, m.len, "LINK"))? (net__http__Method__link) : (_SLIT_EQ(m.str, m.len, "LOCK"))? (net__http__Method__lock) : (_SLIT_EQ(m.str, m.len, "MERGE"))? (net__http__Method__merge) : (_SLIT_EQ(m.str, m.len, "MKACTIVITY"))? (net__http__Method__mkactivity) : (_SLIT_EQ(m.str, m.len, "MKCALENDAR"))? (net__http__Method__mkcalendar) : (_SLIT_EQ(m.str, m.len, "MKCOL"))? (net__http__Method__mkcol) : (_SLIT_EQ(m.str, m.len, "MKREDIRECTREF"))? (net__http__Method__mkredirectref) : (_SLIT_EQ(m.str, m.len, "MKWORKSPACE"))? (net__http__Method__mkworkspace) : (_SLIT_EQ(m.str, m.len, "MOVE"))? (net__http__Method__move) : (_SLIT_EQ(m.str, m.len, "OPTIONS"))? (net__http__Method__options) : (_SLIT_EQ(m.str, m.len, "ORDERPATCH"))? (net__http__Method__orderpatch) : (_SLIT_EQ(m.str, m.len, "PATCH"))? (net__http__Method__patch) : (_SLIT_EQ(m.str, m.len, "PRI"))? (net__http__Method__pri) : (_SLIT_EQ(m.str, m.len, "PROPFIND"))? (net__http__Method__propfind) : (_SLIT_EQ(m.str, m.len, "PROPPATCH"))? (net__http__Method__proppatch) : (_SLIT_EQ(m.str, m.len, "REBIND"))? (net__http__Method__rebind) : (_SLIT_EQ(m.str, m.len, "REPORT"))? (net__http__Method__report) : (_SLIT_EQ(m.str, m.len, "SEARCH"))? (net__http__Method__search) : (_SLIT_EQ(m.str, m.len, "TRACE"))? (net__http__Method__trace) : (_SLIT_EQ(m.str, m.len, "UNBIND"))? (net__http__Method__unbind) : (_SLIT_EQ(m.str, m.len, "UNCHECKOUT"))? (net__http__Method__uncheckout) : (_SLIT_EQ(m.str, m.len, "UNLINK"))? (net__http__Method__unlink) : (_SLIT_EQ(m.str, m.len, "UNLOCK"))? (net__http__Method__unlock) : (_SLIT_EQ(m.str, m.len, "UPDATE"))? (net__http__Method__update) : (_SLIT_EQ(m.str, m.len, "UPDATEREDIRECTREF"))? (net__http__Method__updateredirectref) : (_SLIT_EQ(m.str, m.len, "VERSION-CONTROL"))? (net__http__Method__version_control) : (net__http__Method__get));
}
VV_LOCAL_SYMBOL void net__http__Request_free(net__http__Request* req) {
	net__http__Header_free(&req->header);
}
_option_net__http__Cookie net__http__Request_cookie(net__http__Request* req, string name) {
	string* _t2 = (string*)(map_get_check(ADDR(map, req->cookies), &(string[]){name}));
	_option_string _t1 = {0};
	if (_t2) {
		*((string*)&_t1.data) = *((string*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("map key does not exist"));
	}
	
	if (_t1.state == 0) {
		string value = (*(string*)_t1.data);
		_option_net__http__Cookie _t3;
		_option_ok(&(net__http__Cookie[]) { ((net__http__Cookie){.name = name,.value = value,.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}) }, (_option*)(&_t3), sizeof(net__http__Cookie));
		return _t3;
	}
	return (_option_net__http__Cookie){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}
_result_net__http__Request net__http__parse_request_head(io__BufferedReader* reader) {
	_result_string _t1 = io__BufferedReader_read_line(reader, ((io__BufferedReadLineConfig){.delim = '\n',}));
	if (_t1.is_error) {
		_result_net__http__Request _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	string line = (*(string*)_t1.data);
	_result_multi_return_net__http__Method_net__urllib__URL_net__http__Version _t3 = net__http__parse_request_line(line);
	if (_t3.is_error) {
		_result_net__http__Request _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	multi_return_net__http__Method_net__urllib__URL_net__http__Version mr_12616 = (*(multi_return_net__http__Method_net__urllib__URL_net__http__Version*)_t3.data);
	net__http__Method method = mr_12616.arg0;
	net__urllib__URL target = mr_12616.arg1;
	net__http__Version version = mr_12616.arg2;
	net__http__Header header = net__http__new_header(__new_array(0, 0, sizeof(net__http__HeaderConfig)));
	_result_string _t5 = io__BufferedReader_read_line(reader, ((io__BufferedReadLineConfig){.delim = '\n',}));
	if (_t5.is_error) {
		_result_net__http__Request _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 	line = (*(string*)_t5.data);
	for (;;) {
		if (!((line).len != 0)) break;
		_result_int _t7 = net__http__parse_header_fast(line);
		if (_t7.is_error) {
			_result_net__http__Request _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
 		int pos = (*(int*)_t7.data);
		string key = string_substr_unsafe(line, 0, pos);
		for (;;) {
			if (!(pos < (int)(line.len - 1) && u8_is_space(string_at(line, (int)(pos + 1))))) break;
			if (u8_is_space(string_at(line, (int)(pos + 1)))) {
				pos++;
			}
		}
		string value = string_substr_unsafe(line, (int)(pos + 1), line.len);
		{string _ = key;}
		;
		{string _ = value;}
		;
		_result_void _t9 = net__http__Header_add_custom(&header, key, value);
		if (_t9.is_error) {
			_result_net__http__Request _t10;
			memcpy(&_t10, &_t9, sizeof(_result));
			return _t10;
		}
		
 ;
		_result_string _t11 = io__BufferedReader_read_line(reader, ((io__BufferedReadLineConfig){.delim = '\n',}));
		if (_t11.is_error) {
			_result_net__http__Request _t12;
			memcpy(&_t12, &_t11, sizeof(_result));
			return _t12;
		}
		
 		line = (*(string*)_t11.data);
	}
	Map_string_string request_cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	Array_net__http__Cookie_ptr _t13 = net__http__read_cookies(header, _SLIT(""));
	for (int _t14 = 0; _t14 < _t13.len; ++_t14) {
		net__http__Cookie* cookie = ((net__http__Cookie**)_t13.data)[_t14];
		map_set(&request_cookies, &(string[]){cookie->name}, &(string[]) { cookie->value });
	}
		_result_string _t16 = net__http__Header_get(header, net__http__CommonHeader__host);
		if (_t16.is_error) {
			IError err = _t16.err;
			*(string*) _t16.data = _SLIT("");
		}
		
 	_result_net__http__Request _t15 = {0};
	_result_ok(&(net__http__Request[]) { ((net__http__Request){
		.cookies = request_cookies,
		.version = version,
		.method = method,
		.header = header,
		.host = (*(string*)_t16.data),
		.data = (string){.str=(byteptr)"", .is_lit=1},
		.url = net__urllib__URL_str(target),
		.user_agent = _SLIT("v.http"),
		.verbose = 0,
		.user_ptr = 0,
		.proxy = ((void*)0),
		.read_timeout = 30 * _const_time__second,
		.write_timeout = 30 * _const_time__second,
		.validate = 0,
		.verify = (string){.str=(byteptr)"", .is_lit=1},
		.cert = (string){.str=(byteptr)"", .is_lit=1},
		.cert_key = (string){.str=(byteptr)"", .is_lit=1},
		.in_memory_verification = 0,
		.allow_redirect = true,
		.max_retries = 5,
		.on_redirect = ((void*)0),
		.on_progress = ((void*)0),
		.on_progress_body = ((void*)0),
		.on_finish = ((void*)0),
		.stop_copying_limit = -1,
		.stop_receiving_limit = -1,
	}) }, (_result*)(&_t15), sizeof(net__http__Request));
	return _t15;
}
VV_LOCAL_SYMBOL _result_multi_return_net__http__Method_net__urllib__URL_net__http__Version net__http__parse_request_line(string s) {
	multi_return_int_int mr_13661 = net__http__fast_request_words(s);
	int space1 = mr_13661.arg0;
	int space2 = mr_13661.arg1;
	if (space1 == 0 || space2 == 0) {
		return (_result_multi_return_net__http__Method_net__urllib__URL_net__http__Version){ .is_error=true, .err=_v_error(_SLIT("malformed request line")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string method_str = string_substr_unsafe(s, 0, space1);
	string target_str = string_substr_unsafe(s, (int)(space1 + 1), space2);
	string version_str = string_substr_unsafe(s, (int)(space2 + 1), s.len);
	net__http__Method method = net__http__method_from_str(method_str);
	_result_net__urllib__URL _t2 = net__urllib__parse(target_str);
	if (_t2.is_error) {
		_result_multi_return_net__http__Method_net__urllib__URL_net__http__Version _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	net__urllib__URL target = (*(net__urllib__URL*)_t2.data);
	net__http__Version version = net__http__version_from_str(version_str);
	if (version == net__http__Version__unknown) {
		return (_result_multi_return_net__http__Method_net__urllib__URL_net__http__Version){ .is_error=true, .err=_v_error(_SLIT("unsupported version")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_multi_return_net__http__Method_net__urllib__URL_net__http__Version _t5;
	_result_ok(&(multi_return_net__http__Method_net__urllib__URL_net__http__Version[]) { (multi_return_net__http__Method_net__urllib__URL_net__http__Version){.arg0=method, .arg1=target, .arg2=version} }, (_result*)(&_t5), sizeof(multi_return_net__http__Method_net__urllib__URL_net__http__Version));
	return _t5;
}
Map_string_string net__http__parse_form(string body) {
	Map_string_string form = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	if (string_match_glob(body, _SLIT("{*}"))) {
		map_set(&form, &(string[]){_SLIT("json")}, &(string[]) { body });
	} else {
		Array_string words = string_split(body, _SLIT("&"));
		for (int _t1 = 0; _t1 < words.len; ++_t1) {
			string word = ((string*)words.data)[_t1];
			Array_string kv = string_split_nth(word, _SLIT("="), 2);
			if (kv.len != 2) {
				continue;
			}
			_result_string _t2 = net__urllib__query_unescape((*(string*)array_get(kv, 0)));
			if (_t2.is_error) {
				IError err = _t2.err;
				continue;
			}
			
 			string key = (*(string*)_t2.data);
			_result_string _t3 = net__urllib__query_unescape((*(string*)array_get(kv, 1)));
			if (_t3.is_error) {
				IError err = _t3.err;
				continue;
			}
			
 			string val = (*(string*)_t3.data);
			map_set(&form, &(string[]){key}, &(string[]) { val });
		}
	}
	return form;
}
string net__http__UnexpectedExtraAttributeError_msg(net__http__UnexpectedExtraAttributeError err) {
	return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Encountered unexpected extra attributes: "), 0xfe10, {.d_s = Array_string_str(err.attributes)}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
string net__http__MultiplePathAttributesError_msg(net__http__MultiplePathAttributesError err) {
	return _SLIT("Expected at most one path attribute");
}
multi_return_Map_string_string_Map_string_Array_net__http__FileData net__http__parse_multipart_form(string body, string boundary) {
	Map_string_string form = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	Map_string_Array_net__http__FileData files = new_map(sizeof(string), sizeof(Array_net__http__FileData), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	Array_string sections = string_split(body, boundary);
	Array_string fields = array_slice(sections, 1, (int)(sections.len - 1));
	for (int _t1 = 0; _t1 < fields.len; ++_t1) {
		string field = ((string*)fields.data)[_t1];
		Array_net__http__LineSegmentIndexes line_segments = __new_array_with_default_noscan(0, 100, sizeof(net__http__LineSegmentIndexes), 0);
		int line_idx = 0;
		int line_start = 0;
		for (int cidx = 0; cidx < field.len; ++cidx) {
			u8 c = field.str[cidx];
			if (line_idx >= 6) {
				break;
			}
			if (c == '\n') {
				array_push_noscan((array*)&line_segments, _MOV((net__http__LineSegmentIndexes[]){ ((net__http__LineSegmentIndexes){.start = line_start,.end = cidx,}) }));
				line_start = (int)(cidx + 1);
				line_idx++;
			}
		}
		array_push_noscan((array*)&line_segments, _MOV((net__http__LineSegmentIndexes[]){ ((net__http__LineSegmentIndexes){.start = line_start,.end = field.len,}) }));
		string line1 = string_substr(field, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 1)).start, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 1)).end);
		string line2 = string_substr(field, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 2)).start, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 2)).end);
		Map_string_string disposition = net__http__parse_disposition(string_trim_space(line1));
		string* _t5 = (string*)(map_get_check(ADDR(map, disposition), &(string[]){_SLIT("name")}));
		_option_string _t4 = {0};
		if (_t5) {
			*((string*)&_t4.data) = *((string*)_t5);
		} else {
			_t4.state = 2; _t4.err = _v_error(_SLIT("map key does not exist"));
		}
		;
		if (_t4.state != 0) {
			IError err = _t4.err;
			continue;
		}
		
		string name = (*(string*)_t4.data);
		string* _t7 = (string*)(map_get_check(ADDR(map, disposition), &(string[]){_SLIT("filename")}));
		_option_string _t6 = {0};
		if (_t7) {
			*((string*)&_t6.data) = *((string*)_t7);
		} else {
			_t6.state = 2; _t6.err = _v_error(_SLIT("map key does not exist"));
		}
		
		if (_t6.state == 0) {
			string filename = (*(string*)_t6.data);
			if (line_segments.len < 5) {
				continue;
			}
			if (!string_starts_with(string_to_lower(line2), _SLIT("content-type:"))) {
				continue;
			}
			string content_type = string_trim_space((*(string*)array_get(string_split_nth(line2, _SLIT(":"), 2), 1)));
			string data = string_substr(field, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 4)).start, (int)(field.len - 4));
			array_push((array*)&(*(Array_net__http__FileData*)map_get_and_set((map*)&files, &(string[]){name}, &(Array_net__http__FileData[]){ __new_array(0, 0, sizeof(net__http__FileData)) })), _MOV((net__http__FileData[]){ ((net__http__FileData){.filename = filename,.content_type = content_type,.data = data,}) }));
			continue;
		}
		if (line_segments.len < 4) {
			continue;
		}
		map_set(&form, &(string[]){name}, &(string[]) { string_substr(field, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 3)).start, (int)(field.len - 4)) });
	}
	return (multi_return_Map_string_string_Map_string_Array_net__http__FileData){.arg0=form, .arg1=files};
}
VV_LOCAL_SYMBOL Map_string_string net__http__parse_disposition(string line) {
	Map_string_string data = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	Array_string _t1 = string_split(line, _SLIT(";"));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string word = ((string*)_t1.data)[_t2];
		Array_string kv = string_split_nth(word, _SLIT("="), 2);
		if (kv.len != 2) {
			continue;
		}
		string key = string_trim_left(string_to_lower((*(string*)array_get(kv, 0))), _SLIT(" \t"));
		string value = (*(string*)array_get(kv, 1));
		if (string_starts_with(value, _SLIT("\"")) && string_ends_with(value, _SLIT("\""))) {
			map_set(&data, &(string[]){key}, &(string[]) { string_substr(value, 1, (int)(value.len - 1)) });
		} else {
			map_set(&data, &(string[]){key}, &(string[]) { value });
		}
	}
	return data;
}
VV_LOCAL_SYMBOL void net__http__Response_free(net__http__Response* resp) {
	net__http__Header_free(&resp->header);
}
Array_u8 net__http__Response_bytes(net__http__Response resp) {
	return string_bytes(net__http__Response_bytestr(resp));
}
string net__http__Response_bytestr(net__http__Response resp) {
	return string__plus(string__plus(str_intp(4, _MOV((StrIntpData[]){{_SLIT("HTTP/"), 0xfe10, {.d_s = resp.http_version}}, {_SLIT(" "), 0xfe07, {.d_i32 = resp.status_code}}, {_SLIT(" "), 0xfe10, {.d_s = resp.status_msg}}, {_SLIT("\r\n"), 0, { .d_c = 0 }}})), str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = net__http__Header_render(resp.header, ((net__http__HeaderRenderConfig){.version = net__http__Response_version(resp),.coerce = 0,.canonicalize = 0,}))}}, {_SLIT("\r\n"), 0, { .d_c = 0 }}}))), resp.body);
}
void net__http__Response_set_status(net__http__Response* r, net__http__Status s) {
	r->status_code = net__http__Status_int(s);
	r->status_msg = net__http__Status_str(s);
}
net__http__Version net__http__Response_version(net__http__Response r) {
	return ((_SLIT_EQ(r.http_version.str, r.http_version.len, "1.0"))? (net__http__Version__v1_0) : (_SLIT_EQ(r.http_version.str, r.http_version.len, "1.1"))? (net__http__Version__v1_1) : (_SLIT_EQ(r.http_version.str, r.http_version.len, "2.0"))? (net__http__Version__v2_0) : (net__http__Version__unknown));
}
void net__http__Response_set_version(net__http__Response* r, net__http__Version v) {
	if (v == net__http__Version__unknown) {
		r->http_version = _SLIT("");
		return;
	}
	multi_return_int_int mr_3302 = net__http__Version_protos(v);
	int maj = mr_3302.arg0;
	int min = mr_3302.arg1;
	r->http_version = str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = maj}}, {_SLIT("."), 0xfe07, {.d_i32 = min}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
net__http__Response net__http__new_response(net__http__ResponseConfig conf) {
	net__http__Response resp = ((net__http__Response){.body = conf.body,.header = conf.header,.status_code = 0,.status_msg = (string){.str=(byteptr)"", .is_lit=1},.http_version = (string){.str=(byteptr)"", .is_lit=1},});
	if ((resp.body).len != 0 && !net__http__Header_contains(resp.header, net__http__CommonHeader__content_length)) {
		net__http__Header_add(&resp.header, net__http__CommonHeader__content_length, int_str(resp.body.len));
	}
	net__http__Response_set_status(&resp, conf.status);
	net__http__Response_set_version(&resp, conf.version);
	return resp;
}
VV_LOCAL_SYMBOL net__http__Response net__http__DebugHandler_handle(net__http__DebugHandler d, net__http__Request req) {
	#if defined(_VDEBUG)
	{
	}
	#else
	{
		eprintln(str_intp(4, _MOV((StrIntpData[]){{_SLIT("["), 0xfe10, {.d_s = time__Time_str(time__now())}}, {_SLIT("] "), 0xfe10, {.d_s = net__http__Method_str(req.method)}}, {_SLIT(" "), 0xfe10, {.d_s = req.url}}, {_SLIT(" - 200"), 0, { .d_c = 0 }}})));
	}
	#endif
	net__http__Response r = ((net__http__Response){.body = req.data,.header = req.header,.status_code = 0,.status_msg = (string){.str=(byteptr)"", .is_lit=1},.http_version = (string){.str=(byteptr)"", .is_lit=1},});
	net__http__Response_set_status(&r, net__http__Status__ok);
	net__http__Response_set_version(&r, req.version);
	return r;
}
string net__http__Status_str(net__http__Status code) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (code) {
		case net__http__Status__cont: {
				_t2 = _SLIT("Continue");
				break;
		}
		case net__http__Status__switching_protocols: {
				_t2 = _SLIT("Switching Protocols");
				break;
		}
		case net__http__Status__processing: {
				_t2 = _SLIT("Processing");
				break;
		}
		case net__http__Status__checkpoint_draft: {
				_t2 = _SLIT("Checkpoint Draft");
				break;
		}
		case net__http__Status__ok: {
				_t2 = _SLIT("OK");
				break;
		}
		case net__http__Status__created: {
				_t2 = _SLIT("Created");
				break;
		}
		case net__http__Status__accepted: {
				_t2 = _SLIT("Accepted");
				break;
		}
		case net__http__Status__non_authoritative_information: {
				_t2 = _SLIT("Non Authoritative Information");
				break;
		}
		case net__http__Status__no_content: {
				_t2 = _SLIT("No Content");
				break;
		}
		case net__http__Status__reset_content: {
				_t2 = _SLIT("Reset Content");
				break;
		}
		case net__http__Status__partial_content: {
				_t2 = _SLIT("Partial Content");
				break;
		}
		case net__http__Status__multi_status: {
				_t2 = _SLIT("Multi Status");
				break;
		}
		case net__http__Status__already_reported: {
				_t2 = _SLIT("Already Reported");
				break;
		}
		case net__http__Status__im_used: {
				_t2 = _SLIT("IM Used");
				break;
		}
		case net__http__Status__multiple_choices: {
				_t2 = _SLIT("Multiple Choices");
				break;
		}
		case net__http__Status__moved_permanently: {
				_t2 = _SLIT("Moved Permanently");
				break;
		}
		case net__http__Status__found: {
				_t2 = _SLIT("Found");
				break;
		}
		case net__http__Status__see_other: {
				_t2 = _SLIT("See Other");
				break;
		}
		case net__http__Status__not_modified: {
				_t2 = _SLIT("Not Modified");
				break;
		}
		case net__http__Status__use_proxy: {
				_t2 = _SLIT("Use Proxy");
				break;
		}
		case net__http__Status__switch_proxy: {
				_t2 = _SLIT("Switch Proxy");
				break;
		}
		case net__http__Status__temporary_redirect: {
				_t2 = _SLIT("Temporary Redirect");
				break;
		}
		case net__http__Status__permanent_redirect: {
				_t2 = _SLIT("Permanent Redirect");
				break;
		}
		case net__http__Status__bad_request: {
				_t2 = _SLIT("Bad Request");
				break;
		}
		case net__http__Status__unauthorized: {
				_t2 = _SLIT("Unauthorized");
				break;
		}
		case net__http__Status__payment_required: {
				_t2 = _SLIT("Payment Required");
				break;
		}
		case net__http__Status__forbidden: {
				_t2 = _SLIT("Forbidden");
				break;
		}
		case net__http__Status__not_found: {
				_t2 = _SLIT("Not Found");
				break;
		}
		case net__http__Status__method_not_allowed: {
				_t2 = _SLIT("Method Not Allowed");
				break;
		}
		case net__http__Status__not_acceptable: {
				_t2 = _SLIT("Not Acceptable");
				break;
		}
		case net__http__Status__proxy_authentication_required: {
				_t2 = _SLIT("Proxy Authentication Required");
				break;
		}
		case net__http__Status__request_timeout: {
				_t2 = _SLIT("Request Timeout");
				break;
		}
		case net__http__Status__conflict: {
				_t2 = _SLIT("Conflict");
				break;
		}
		case net__http__Status__gone: {
				_t2 = _SLIT("Gone");
				break;
		}
		case net__http__Status__length_required: {
				_t2 = _SLIT("Length Required");
				break;
		}
		case net__http__Status__precondition_failed: {
				_t2 = _SLIT("Precondition Failed");
				break;
		}
		case net__http__Status__request_entity_too_large: {
				_t2 = _SLIT("Request Entity Too Large");
				break;
		}
		case net__http__Status__request_uri_too_long: {
				_t2 = _SLIT("Request URI Too Long");
				break;
		}
		case net__http__Status__unsupported_media_type: {
				_t2 = _SLIT("Unsupported Media Type");
				break;
		}
		case net__http__Status__requested_range_not_satisfiable: {
				_t2 = _SLIT("Requested Range Not Satisfiable");
				break;
		}
		case net__http__Status__expectation_failed: {
				_t2 = _SLIT("Expectation Failed");
				break;
		}
		case net__http__Status__im_a_teapot: {
				_t2 = _SLIT("Im a teapot");
				break;
		}
		case net__http__Status__misdirected_request: {
				_t2 = _SLIT("Misdirected Request");
				break;
		}
		case net__http__Status__unprocessable_entity: {
				_t2 = _SLIT("Unprocessable Entity");
				break;
		}
		case net__http__Status__locked: {
				_t2 = _SLIT("Locked");
				break;
		}
		case net__http__Status__failed_dependency: {
				_t2 = _SLIT("Failed Dependency");
				break;
		}
		case net__http__Status__unordered_collection: {
				_t2 = _SLIT("Unordered Collection");
				break;
		}
		case net__http__Status__upgrade_required: {
				_t2 = _SLIT("Upgrade Required");
				break;
		}
		case net__http__Status__precondition_required: {
				_t2 = _SLIT("Precondition Required");
				break;
		}
		case net__http__Status__too_many_requests: {
				_t2 = _SLIT("Too Many Requests");
				break;
		}
		case net__http__Status__request_header_fields_too_large: {
				_t2 = _SLIT("Request Header Fields Too Large");
				break;
		}
		case net__http__Status__unavailable_for_legal_reasons: {
				_t2 = _SLIT("Unavailable For Legal Reasons");
				break;
		}
		case net__http__Status__internal_server_error: {
				_t2 = _SLIT("Internal Server Error");
				break;
		}
		case net__http__Status__not_implemented: {
				_t2 = _SLIT("Not Implemented");
				break;
		}
		case net__http__Status__bad_gateway: {
				_t2 = _SLIT("Bad Gateway");
				break;
		}
		case net__http__Status__service_unavailable: {
				_t2 = _SLIT("Service Unavailable");
				break;
		}
		case net__http__Status__gateway_timeout: {
				_t2 = _SLIT("Gateway Timeout");
				break;
		}
		case net__http__Status__http_version_not_supported: {
				_t2 = _SLIT("HTTP Version Not Supported");
				break;
		}
		case net__http__Status__variant_also_negotiates: {
				_t2 = _SLIT("Variant Also Negotiates");
				break;
		}
		case net__http__Status__insufficient_storage: {
				_t2 = _SLIT("Insufficient Storage");
				break;
		}
		case net__http__Status__loop_detected: {
				_t2 = _SLIT("Loop Detected");
				break;
		}
		case net__http__Status__bandwidth_limit_exceeded: {
				_t2 = _SLIT("Bandwidth Limit Exceeded");
				break;
		}
		case net__http__Status__not_extended: {
				_t2 = _SLIT("Not Extended");
				break;
		}
		case net__http__Status__network_authentication_required: {
				_t2 = _SLIT("Network Authentication Required");
				break;
		}
		case net__http__Status__unassigned: {
				_t2 = _SLIT("Unassigned");
				break;
		}
		case net__http__Status__unknown:
		case net__http__Status__client_closed_request:
		default: {
				_t2 = _SLIT("Unknown");
				break;
		}
	}
	return _t2;
}
int net__http__Status_int(net__http__Status code) {
	if (code == net__http__Status__unknown || code == net__http__Status__unassigned) {
		return 0;
	}
	return ((int)(code));
}
VV_LOCAL_SYMBOL multi_return_int_int net__http__fast_request_words(string line) {
	_option_int _t1 = string_index(line, _SLIT(" "));
	if (_t1.state != 0) {
		IError err = _t1.err;
		return (multi_return_int_int){.arg0=0, .arg1=0};
	}
	
 	int space1 = (*(int*)_t1.data);
	_option_int _t3 = string_index_after(line, _SLIT(" "), (int)(space1 + 1));
	if (_t3.state != 0) {
		IError err = _t3.err;
		return (multi_return_int_int){.arg0=0, .arg1=0};
	}
	
 	int space2 = (*(int*)_t3.data);
	return (multi_return_int_int){.arg0=space1, .arg1=space2};
}
string net__http__Version_str(net__http__Version v) {
	return ((v == (net__http__Version__v1_1))? (_SLIT("HTTP/1.1")) : (v == (net__http__Version__v2_0))? (_SLIT("HTTP/2.0")) : (v == (net__http__Version__v1_0))? (_SLIT("HTTP/1.0")) : (_SLIT("unknown")));
}
net__http__Version net__http__version_from_str(string v) {
	string _t2 = string_to_lower(v);
	return ((_SLIT_EQ(_t2.str, _t2.len, "http/1.1"))? (net__http__Version__v1_1) : (_SLIT_EQ(_t2.str, _t2.len, "http/2.0"))? (net__http__Version__v2_0) : (_SLIT_EQ(_t2.str, _t2.len, "http/1.0"))? (net__http__Version__v1_0) : (net__http__Version__unknown));
}
multi_return_int_int net__http__Version_protos(net__http__Version v) {

	if (v == (net__http__Version__v1_1)) {
		return (multi_return_int_int){.arg0=1, .arg1=1};
	}
	else if (v == (net__http__Version__v2_0)) {
		return (multi_return_int_int){.arg0=2, .arg1=0};
	}
	else if (v == (net__http__Version__v1_0)) {
		return (multi_return_int_int){.arg0=1, .arg1=0};
	}
	else if (v == (net__http__Version__unknown)) {
		return (multi_return_int_int){.arg0=0, .arg1=0};
	}
	return (multi_return_int_int){0};
}
_result_string veb__Context_get_header(veb__Context* ctx, net__http__CommonHeader key) {
	_result_string _t2 = net__http__Header_get(ctx->req.header, key);
	if (_t2.is_error) {
		_result_string _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_string _t1 = {0};
	_result_ok(&(string[]) { (*(string*)_t2.data) }, (_result*)(&_t1), sizeof(string));
	return _t1;
}
_result_string veb__Context_get_custom_header(veb__Context* ctx, string key) {
	_result_string _t2 = net__http__Header_get_custom(ctx->req.header, key, ((net__http__HeaderQueryConfig){.exact = 0,}));
	if (_t2.is_error) {
		_result_string _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_string _t1 = {0};
	_result_ok(&(string[]) { (*(string*)_t2.data) }, (_result*)(&_t1), sizeof(string));
	return _t1;
}
void veb__Context_set_header(veb__Context* ctx, net__http__CommonHeader key, string value) {
	net__http__Header_set(&ctx->res.header, key, value);
}
_result_void veb__Context_set_custom_header(veb__Context* ctx, string key, string value) {
	_result_void _t1 = net__http__Header_set_custom(&ctx->res.header, key, value);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
veb__Result veb__Context_send_response_to_client(veb__Context* ctx, string mimetype, string response) {
	if (ctx->done && !ctx->takeover) {
		eprintln(_SLIT("[veb] a response cannot be sent twice over one connection"));
		return ((veb__Result){EMPTY_STRUCT_INITIALIZATION});
	}
	ctx->done = true;
	ctx->res.body = response;
	string custom_mimetype = (ctx->content_type.len == 0 ? (mimetype) : (ctx->content_type));
	if ((custom_mimetype).len != 0) {
		net__http__Header_set(&ctx->res.header, net__http__CommonHeader__content_type, custom_mimetype);
	}
	if ((ctx->res.body).len != 0) {
		net__http__Header_set(&ctx->res.header, net__http__CommonHeader__content_length, int_str(ctx->res.body.len));
	}
	net__http__Header_set(&ctx->res.header, net__http__CommonHeader__server, _SLIT("veb"));
	if (!ctx->takeover && ctx->client_wants_to_close) {
		net__http__Header_set(&ctx->res.header, net__http__CommonHeader__connection, _SLIT("close"));
	}
	net__http__Response_set_version(&ctx->res, net__http__Version__v1_1);
	if (ctx->res.status_code == 0) {
		net__http__Response_set_status(&ctx->res, net__http__Status__ok);
	}
	if (ctx->takeover) {
		_result_void _t2 = veb__fast_send_resp(ctx->conn, ctx->res);
		(void)_t2;
 ;
	}
	return ((veb__Result){EMPTY_STRUCT_INITIALIZATION});
}
veb__Result veb__Context_html(veb__Context* ctx, string s) {
	return veb__Context_send_response_to_client(ctx, _SLIT("text/html"), s);
}
veb__Result veb__Context_text(veb__Context* ctx, string s) {
	return veb__Context_send_response_to_client(ctx, _SLIT("text/plain"), s);
}
veb__Result veb__Context_file(veb__Context* ctx, string file_path) {
	if (!os__exists(file_path)) {
		eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] file \""), 0xfe10, {.d_s = file_path}}, {_SLIT("\" does not exist"), 0, { .d_c = 0 }}})));
		return veb__Context_not_found(ctx);
	}
	string ext = os__file_ext(file_path);
	string content_type = ctx->content_type;
	if (content_type.len == 0) {
		string* _t3 = (string*)(map_get_check(ADDR(map, ctx->custom_mime_types), &(string[]){ext}));
		_option_string _t2 = {0};
		if (_t3) {
			*((string*)&_t2.data) = *((string*)_t3);
		} else {
			_t2.state = 2; _t2.err = _v_error(_SLIT("map key does not exist"));
		}
		
		if (_t2.state == 0) {
			string ct = (*(string*)_t2.data);
			content_type = ct;
		} else {
			IError err = _t2.err;
			content_type = (*(string*)map_get(ADDR(map, _const_veb__mime_types), &(string[]){ext}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
		}
	}
	if (content_type.len == 0) {
		eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] no MIME type found for extension \""), 0xfe10, {.d_s = ext}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
		return veb__Context_server_error(ctx, _SLIT(""));
	}
	return veb__Context_send_file(ctx, content_type, file_path);
}
VV_LOCAL_SYMBOL veb__Result veb__Context_send_file(veb__Context* ctx, string content_type, string file_path) {
	_result_os__File _t1 = os__open(file_path);
	if (_t1.is_error) {
		IError err = _t1.err;
		eprint(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] error while trying to open file: "), 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		net__http__Response_set_status(&ctx->res, net__http__Status__not_found);
		return veb__Context_text(ctx, _SLIT("resource does not exist"));
	}
	
 	os__File file = (*(os__File*)_t1.data);
	_result_void _t3 = os__File_seek(&file, 0, os__SeekMode__end);
	if (_t3.is_error) {
		IError err = _t3.err;
		eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] error while trying to read file: "), 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return veb__Context_server_error(ctx, _SLIT("could not read resource"));
	}
	
 ;
	_result_i64 _t5 = os__File_tell(&file);
	if (_t5.is_error) {
		IError err = _t5.err;
		eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] error while trying to read file: "), 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return veb__Context_server_error(ctx, _SLIT("could not read resource"));
	}
	
 	i64 file_size = (*(i64*)_t5.data);
	os__File_close(&file);
	if (ctx->takeover) {
		_result_string _t7 = os__read_file(file_path);
		if (_t7.is_error) {
			IError err = _t7.err;
			eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] error while trying to read file: "), 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			return veb__Context_server_error(ctx, _SLIT("could not read resource"));
		}
		
 		string data = (*(string*)_t7.data);
		return veb__Context_send_response_to_client(ctx, content_type, data);
	} else {
		ctx->return_type = veb__ContextReturnType__file;
		ctx->return_file = file_path;
		veb__Context_send_response_to_client(ctx, content_type, _SLIT(""));
		net__http__Header_set(&ctx->res.header, net__http__CommonHeader__content_length, i64_str(file_size));
		return ((veb__Result){EMPTY_STRUCT_INITIALIZATION});
	}
	return (veb__Result){0};
}
veb__Result veb__Context_ok(veb__Context* ctx, string s) {
	string mime = (ctx->content_type.len == 0 ? (_SLIT("text/plain")) : (ctx->content_type));
	return veb__Context_send_response_to_client(ctx, mime, s);
}
veb__Result veb__Context_request_error(veb__Context* ctx, string msg) {
	net__http__Response_set_status(&ctx->res, net__http__Status__bad_request);
	return veb__Context_send_response_to_client(ctx, _SLIT("text/plain"), msg);
}
veb__Result veb__Context_server_error(veb__Context* ctx, string msg) {
	net__http__Response_set_status(&ctx->res, net__http__Status__internal_server_error);
	return veb__Context_send_response_to_client(ctx, _SLIT("text/plain"), msg);
}
veb__Result veb__Context_server_error_with_status(veb__Context* ctx, net__http__Status s) {
	net__http__Response_set_status(&ctx->res, s);
	return veb__Context_send_response_to_client(ctx, _SLIT("text/plain"), _SLIT("Server error"));
}
veb__Result veb__Context_no_content(veb__Context* ctx) {
	net__http__Response_set_status(&ctx->res, net__http__Status__no_content);
	return veb__Context_send_response_to_client(ctx, _SLIT(""), _SLIT(""));
}
veb__Result veb__Context_redirect(veb__Context* ctx, string url, veb__RedirectParams params) {
	net__http__Status status = ((net__http__Status)(params.typ));
	net__http__Response_set_status(&ctx->res, status);
	net__http__Header_add(&ctx->res.header, net__http__CommonHeader__location, url);
	return veb__Context_send_response_to_client(ctx, _SLIT("text/plain"), net__http__Status_str(status));
}
veb__Result veb__Context_before_request(veb__Context* ctx) {
	return ((veb__Result){EMPTY_STRUCT_INITIALIZATION});
}
veb__Result veb__Context_not_found(veb__Context* ctx) {
	net__http__Response_set_status(&ctx->res, net__http__Status__not_found);
	return veb__Context_send_response_to_client(ctx, _SLIT("text/plain"), _SLIT("404 Not Found"));
}
_option_string veb__Context_get_cookie(veb__Context* ctx, string key) {
	_option_net__http__Cookie _t1;
	if (_t1 = net__http__Request_cookie(&ctx->req, key), _t1.state == 0) {
		net__http__Cookie cookie = *(net__http__Cookie*)_t1.data;
		_option_string _t2;
		_option_ok(&(string[]) { cookie.value }, (_option*)(&_t2), sizeof(string));
		return _t2;
	} else {
		IError err = _t1.err;
		return (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_option_string){.state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION}};
}
void veb__Context_set_cookie(veb__Context* ctx, net__http__Cookie cookie) {
	string cookie_raw = net__http__Cookie_str(&cookie);
	if ((cookie_raw).len == 0) {
		eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] error setting cookie: name of cookie is invalid.\n"), 0xfe10, {.d_s = net__http__Cookie_str(&cookie)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return;
	}
	net__http__Header_add(&ctx->res.header, net__http__CommonHeader__set_cookie, cookie_raw);
}
void veb__Context_set_content_type(veb__Context* ctx, string mime) {
	ctx->content_type = mime;
}
void veb__Context_takeover_conn(veb__Context* ctx) {
	ctx->takeover = true;
}
string veb__Context_user_agent(veb__Context* ctx) {
	_result_string _t2 = net__http__Header_get(ctx->req.header, net__http__CommonHeader__user_agent);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(string*) _t2.data = _SLIT("");
	}
	
 	return (*(string*)_t2.data);
}
string veb__Context_ip(veb__Context* ctx) {
	_result_string _t1 = net__http__Header_get_custom(ctx->req.header, _SLIT("CF-Connecting-IP"), ((net__http__HeaderQueryConfig){.exact = 0,}));
	if (_t1.is_error) {
		IError err = _t1.err;
		*(string*) _t1.data = _SLIT("");
	}
	
 	string ip = (*(string*)_t1.data);
	if ((ip).len == 0) {
		_result_string _t2 = net__http__Header_get(ctx->req.header, net__http__CommonHeader__x_forwarded_for);
		if (_t2.is_error) {
			IError err = _t2.err;
			*(string*) _t2.data = _SLIT("");
		}
		
 		ip = (*(string*)_t2.data);
	}
	if ((ip).len == 0) {
		_result_string _t3 = net__http__Header_get_custom(ctx->req.header, _SLIT("X-Forwarded-For"), ((net__http__HeaderQueryConfig){.exact = 0,}));
		if (_t3.is_error) {
			IError err = _t3.err;
			*(string*) _t3.data = _SLIT("");
		}
		
 		ip = (*(string*)_t3.data);
	}
	if ((ip).len == 0) {
		_result_string _t4 = net__http__Header_get_custom(ctx->req.header, _SLIT("X-Real-Ip"), ((net__http__HeaderQueryConfig){.exact = 0,}));
		if (_t4.is_error) {
			IError err = _t4.err;
			*(string*) _t4.data = _SLIT("");
		}
		
 		ip = (*(string*)_t4.data);
	}
	if (string_contains(ip, _SLIT(","))) {
		ip = string_all_before(ip, _SLIT(","));
	}
	if ((ip).len == 0) {
		_result_string _t5 = net__TcpConn_peer_ip(ctx->conn);
		if (_t5.is_error) {
			IError err = _t5.err;
			*(string*) _t5.data = _SLIT("");
		}
		
 		ip = (*(string*)_t5.data);
	}
	return ip;
}
VV_LOCAL_SYMBOL _result_Array_veb__ControllerPath_ptr veb__check_duplicate_routes_in_controllers_T_main__App(main__App* global_app, Map_string_veb__Route routes) {
	Array_veb__ControllerPath_ptr controllers_sorted = __new_array_with_default(0, 0, sizeof(veb__ControllerPath*), 0);
	#if 0
	{
	}
	#endif
	_result_Array_veb__ControllerPath_ptr _t2 = {0};
	_result_ok(&(Array_veb__ControllerPath_ptr[]) { controllers_sorted }, (_result*)(&_t2), sizeof(Array_veb__ControllerPath_ptr));
	return _t2;
}
VV_LOCAL_SYMBOL string veb__filter(string s) {
	return encoding__html__escape(s, ((encoding__html__EscapeConfig){.quote = true,}));
}
string veb__Middleware_T_main__Context_str_T_main__Context(veb__Middleware_T_main__Context* m) {
	return str_intp(6, _MOV((StrIntpData[]){{_SLIT("veb.Middleware["), 0xfe10, {.d_s = _SLIT("Context")}}, {_SLIT("]{\n        global_handlers: ["), 0xfe07, {.d_i32 = m->global_handlers.len}}, {_SLIT("]\n        global_handlers_after: ["), 0xfe07, {.d_i32 = m->global_handlers_after.len}}, {_SLIT("]\n        route_handlers: ["), 0xfe07, {.d_i32 = m->route_handlers.len}}, {_SLIT("]\n        route_handlers_after: ["), 0xfe07, {.d_i32 = m->route_handlers_after.len}}, {_SLIT("]\n    }"), 0, { .d_c = 0 }}}));
}
void veb__Middleware_T_main__Context_use_T_main__Context(veb__Middleware_T_main__Context* m, veb__MiddlewareOptions_T_main__Context options) {
	if (options.after) {
		array_push((array*)&m->global_handlers_after, _MOV((voidptr[]){ ((voidptr)(options.handler)) }));
	} else {
		array_push((array*)&m->global_handlers, _MOV((voidptr[]){ ((voidptr)(options.handler)) }));
	}
}
void veb__Middleware_T_main__Context_route_use_T_main__Context(veb__Middleware_T_main__Context* m, string route, veb__MiddlewareOptions_T_main__Context options) {
	Array_string _t1 = {0};
	Array_string _t1_orig = string_split(route, _SLIT("/"));
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(string));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		string it = ((string*) _t1_orig.data)[_t2];
		if ((it).len != 0) {
			array_push((array*)&_t1, &it);
		}
	}
	veb__RouteMiddleware middleware = ((veb__RouteMiddleware){.url_parts =_t1,.handler = ((voidptr)(options.handler)),});
	if (options.after) {
		array_push((array*)&m->route_handlers_after, _MOV((veb__RouteMiddleware[]){ middleware }));
	} else {
		array_push((array*)&m->route_handlers, _MOV((veb__RouteMiddleware[]){ middleware }));
	}
}
VV_LOCAL_SYMBOL Array_voidptr veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(veb__Middleware_T_main__Context* m, string route_path) {
	Array_voidptr fns = __new_array_with_default(0, 0, sizeof(voidptr), 0);
	Array_string _t1 = {0};
	Array_string _t1_orig = string_split(route_path, _SLIT("/"));
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(string));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		string it = ((string*) _t1_orig.data)[_t2];
		if ((it).len != 0) {
			array_push((array*)&_t1, &it);
		}
	}
	Array_string route_parts =_t1;
	for (int _t3 = 0; _t3 < m->route_handlers.len; ++_t3) {
		veb__RouteMiddleware handler = ((veb__RouteMiddleware*)m->route_handlers.data)[_t3];
		_option_Array_string _t4;
		if (_t4 = veb__route_matches(route_parts, handler.url_parts), _t4.state == 0) {
			array_push((array*)&fns, _MOV((voidptr[]){ handler.handler }));
		} else if (handler.url_parts.len == 0 && _SLIT_EQ(route_path.str, route_path.len, "/index")) {
			array_push((array*)&fns, _MOV((voidptr[]){ handler.handler }));
		}
	}
	return fns;
}
VV_LOCAL_SYMBOL Array_voidptr veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(veb__Middleware_T_main__Context* m, string route_path) {
	Array_voidptr fns = __new_array_with_default(0, 0, sizeof(voidptr), 0);
	Array_string _t1 = {0};
	Array_string _t1_orig = string_split(route_path, _SLIT("/"));
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(string));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		string it = ((string*) _t1_orig.data)[_t2];
		if ((it).len != 0) {
			array_push((array*)&_t1, &it);
		}
	}
	Array_string route_parts =_t1;
	for (int _t3 = 0; _t3 < m->route_handlers_after.len; ++_t3) {
		veb__RouteMiddleware handler = ((veb__RouteMiddleware*)m->route_handlers_after.data)[_t3];
		_option_Array_string _t4;
		if (_t4 = veb__route_matches(route_parts, handler.url_parts), _t4.state == 0) {
			array_push((array*)&fns, _MOV((voidptr[]){ handler.handler }));
		} else if (handler.url_parts.len == 0 && _SLIT_EQ(route_path.str, route_path.len, "/index")) {
			array_push((array*)&fns, _MOV((voidptr[]){ handler.handler }));
		}
	}
	return fns;
}
VV_LOCAL_SYMBOL Array_voidptr veb__Middleware_T_main__Context_get_global_handlers_T_main__Context(veb__Middleware_T_main__Context* m) {
	return m->global_handlers;
}
VV_LOCAL_SYMBOL Array_voidptr veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(veb__Middleware_T_main__Context* m) {
	return m->global_handlers_after;
}
VV_LOCAL_SYMBOL bool veb__validate_middleware_T_main__Context(main__Context* ctx, Array_voidptr raw_handlers) {
	for (int _t1 = 0; _t1 < raw_handlers.len; ++_t1) {
		voidptr handler = ((voidptr*)raw_handlers.data)[_t1];
		bool (*func) (main__Context* ctx) = ((anon_fn_mut_main__context__bool)(handler));
		if (func(ctx) == false) {
			return false;
		}
	}
	return true;
}
void veb__CorsOptions_set_headers(veb__CorsOptions* options, veb__Context* ctx) {
	_result_string _t1 = net__http__Header_get(ctx->req.header, net__http__CommonHeader__origin);
	if (_t1.is_error) {
		IError err = _t1.err;
		return;
	}
	
 	string origin = (*(string*)_t1.data);
	if (!Array_string_arr_eq(options->origins, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("*")}))) && !(Array_string_contains(options->origins, origin))) {
		return;
	}
	veb__Context_set_header(ctx, net__http__CommonHeader__access_control_allow_origin, origin);
	veb__Context_set_header(ctx, net__http__CommonHeader__vary, _SLIT("Origin, Access-Control-Request-Headers"));
	if (options->allow_credentials) {
		veb__Context_set_header(ctx, net__http__CommonHeader__access_control_allow_credentials, _SLIT("true"));
	}
	bool _t3 = options->allowed_headers.len > 0;
	_result_string _t2;
	if (_t3) {
		veb__Context_set_header(ctx, net__http__CommonHeader__access_control_allow_headers, Array_string_join(options->allowed_headers, _SLIT(",")));
	} else if (_t2 = net__http__Header_get(ctx->req.header, net__http__CommonHeader__access_control_request_headers), !_t2.is_error) {
		veb__Context_set_header(ctx, net__http__CommonHeader__access_control_allow_headers, Array_string_join(_const_veb__cors_safelisted_response_headers, _SLIT(",")));
	}
	if (options->allowed_methods.len > 0) {
		string method_str = string_trim(Array_net__http__Method_str(options->allowed_methods), _SLIT("[]"));
		veb__Context_set_header(ctx, net__http__CommonHeader__access_control_allow_methods, method_str);
	}
	if (options->expose_headers.len > 0) {
		veb__Context_set_header(ctx, net__http__CommonHeader__access_control_expose_headers, Array_string_join(options->expose_headers, _SLIT(",")));
	}
	_option_int _t4;
	if (_t4 = options->max_age, _t4.state == 0) {
		int max_age = *(int*)_t4.data;
		veb__Context_set_header(ctx, net__http__CommonHeader__access_control_max_age, int_str(max_age));
	}
}
bool veb__CorsOptions_validate_request(veb__CorsOptions* options, veb__Context* ctx) {
	_result_string _t1 = net__http__Header_get(ctx->req.header, net__http__CommonHeader__origin);
	if (_t1.is_error) {
		IError err = _t1.err;
		return true;
	}
	
 	string origin = (*(string*)_t1.data);
	if (!Array_string_arr_eq(options->origins, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("*")}))) && !(Array_string_contains(options->origins, origin))) {
		net__http__Response_set_status(&ctx->res, net__http__Status__forbidden);
		veb__Context_text(ctx, _SLIT("invalid CORS origin"));
		return false;
	}
	veb__Context_set_header(ctx, net__http__CommonHeader__access_control_allow_origin, origin);
	veb__Context_set_header(ctx, net__http__CommonHeader__vary, _SLIT("Origin, Access-Control-Request-Headers"));
	if (!(Array_net__http__Method_contains(options->allowed_methods, ctx->req.method))) {
		net__http__Response_set_status(&ctx->res, net__http__Status__method_not_allowed);
		veb__Context_text(ctx, str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = net__http__Method_str(ctx->req.method)}}, {_SLIT(" requests are not allowed"), 0, { .d_c = 0 }}})));
		return false;
	}
	if (options->allowed_headers.len > 0 && !Array_string_arr_eq(options->allowed_headers, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("*")})))) {
		Array_string _t5 = net__http__Header_keys(ctx->req.header);
		for (int _t6 = 0; _t6 < _t5.len; ++_t6) {
			string header = ((string*)_t5.data)[_t6];
			if (!(Array_string_contains(options->allowed_headers, header))) {
				net__http__Response_set_status(&ctx->res, net__http__Status__forbidden);
				veb__Context_text(ctx, str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid Header \""), 0xfe10, {.d_s = header}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
				return false;
			}
		}
	}
	return true;
}
veb__MiddlewareOptions_T_main__Context veb__cors_T_main__Context(veb__CorsOptions options) {
	return ((veb__MiddlewareOptions_T_main__Context){.handler = (voidptr)	__closure_create(anon_fn_ccb961b82e6b9984_mut_t__bool_9654_T_main__Context, (struct _V_anon_fn_ccb961b82e6b9984_mut_t__bool_9654_T_main__Context_Ctx*) memdup_uncollectable(&(struct _V_anon_fn_ccb961b82e6b9984_mut_t__bool_9654_T_main__Context_Ctx){.options = options,
	}, sizeof(struct _V_anon_fn_ccb961b82e6b9984_mut_t__bool_9654_T_main__Context_Ctx))),.after = 0,});
}
VV_LOCAL_SYMBOL _result_multi_return_Array_net__http__Method_string_string veb__parse_attrs(string name, Array_string attrs) {
	if (attrs.len == 0) {
		_result_multi_return_Array_net__http__Method_string_string _t1;
		_result_ok(&(multi_return_Array_net__http__Method_string_string[]) { (multi_return_Array_net__http__Method_string_string){.arg0=new_array_from_c_array_noscan(1, 1, sizeof(net__http__Method), _MOV((net__http__Method[1]){net__http__Method__get})), .arg1=str_intp(2, _MOV((StrIntpData[]){{_SLIT("/"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}})), .arg2=_SLIT("")} }, (_result*)(&_t1), sizeof(multi_return_Array_net__http__Method_string_string));
		return _t1;
	}
	Array_string x = array_clone_to_depth(&attrs, 0);
	Array_net__http__Method methods = __new_array_with_default_noscan(0, 0, sizeof(net__http__Method), 0);
	string path = _SLIT("");
	string host = _SLIT("");
	for (int i = 0; i < x.len; ) {
		string attr = (*(string*)array_get(x, i));
		string attru = string_to_upper(attr);
		net__http__Method m = net__http__method_from_str(attru);
		if (_SLIT_EQ(attru.str, attru.len, "GET") || m != net__http__Method__get) {
			array_push_noscan((array*)&methods, _MOV((net__http__Method[]){ m }));
			array_delete(&x, i);
			continue;
		}
		if (string_starts_with(attr, _SLIT("/"))) {
			if ((path).len != 0) {
				return (_result_multi_return_Array_net__http__Method_string_string){ .is_error=true, .err=I_net__http__MultiplePathAttributesError_to_Interface_IError(((net__http__MultiplePathAttributesError*)memdup(&(net__http__MultiplePathAttributesError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(net__http__MultiplePathAttributesError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			path = attr;
			array_delete(&x, i);
			continue;
		}
		if (string_starts_with(attr, _SLIT("host:"))) {
			host = string_trim_space(string_all_after(attr, _SLIT("host:")));
			array_delete(&x, i);
			continue;
		}
		i++;
	}
	if (x.len > 0) {
		return (_result_multi_return_Array_net__http__Method_string_string){ .is_error=true, .err=I_net__http__UnexpectedExtraAttributeError_to_Interface_IError(((net__http__UnexpectedExtraAttributeError*)memdup(&(net__http__UnexpectedExtraAttributeError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),.attributes = x,}, sizeof(net__http__UnexpectedExtraAttributeError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (methods.len == 0) {
		methods = new_array_from_c_array_noscan(1, 1, sizeof(net__http__Method), _MOV((net__http__Method[1]){net__http__Method__get}));
	}
	if ((path).len == 0) {
		path = str_intp(2, _MOV((StrIntpData[]){{_SLIT("/"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	_result_multi_return_Array_net__http__Method_string_string _t5;
	_result_ok(&(multi_return_Array_net__http__Method_string_string[]) { (multi_return_Array_net__http__Method_string_string){.arg0=methods, .arg1=path, .arg2=string_to_lower(host)} }, (_result*)(&_t5), sizeof(multi_return_Array_net__http__Method_string_string));
	return _t5;
}
VV_LOCAL_SYMBOL Map_string_string veb__parse_query_from_url(net__urllib__URL url) {
	Map_string_string query = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	for (int _t1 = 0; _t1 < net__urllib__URL_query(&url).data.len; ++_t1) {
		net__urllib__QueryValue qvalue = ((net__urllib__QueryValue*)net__urllib__URL_query(&url).data.data)[_t1];
		map_set(&query, &(string[]){qvalue.key}, &(string[]) { qvalue.value });
	}
	return query;
}
VV_LOCAL_SYMBOL _result_multi_return_Map_string_string_Map_string_Array_net__http__FileData veb__parse_form_from_request(net__http__Request request) {
	if (!(request.method == net__http__Method__post || request.method == net__http__Method__put || request.method == net__http__Method__patch)) {
		_result_multi_return_Map_string_string_Map_string_Array_net__http__FileData _t1;
		_result_ok(&(multi_return_Map_string_string_Map_string_Array_net__http__FileData[]) { (multi_return_Map_string_string_Map_string_Array_net__http__FileData){.arg0=new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
		, .arg1=new_map(sizeof(string), sizeof(Array_net__http__FileData), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
		} }, (_result*)(&_t1), sizeof(multi_return_Map_string_string_Map_string_Array_net__http__FileData));
		return _t1;
	}
	_result_string _t4 = net__http__Header_get(request.header, net__http__CommonHeader__content_type);
	if (_t4.is_error) {
		IError err = _t4.err;
		*(string*) _t4.data = _SLIT("");
	}
	
 	Array_string _t2 = {0};
	Array_string _t2_orig = string_split((*(string*)_t4.data), _SLIT(";"));
	int _t2_len = _t2_orig.len;
	_t2 = __new_array(0, _t2_len, sizeof(string));

	for (int _t5 = 0; _t5 < _t2_len; ++_t5) {
		string it = ((string*) _t2_orig.data)[_t5];
		string _t3 = string_trim_left(it, _SLIT(" \t"));
		array_push((array*)&_t2, &_t3);
	}
	Array_string ct =_t2;
	if ((Array_string_contains(ct, _SLIT("multipart/form-data")))) {
		Array_string _t6 = {0};
		Array_string _t6_orig = ct;
		int _t6_len = _t6_orig.len;
		_t6 = __new_array(0, _t6_len, sizeof(string));

		for (int _t7 = 0; _t7 < _t6_len; ++_t7) {
			string it = ((string*) _t6_orig.data)[_t7];
			if (string_starts_with(it, _const_veb__boundary_start)) {
				array_push((array*)&_t6, &it);
			}
		}
		Array_string boundaries =_t6;
		if (boundaries.len != 1) {
			return (_result_multi_return_Map_string_string_Map_string_Array_net__http__FileData){ .is_error=true, .err=_v_error(_SLIT("detected more that one form-data boundary")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		string boundary = string_all_after((*(string*)array_get(boundaries, 0)), _const_veb__boundary_start);
		if (boundary.len > 0 && string_at(boundary, 0) == '"') {
			_result_multi_return_Map_string_string_Map_string_Array_net__http__FileData _t9 = {0};
			_result_ok(&(multi_return_Map_string_string_Map_string_Array_net__http__FileData[]) { net__http__parse_multipart_form(request.data, string_trim(boundary, _SLIT("\""))) }, (_result*)(&_t9), sizeof(multi_return_Map_string_string_Map_string_Array_net__http__FileData));
			return _t9;
		}
		_result_multi_return_Map_string_string_Map_string_Array_net__http__FileData _t10 = {0};
		_result_ok(&(multi_return_Map_string_string_Map_string_Array_net__http__FileData[]) { net__http__parse_multipart_form(request.data, boundary) }, (_result*)(&_t10), sizeof(multi_return_Map_string_string_Map_string_Array_net__http__FileData));
		return _t10;
	}
	_result_multi_return_Map_string_string_Map_string_Array_net__http__FileData _t11;
	_result_ok(&(multi_return_Map_string_string_Map_string_Array_net__http__FileData[]) { (multi_return_Map_string_string_Map_string_Array_net__http__FileData){.arg0=net__http__parse_form(request.data), .arg1=new_map(sizeof(string), sizeof(Array_net__http__FileData), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	} }, (_result*)(&_t11), sizeof(multi_return_Map_string_string_Map_string_Array_net__http__FileData));
	return _t11;
}
VV_LOCAL_SYMBOL int veb__sendfile(int out_fd, int in_fd, int nr_bytes) {
	return sendfile(out_fd, in_fd, 0, nr_bytes);
}
VV_LOCAL_SYMBOL _result_void veb__StaticHandler_scan_static_directory(veb__StaticHandler* sh, string directory_path, string mount_path, string host) {
	_result_Array_string _t1 = os__ls(directory_path);
	if (_t1.is_error) {
		IError err = _t1.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 	Array_string files = (*(Array_string*)_t1.data);
	if (files.len > 0) {
		for (int _t2 = 0; _t2 < files.len; ++_t2) {
			string file = ((string*)files.data)[_t2];
			string full_path = os__join_path(directory_path, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){file})));
			if (os__is_dir(full_path)) {
				_result_void _t3 = veb__StaticHandler_scan_static_directory(sh, full_path, string__plus(string__plus(string_trim_right(mount_path, _SLIT("/")), _SLIT("/")), file), host);
				if (_t3.is_error) {
					_result_void _t4;
					memcpy(&_t4, &_t3, sizeof(_result));
					return _t4;
				}
				
 ;
			} else if (string_contains(file, _SLIT(".")) && !string_starts_with(file, _SLIT(".")) && !string_ends_with(file, _SLIT("."))) {
				_result_void _t5 = veb__StaticHandler_host_serve_static(sh, host, string__plus(string__plus(string_trim_right(mount_path, _SLIT("/")), _SLIT("/")), file), full_path);
				if (_t5.is_error) {
					_result_void _t6;
					memcpy(&_t6, &_t5, sizeof(_result));
					return _t6;
				}
				
 ;
			}
		}
	}
	return (_result_void){0};
}
_result_bool veb__StaticHandler_handle_static(veb__StaticHandler* sh, string directory_path, bool root) {
	_result_bool _t2 = veb__StaticHandler_host_handle_static(sh, _SLIT(""), directory_path, root);
	if (_t2.is_error) {
		_result_bool _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_bool _t1 = {0};
	_result_ok(&(bool[]) { (*(bool*)_t2.data) }, (_result*)(&_t1), sizeof(bool));
	return _t1;
}
_result_bool veb__StaticHandler_host_handle_static(veb__StaticHandler* sh, string host, string directory_path, bool root) {
	if (!os__exists(directory_path)) {
		return (_result_bool){ .is_error=true, .err=_v_error(str_intp(3, _MOV((StrIntpData[]){{_SLIT("directory `"), 0xfe10, {.d_s = directory_path}}, {_SLIT("` does not exist. The directory should be relative to the current working directory: "), 0xfe10, {.d_s = os__getwd()}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string dir_path = string_trim_right(string_trim_space(directory_path), _SLIT("/"));
	string mount_path = _SLIT("");
	if (_SLIT_NE(dir_path.str, dir_path.len, ".") && os__is_dir(dir_path) && !root) {
		mount_path = string__plus(_SLIT("/"), string_trim(string_trim_left(dir_path, _SLIT(".")), _SLIT("/")));
	}
	_result_void _t2 = veb__StaticHandler_scan_static_directory(sh, dir_path, mount_path, host);
	if (_t2.is_error) {
		_result_bool _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 ;
	_result_bool _t4 = {0};
	_result_ok(&(bool[]) { true }, (_result*)(&_t4), sizeof(bool));
	return _t4;
}
_result_void veb__StaticHandler_host_serve_static(veb__StaticHandler* sh, string host, string url, string file_path) {
	string ext = string_to_lower(os__file_ext(file_path));
	if (!_IN_MAP(ADDR(string, ext), ADDR(map, sh->static_mime_types)) && !_IN_MAP(ADDR(string, ext), ADDR(map, _const_veb__mime_types))) {
		return (_result_void){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown MIME type for file extension \""), 0xfe10, {.d_s = ext}}, {_SLIT("\". You can register your MIME type in `app.static_mime_types`"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	map_set(&sh->static_files, &(string[]){url}, &(string[]) { file_path });
	map_set(&sh->static_hosts, &(string[]){url}, &(string[]) { host });
	return (_result_void){0};
}
veb__Result veb__no_result(void) {
	return ((veb__Result){EMPTY_STRUCT_INITIALIZATION});
}
VV_LOCAL_SYMBOL _result_Map_string_veb__Route veb__generate_routes_T_main__App_main__Context(main__App* app) {
	Map_string_veb__Route routes = new_map(sizeof(string), sizeof(veb__Route), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	/* $for method in main.App.methods */ {
		FunctionData method = {0};
		/* method 0 */ {
			method.name = _SLIT("index");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t2 = veb__parse_attrs(method.name, method.attrs);
				if (_t2.is_error) {
					IError err = _t2.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t2.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 1 */ {
			method.name = _SLIT("find_index");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/index.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t6 = veb__parse_attrs(method.name, method.attrs);
				if (_t6.is_error) {
					IError err = _t6.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t6.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 2 */ {
			method.name = _SLIT("error");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/error.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t10 = veb__parse_attrs(method.name, method.attrs);
				if (_t10.is_error) {
					IError err = _t10.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t10.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 3 */ {
			method.name = _SLIT("login");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/login.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t14 = veb__parse_attrs(method.name, method.attrs);
				if (_t14.is_error) {
					IError err = _t14.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t14.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 4 */ {
			method.name = _SLIT("loginapi");
			method.attrs = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/loginapi"), _SLIT("post")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t18 = veb__parse_attrs(method.name, method.attrs);
				if (_t18.is_error) {
					IError err = _t18.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t18.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 5 */ {
			method.name = _SLIT("signup");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/signup.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t22 = veb__parse_attrs(method.name, method.attrs);
				if (_t22.is_error) {
					IError err = _t22.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t22.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 6 */ {
			method.name = _SLIT("signupapi");
			method.attrs = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/signupapi"), _SLIT("post")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t26 = veb__parse_attrs(method.name, method.attrs);
				if (_t26.is_error) {
					IError err = _t26.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t26.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 7 */ {
			method.name = _SLIT("member");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/member.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t30 = veb__parse_attrs(method.name, method.attrs);
				if (_t30.is_error) {
					IError err = _t30.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t30.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 8 */ {
			method.name = _SLIT("memberapi");
			method.attrs = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/memberapi"), _SLIT("post")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t34 = veb__parse_attrs(method.name, method.attrs);
				if (_t34.is_error) {
					IError err = _t34.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t34.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 9 */ {
			method.name = _SLIT("challenge");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/challenge.html")}));

			method.args = new_array_from_c_array(2, 2, sizeof(MethodParam), _MOV((MethodParam[2]){{107, _SLIT("ctx")}, {21, _SLIT("display_challenge")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t38 = veb__parse_attrs(method.name, method.attrs);
				if (_t38.is_error) {
					IError err = _t38.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t38.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 10 */ {
			method.name = _SLIT("flagapi");
			method.attrs = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/flagapi"), _SLIT("post")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t42 = veb__parse_attrs(method.name, method.attrs);
				if (_t42.is_error) {
					IError err = _t42.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t42.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 11 */ {
			method.name = _SLIT("team");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/team.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t46 = veb__parse_attrs(method.name, method.attrs);
				if (_t46.is_error) {
					IError err = _t46.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t46.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 12 */ {
			method.name = _SLIT("ranking");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/ranking.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t50 = veb__parse_attrs(method.name, method.attrs);
				if (_t50.is_error) {
					IError err = _t50.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t50.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 13 */ {
			method.name = _SLIT("rankapi");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/rankapi")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t54 = veb__parse_attrs(method.name, method.attrs);
				if (_t54.is_error) {
					IError err = _t54.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t54.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 14 */ {
			method.name = _SLIT("notice");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/notice.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t58 = veb__parse_attrs(method.name, method.attrs);
				if (_t58.is_error) {
					IError err = _t58.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t58.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
		/* method 15 */ {
			method.name = _SLIT("console");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/console.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				_result_multi_return_Array_net__http__Method_string_string _t62 = veb__parse_attrs(method.name, method.attrs);
				if (_t62.is_error) {
					IError err = _t62.err;
					return (_result_Map_string_veb__Route){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("error parsing method attributes: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				multi_return_Array_net__http__Method_string_string mr_1119 = (*(multi_return_Array_net__http__Method_string_string*)_t62.data);
				Array_net__http__Method http_methods = mr_1119.arg0;
				string route_path = mr_1119.arg1;
				string host = mr_1119.arg2;
				veb__Route route = ((veb__Route){.methods = http_methods,.path = route_path,.host = host,.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				#if 1 && false == false
				{
					route.middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_T_main__Context(&app->Middleware, route_path);
					route.after_middlewares = veb__Middleware_T_main__Context_get_handlers_for_route_after_T_main__Context(&app->Middleware, route_path);
				}
				#endif
				(*(veb__Route*)map_get_and_set((map*)&routes, &(string[]){method.name}, &(veb__Route[]){ (veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),} })) = route;
			}
			#endif
		}
	}// $for
	_result_Map_string_veb__Route _t65 = {0};
	_result_ok(&(Map_string_veb__Route[]) { routes }, (_result*)(&_t65), sizeof(Map_string_veb__Route));
	return _t65;
}
void veb__FileResponse_done(veb__FileResponse* fr) {
	fr->open = false;
	os__File_close(&fr->file);
	fr->total = 0;
	fr->pos = 0;
	fr->should_close_conn = false;
}
void veb__StringResponse_done(veb__StringResponse* sr) {
	sr->open = false;
	sr->pos = 0;
	sr->should_close_conn = false;
	string_free(&sr->str);
}
void veb__RequestParams_request_done(veb__RequestParams* params, int fd) {
	array_set(&params->incomplete_requests, fd, &(net__http__Request[]) { ((net__http__Request){.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.version = net__http__Version__v1_1,.method = net__http__Method__get,.header = ((net__http__Header){.data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.cur_pos = 0,}),.host = (string){.str=(byteptr)"", .is_lit=1},.data = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.user_agent = _SLIT("v.http"),.verbose = 0,.user_ptr = 0,.proxy = ((void*)0),.read_timeout = 30 * _const_time__second,.write_timeout = 30 * _const_time__second,.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_progress_body = ((void*)0),.on_finish = ((void*)0),.stop_copying_limit = -1,.stop_receiving_limit = -1,}) });
	array_set(&params->idx, fd, &(int[]) { 0 });
}
_result_void veb__run_at_T_main__App_main__Context(main__App* global_app, veb__RunParams params) {
	bool veb__run_at_T_main__App_main__Context_defer_0 = false;
	veb__RequestParams* pico_context;
	if (params.port <= 0 || params.port > 65535) {
		return (_result_void){ .is_error=true, .err=_v_error(str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid port number `"), 0xfe07, {.d_i32 = params.port}}, {_SLIT("`, it should be between 1 and 65535"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_Map_string_veb__Route _t2 = veb__generate_routes_T_main__App_main__Context(global_app);
	if (_t2.is_error) {
		_result_void _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	Map_string_veb__Route *routes = HEAP(Map_string_veb__Route, ((*(Map_string_veb__Route*)_t2.data)));
	_result_Array_veb__ControllerPath_ptr _t4 = veb__check_duplicate_routes_in_controllers_T_main__App(global_app, *routes);
	if (_t4.is_error) {
		_result_void _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	Array_veb__ControllerPath_ptr controllers_sorted = (*(Array_veb__ControllerPath_ptr*)_t4.data);
	if (params.show_startup_message) {
		string host = ((params.host).len == 0 ? (_SLIT("localhost")) : (params.host));
		println(str_intp(3, _MOV((StrIntpData[]){{_SLIT("[veb] Running app on http://"), 0xfe10, {.d_s = host}}, {_SLIT(":"), 0xfe07, {.d_i32 = params.port}}, {_SLIT("/"), 0, { .d_c = 0 }}})));
	}
	flush_stdout();
	pico_context = ((veb__RequestParams*)memdup(&(veb__RequestParams){.global_app = global_app,.controllers = controllers_sorted,.routes = &*routes,.timeout_in_seconds = params.timeout_in_seconds,.buf = ((void*)0),.idx = __new_array_noscan(0, 0, sizeof(int)),.incomplete_requests = __new_array(0, 0, sizeof(net__http__Request)),.file_responses = __new_array(0, 0, sizeof(veb__FileResponse)),.string_responses = __new_array(0, 0, sizeof(veb__StringResponse)),}, sizeof(veb__RequestParams)));
	pico_context->idx = __new_array_with_default_noscan(_const_picoev__max_fds, 0, sizeof(int), 0);
	pico_context->buf = malloc_noscan((int_literal)((int_literal)(1024 * 8096) + 1));
	veb__run_at_T_main__App_main__Context_defer_0 = true;
	net__http__Request* _t6 = (net__http__Request*) _v_malloc((_const_picoev__max_fds) * sizeof(net__http__Request));
	for (int _t7=0; _t7<_const_picoev__max_fds; _t7++) {
		_t6[_t7] = (net__http__Request){.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.version = net__http__Version__v1_1,.method = net__http__Method__get,.header = (net__http__Header){.data = {0},.cur_pos = 0,},.host = (string){.str=(byteptr)"", .is_lit=1},.data = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.user_agent = _SLIT("v.http"),.verbose = 0,.user_ptr = 0,.proxy = ((void*)0),.read_timeout = 30 * _const_time__second,.write_timeout = 30 * _const_time__second,.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_progress_body = ((void*)0),.on_finish = ((void*)0),.stop_copying_limit = -1,.stop_receiving_limit = -1,};
	}
	pico_context->incomplete_requests = __new_array_with_multi_default(_const_picoev__max_fds, 0, sizeof(net__http__Request), (voidptr)_t6);
	pico_context->file_responses = __new_array_with_default(_const_picoev__max_fds, 0, sizeof(veb__FileResponse), (voidptr)&(veb__FileResponse[]){(veb__FileResponse){.open = 0,.file = (os__File){.cfile = 0,.fd = 0,.is_opened = 0,},.total = 0,.pos = 0,.should_close_conn = 0,}}[0]);
	pico_context->string_responses = __new_array_with_default(_const_picoev__max_fds, 0, sizeof(veb__StringResponse), (voidptr)&(veb__StringResponse[]){(veb__StringResponse){.open = 0,.str = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.should_close_conn = 0,}}[0]);
	_result_picoev__Picoev_ptr _t8 = picoev__new(((picoev__Config){
		.port = params.port,
		.cb = ((void*)0),
		.err_cb = picoev__default_error_callback,
		.raw_cb = (voidptr)veb__ev_callback_T_main__App_main__Context,
		.user_data = pico_context,
		.timeout_secs = params.timeout_in_seconds,
		.max_headers = 100,
		.max_read = 4096,
		.max_write = 8192,
		.family = params.family,
		.host = params.host,
	}));
	if (_t8.is_error) {
	// Defer begin
	if (veb__run_at_T_main__App_main__Context_defer_0) {
		_v_free(pico_context->buf);
	}
	// Defer end
		_result_void _t9;
		memcpy(&_t9, &_t8, sizeof(_result));
		return _t9;
	}
	
 	picoev__Picoev* pico = (*(picoev__Picoev**)_t8.data);
	#if 0
	{
	}
	#endif
	picoev__Picoev_serve(pico);
	// Defer begin
	if (veb__run_at_T_main__App_main__Context_defer_0) {
		_v_free(pico_context->buf);
	}
	// Defer end
	return (_result_void){0};
}
VV_LOCAL_SYMBOL void veb__ev_callback_T_main__App_main__Context(picoev__Picoev* pv, int fd, int events) {
	veb__RequestParams* params = ((veb__RequestParams*)(pv->user_data));
	if (events == 4) {
		veb__handle_timeout(pv, params, fd);
	} else if (events == 2) {
		if (((veb__FileResponse*)params->file_responses.data)[fd].open) {
			veb__handle_write_file(pv, params, fd);
		} else if (((veb__StringResponse*)params->string_responses.data)[fd].open) {
			veb__handle_write_string(pv, params, fd);
		} else {
			picoev__Picoev_close_conn(pv, fd);
		}
	} else if (events == 1) {
		veb__handle_read_T_main__App_main__Context(pv, params, fd);
	} else {
		eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] error: invalid picoev event "), 0xfe07, {.d_i32 = events}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}
VV_LOCAL_SYMBOL void veb__handle_timeout(picoev__Picoev* pv, veb__RequestParams* params, int fd) {
	net__TcpConn* conn = ((net__TcpConn*)memdup(&(net__TcpConn){.sock = net__tcp_socket_from_handle_raw(fd),.handle = fd,.write_deadline = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.read_deadline = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.read_timeout = 0,.write_timeout = 0,.is_blocking = false,}, sizeof(net__TcpConn)));
	_result_void _t1 = veb__fast_send_resp(conn, _const_veb__http_408);
	(void)_t1;
 ;
	picoev__Picoev_close_conn(pv, fd);
	veb__RequestParams_request_done(params, fd);
}
VV_LOCAL_SYMBOL void veb__handle_write_file(picoev__Picoev* pv, veb__RequestParams* params, int fd) {
	int bytes_to_write = ((int)((i64)(((veb__FileResponse*)params->file_responses.data)[fd].total - ((veb__FileResponse*)params->file_responses.data)[fd].pos)));
	#if defined(__linux__) || defined(__FreeBSD__)
	{
		int bytes_written = veb__sendfile(fd, ((veb__FileResponse*)params->file_responses.data)[fd].file.fd, bytes_to_write);
		if (bytes_written < 0) {
			((veb__FileResponse*)params->file_responses.data)[fd].pos += bytes_to_write;
		} else {
			((veb__FileResponse*)params->file_responses.data)[fd].pos += bytes_written;
		}
	}
	#else
	{
	}
	#endif
	if (((veb__FileResponse*)params->file_responses.data)[fd].pos == ((veb__FileResponse*)params->file_responses.data)[fd].total) {
		veb__FileResponse_done(&((veb__FileResponse*)params->file_responses.data)[fd]);
		veb__handle_complete_request(((veb__FileResponse*)params->file_responses.data)[fd].should_close_conn, pv, fd);
		return;
	}
}
VV_LOCAL_SYMBOL void veb__handle_write_string(picoev__Picoev* pv, veb__RequestParams* params, int fd) {
	int bytes_to_write = ((int)((i64)(((veb__StringResponse*)params->string_responses.data)[fd].str.len - ((veb__StringResponse*)params->string_responses.data)[fd].pos)));
	if (bytes_to_write > _const_veb__max_write) {
		bytes_to_write = _const_veb__max_write;
	}
	net__TcpConn* conn = ((net__TcpConn*)memdup(&(net__TcpConn){.sock = net__tcp_socket_from_handle_raw(fd),.handle = fd,.write_deadline = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.read_deadline = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.read_timeout = 0,.write_timeout = 0,.is_blocking = false,}, sizeof(net__TcpConn)));
	u8* data = ((veb__StringResponse*)params->string_responses.data)[fd].str.str + ((veb__StringResponse*)params->string_responses.data)[fd].pos;
	_result_int _t1 = veb__send_string_ptr(conn, data, bytes_to_write);
	if (_t1.is_error) {
		IError err = _t1.err;
		veb__StringResponse_done(&((veb__StringResponse*)params->string_responses.data)[fd]);
		picoev__Picoev_close_conn(pv, fd);
		return;
	}
	
 	int actual_written = (*(int*)_t1.data);
	((veb__StringResponse*)params->string_responses.data)[fd].pos += actual_written;
	if (((veb__StringResponse*)params->string_responses.data)[fd].pos == ((veb__StringResponse*)params->string_responses.data)[fd].str.len) {
		veb__StringResponse_done(&((veb__StringResponse*)params->string_responses.data)[fd]);
		picoev__Picoev_close_conn(pv, fd);
		veb__handle_complete_request(((veb__StringResponse*)params->string_responses.data)[fd].should_close_conn, pv, fd);
		return;
	}
}
VV_LOCAL_SYMBOL void veb__handle_read_T_main__App_main__Context(picoev__Picoev* pv, veb__RequestParams* params, int fd) {
	bool veb__handle_read_T_main__App_main__Context_defer_0 = false;
	io__BufferedReader* reader;
	bool veb__handle_read_T_main__App_main__Context_defer_1 = false;
	net__TcpConn* conn = ((net__TcpConn*)memdup(&(net__TcpConn){.sock = net__tcp_socket_from_handle_raw(fd),.handle = fd,.write_deadline = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.read_deadline = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.read_timeout = 0,.write_timeout = 0,.is_blocking = false,}, sizeof(net__TcpConn)));
	reader = io__new_buffered_reader(((io__BufferedReaderConfig){.reader = I_net__TcpConn_to_Interface_io__Reader(conn),.cap = _const_veb__max_read,.retries = 2,}));
	veb__handle_read_T_main__App_main__Context_defer_0 = true;
	net__http__Request req = ((net__http__Request*)params->incomplete_requests.data)[fd];
	if (((int*)params->idx.data)[fd] == 0) {
		net__TcpConn_set_read_timeout(conn, params->timeout_in_seconds);
		net__TcpConn_set_write_timeout(conn, params->timeout_in_seconds);
		_result_net__http__Request _t1 = net__http__parse_request_head(reader);
		if (_t1.is_error) {
			IError err = _t1.err;
			if ((err)._typ != _IError_io__Eof_index) {
				eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] error parsing request: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			picoev__Picoev_close_conn(pv, fd);
			((net__http__Request*)params->incomplete_requests.data)[fd] = ((net__http__Request){.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.version = net__http__Version__v1_1,.method = net__http__Method__get,.header = ((net__http__Header){.data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.cur_pos = 0,}),.host = (string){.str=(byteptr)"", .is_lit=1},.data = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.user_agent = _SLIT("v.http"),.verbose = 0,.user_ptr = 0,.proxy = ((void*)0),.read_timeout = 30 * _const_time__second,.write_timeout = 30 * _const_time__second,.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_progress_body = ((void*)0),.on_finish = ((void*)0),.stop_copying_limit = -1,.stop_receiving_limit = -1,});
			// Defer begin
			if (veb__handle_read_T_main__App_main__Context_defer_0) {
				io__BufferedReader_free(reader);
			}
			// Defer end
			return;
		}
		
 		req = (*(net__http__Request*)_t1.data);
		if (reader->total_read >= 8096) {
			eprintln(_SLIT("[veb] error parsing request: too large"));
			_result_void _t2 = veb__fast_send_resp(conn, _const_veb__http_413);
			(void)_t2;
 ;
			picoev__Picoev_close_conn(pv, fd);
			((net__http__Request*)params->incomplete_requests.data)[fd] = ((net__http__Request){.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.version = net__http__Version__v1_1,.method = net__http__Method__get,.header = ((net__http__Header){.data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.cur_pos = 0,}),.host = (string){.str=(byteptr)"", .is_lit=1},.data = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.user_agent = _SLIT("v.http"),.verbose = 0,.user_ptr = 0,.proxy = ((void*)0),.read_timeout = 30 * _const_time__second,.write_timeout = 30 * _const_time__second,.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_progress_body = ((void*)0),.on_finish = ((void*)0),.stop_copying_limit = -1,.stop_receiving_limit = -1,});
			// Defer begin
			if (veb__handle_read_T_main__App_main__Context_defer_0) {
				io__BufferedReader_free(reader);
			}
			// Defer end
			return;
		}
	}
	_result_string _t3 = net__http__Header_get(req.header, net__http__CommonHeader__content_length);
	if (_t3.is_error) {
		IError err = _t3.err;
		*(string*) _t3.data = _SLIT("0");
	}
	
 	string content_length = (*(string*)_t3.data);
	if (string_int(content_length) > 0) {
		int max_bytes_to_read = (int)(8096 - reader->total_read);
		int bytes_to_read = (int)(string_int(content_length) - ((int*)params->idx.data)[fd]);
		if (bytes_to_read > (int)(8096 - reader->total_read)) {
			bytes_to_read = (int)(8096 - reader->total_read);
		}
		u8* buf_ptr = params->buf;
		{ // Unsafe block
			buf_ptr += (int)(fd * 8096);
		}
		Array_u8 buf = u8_vbytes(buf_ptr, max_bytes_to_read);
		_result_int _t4 = io__BufferedReader_read(reader, &buf);
		if (_t4.is_error) {
			IError err = _t4.err;
			if (reader->total_read > 0) {
				// Defer begin
				if (veb__handle_read_T_main__App_main__Context_defer_0) {
					io__BufferedReader_free(reader);
				}
				// Defer end
				return;
			}
			eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] error reading request body: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			if ((err)._typ == _IError_io__Eof_index) {
				_result_void _t5 = veb__fast_send_resp(conn, net__http__new_response(((net__http__ResponseConfig){.version = net__http__Version__v1_1,.status = net__http__Status__bad_request,.header = net__http__Header_join(net__http__new_header(new_array_from_c_array(1, 1, sizeof(net__http__HeaderConfig), _MOV((net__http__HeaderConfig[1]){((net__http__HeaderConfig){.key = net__http__CommonHeader__content_type,.value = _SLIT("text/plain"),})}))), _const_veb__headers_close),.body = _SLIT("Mismatch of body length and Content-Length header"),})));
				(void)_t5;
 ;
			}
			picoev__Picoev_close_conn(pv, fd);
			((net__http__Request*)params->incomplete_requests.data)[fd] = ((net__http__Request){.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.version = net__http__Version__v1_1,.method = net__http__Method__get,.header = ((net__http__Header){.data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.cur_pos = 0,}),.host = (string){.str=(byteptr)"", .is_lit=1},.data = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.user_agent = _SLIT("v.http"),.verbose = 0,.user_ptr = 0,.proxy = ((void*)0),.read_timeout = 30 * _const_time__second,.write_timeout = 30 * _const_time__second,.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_progress_body = ((void*)0),.on_finish = ((void*)0),.stop_copying_limit = -1,.stop_receiving_limit = -1,});
			((int*)params->idx.data)[fd] = 0;
			// Defer begin
			if (veb__handle_read_T_main__App_main__Context_defer_0) {
				io__BufferedReader_free(reader);
			}
			// Defer end
			return;
		}
		
 		int n = (*(int*)_t4.data);
		if ((n == 0 && ((int*)params->idx.data)[fd] != 0) || (int)(((int*)params->idx.data)[fd] + n) > string_int(content_length)) {
			_result_void _t6 = veb__fast_send_resp(conn, net__http__new_response(((net__http__ResponseConfig){.version = net__http__Version__v1_1,.status = net__http__Status__bad_request,.header = net__http__Header_join(net__http__new_header(new_array_from_c_array(1, 1, sizeof(net__http__HeaderConfig), _MOV((net__http__HeaderConfig[1]){((net__http__HeaderConfig){.key = net__http__CommonHeader__content_type,.value = _SLIT("text/plain"),})}))), _const_veb__headers_close),.body = _SLIT("Mismatch of body length and Content-Length header"),})));
			(void)_t6;
 ;
			picoev__Picoev_close_conn(pv, fd);
			((net__http__Request*)params->incomplete_requests.data)[fd] = ((net__http__Request){.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.version = net__http__Version__v1_1,.method = net__http__Method__get,.header = ((net__http__Header){.data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.cur_pos = 0,}),.host = (string){.str=(byteptr)"", .is_lit=1},.data = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.user_agent = _SLIT("v.http"),.verbose = 0,.user_ptr = 0,.proxy = ((void*)0),.read_timeout = 30 * _const_time__second,.write_timeout = 30 * _const_time__second,.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_progress_body = ((void*)0),.on_finish = ((void*)0),.stop_copying_limit = -1,.stop_receiving_limit = -1,});
			((int*)params->idx.data)[fd] = 0;
			// Defer begin
			if (veb__handle_read_T_main__App_main__Context_defer_0) {
				io__BufferedReader_free(reader);
			}
			// Defer end
			return;
		} else if (n < bytes_to_read || (int)(((int*)params->idx.data)[fd] + n) < string_int(content_length)) {
			((int*)params->idx.data)[fd] += n;
			req.data = string__plus(req.data, Array_u8_bytestr(array_slice(buf, 0, n)));
			((net__http__Request*)params->incomplete_requests.data)[fd] = req;
			// Defer begin
			if (veb__handle_read_T_main__App_main__Context_defer_0) {
				io__BufferedReader_free(reader);
			}
			// Defer end
			return;
		} else {
			((int*)params->idx.data)[fd] += n;
			req.data = string__plus(req.data, Array_u8_bytestr(array_slice(buf, 0, n)));
		}
	}
	veb__handle_read_T_main__App_main__Context_defer_1 = true;
	_option_veb__Context_ptr _t7;
	if (_t7 = veb__handle_request_T_main__App_main__Context(conn, req, params), _t7.state == 0) {
		veb__Context* completed_context = *(veb__Context**)_t7.data;
		if (completed_context->takeover) {
			picoev__Picoev_delete(pv, fd);
			// Defer begin
			if (veb__handle_read_T_main__App_main__Context_defer_1) {
				veb__RequestParams_request_done(params, fd);
			}
			// Defer end
			// Defer begin
			if (veb__handle_read_T_main__App_main__Context_defer_0) {
				io__BufferedReader_free(reader);
			}
			// Defer end
			return;
		}

		if (completed_context->return_type == (veb__ContextReturnType__normal)) {
			if (completed_context->res.body.len < 8096) {
				_result_void _t8 = veb__fast_send_resp(conn, completed_context->res);
				(void)_t8;
 ;
				veb__handle_complete_request(completed_context->client_wants_to_close, pv, fd);
			} else {
				((veb__StringResponse*)params->string_responses.data)[fd].open = true;
				((veb__StringResponse*)params->string_responses.data)[fd].str = completed_context->res.body;
				int res = picoev__Picoev_add(pv, fd, _const_picoev__picoev_write, params->timeout_in_seconds, picoev__raw_callback);
				if (res == -1) {
					veb__StringResponse_done(&((veb__StringResponse*)params->string_responses.data)[fd]);
					_result_void _t9 = veb__fast_send_resp(conn, _const_veb__http_500);
					(void)_t9;
 ;
					veb__handle_complete_request(completed_context->client_wants_to_close, pv, fd);
					// Defer begin
					if (veb__handle_read_T_main__App_main__Context_defer_1) {
						veb__RequestParams_request_done(params, fd);
					}
					// Defer end
					// Defer begin
					if (veb__handle_read_T_main__App_main__Context_defer_0) {
						io__BufferedReader_free(reader);
					}
					// Defer end
					return;
				}
				_result_void _t10 = veb__fast_send_resp_header(conn, completed_context->res);
				(void)_t10;
 ;
			}
		}
		else if (completed_context->return_type == (veb__ContextReturnType__file)) {
			_result_string _t11 = net__http__Header_get(completed_context->res.header, net__http__CommonHeader__content_length);
			if (_t11.is_error) {
				IError err = _t11.err;
				_result_void _t12 = veb__fast_send_resp(conn, _const_veb__http_500);
				(void)_t12;
 ;
				// Defer begin
				if (veb__handle_read_T_main__App_main__Context_defer_1) {
					veb__RequestParams_request_done(params, fd);
				}
				// Defer end
				// Defer begin
				if (veb__handle_read_T_main__App_main__Context_defer_0) {
					io__BufferedReader_free(reader);
				}
				// Defer end
				return;
			}
			
 			string length = (*(string*)_t11.data);
			((veb__FileResponse*)params->file_responses.data)[fd].total = string_i64(length);
			_result_os__File _t13 = os__open(completed_context->return_file);
			if (_t13.is_error) {
				IError err = _t13.err;
				_result_void _t14 = veb__fast_send_resp(conn, _const_veb__http_500);
				(void)_t14;
 ;
				veb__FileResponse_done(&((veb__FileResponse*)params->file_responses.data)[fd]);
				picoev__Picoev_close_conn(pv, fd);
				// Defer begin
				if (veb__handle_read_T_main__App_main__Context_defer_1) {
					veb__RequestParams_request_done(params, fd);
				}
				// Defer end
				// Defer begin
				if (veb__handle_read_T_main__App_main__Context_defer_0) {
					io__BufferedReader_free(reader);
				}
				// Defer end
				return;
			}
			
 			((veb__FileResponse*)params->file_responses.data)[fd].file = (*(os__File*)_t13.data);
			((veb__FileResponse*)params->file_responses.data)[fd].open = true;
			int res = picoev__Picoev_add(pv, fd, _const_picoev__picoev_write, params->timeout_in_seconds, picoev__raw_callback);
			if (res == -1) {
				_result_void _t15 = veb__fast_send_resp(conn, _const_veb__http_500);
				(void)_t15;
 ;
				veb__FileResponse_done(&((veb__FileResponse*)params->file_responses.data)[fd]);
				picoev__Picoev_close_conn(pv, fd);
				// Defer begin
				if (veb__handle_read_T_main__App_main__Context_defer_1) {
					veb__RequestParams_request_done(params, fd);
				}
				// Defer end
				// Defer begin
				if (veb__handle_read_T_main__App_main__Context_defer_0) {
					io__BufferedReader_free(reader);
				}
				// Defer end
				return;
			}
			_result_void _t16 = veb__fast_send_resp_header(conn, completed_context->res);
			(void)_t16;
 ;
		}
	} else {
		IError err = _t7.err;
		picoev__Picoev_close_conn(pv, fd);
	}
// Defer begin
if (veb__handle_read_T_main__App_main__Context_defer_1) {
	veb__RequestParams_request_done(params, fd);
}
// Defer end
// Defer begin
if (veb__handle_read_T_main__App_main__Context_defer_0) {
	io__BufferedReader_free(reader);
}
// Defer end
}
inline VV_LOCAL_SYMBOL void veb__handle_complete_request(bool should_close, picoev__Picoev* pv, int fd) {
	if (should_close) {
		picoev__Picoev_close_conn(pv, fd);
	}
}
VV_LOCAL_SYMBOL _option_veb__Context_ptr veb__handle_request_T_main__App_main__Context(net__TcpConn* conn, net__http__Request req, veb__RequestParams* params) {
	main__App* global_app = ((main__App*)(params->global_app));
	i64 page_gen_start = time__ticks();
	_result_net__urllib__URL _t1 = net__urllib__parse(req.url);
	if (_t1.is_error) {
		IError err = _t1.err;
		eprintln(str_intp(3, _MOV((StrIntpData[]){{_SLIT("[veb] error parsing path \""), 0xfe10, {.d_s = req.url}}, {_SLIT("\": "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return (_option_veb__Context_ptr){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	net__urllib__URL url = (*(net__urllib__URL*)_t1.data);
	Map_string_string query = veb__parse_query_from_url(url);
	_result_multi_return_Map_string_string_Map_string_Array_net__http__FileData _t3 = veb__parse_form_from_request(req);
	if (_t3.is_error) {
		IError err = _t3.err;
		eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] error parsing form: "), 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		_result_int _t4 = net__TcpConn_write(conn, net__http__Response_bytes(_const_veb__http_400));
		(void)_t4;
 ;
		return (_option_veb__Context_ptr){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	multi_return_Map_string_string_Map_string_Array_net__http__FileData mr_17562 = (*(multi_return_Map_string_string_Map_string_Array_net__http__FileData*)_t3.data);
	Map_string_string form = mr_17562.arg0;
	Map_string_Array_net__http__FileData files = mr_17562.arg1;
	_result_string _t6 = net__http__Header_get(req.header, net__http__CommonHeader__host);
	if (_t6.is_error) {
		IError err = _t6.err;
		*(string*) _t6.data = _SLIT("");
	}
	
 	string host_with_port = (*(string*)_t6.data);
	multi_return_string_string mr_17830 = net__urllib__split_host_port(host_with_port);
	string host = mr_17830.arg0;
	veb__Context* ctx = ((veb__Context*)memdup(&(veb__Context){.content_type = (string){.str=(byteptr)"", .is_lit=1},
		.done = 0,
		.takeover = 0,
		.return_type = veb__ContextReturnType__normal,
		.return_file = (string){.str=(byteptr)"", .is_lit=1},
		.client_wants_to_close = 0,
		.page_gen_start = page_gen_start,
		.req = req,
		.custom_mime_types = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.conn = conn,
		.query = query,
		.form = form,
		.files = files,
		.res = ((net__http__Response){.body = (string){.str=(byteptr)"", .is_lit=1},.header = ((net__http__Header){.data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.cur_pos = 0,}),.status_code = 0,.status_msg = (string){.str=(byteptr)"", .is_lit=1},.http_version = (string){.str=(byteptr)"", .is_lit=1},}),
		.form_error = (string){.str=(byteptr)"", .is_lit=1},
		.livereload_poll_interval_ms = 250,
	}, sizeof(veb__Context)));
	_result_string _t7;
	if (_t7 = net__http__Header_get(req.header, net__http__CommonHeader__connection), !_t7.is_error) {
		string connection_header = *(string*)_t7.data;
		if (string__eq(string_to_lower(connection_header), _SLIT("close"))) {
			ctx->client_wants_to_close = true;
		}
	}
	#if 1 && false == false
	{
		ctx->custom_mime_types = map_clone(&global_app->StaticHandler.static_mime_types);
	}
	#endif
	#if 0
	{
	}
	#endif
	main__Context *user_context = HEAP(main__Context, (((main__Context){.Context = ((veb__Context){.content_type = (string){.str=(byteptr)"", .is_lit=1},.done = 0,.takeover = 0,.return_type = veb__ContextReturnType__normal,.return_file = (string){.str=(byteptr)"", .is_lit=1},.client_wants_to_close = 0,.page_gen_start = 0,.req = ((net__http__Request){.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.version = net__http__Version__v1_1,.method = net__http__Method__get,.header = ((net__http__Header){.data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.cur_pos = 0,}),.host = (string){.str=(byteptr)"", .is_lit=1},.data = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.user_agent = _SLIT("v.http"),.verbose = 0,.user_ptr = 0,.proxy = ((void*)0),.read_timeout = 30 * _const_time__second,.write_timeout = 30 * _const_time__second,.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_progress_body = ((void*)0),.on_finish = ((void*)0),.stop_copying_limit = -1,.stop_receiving_limit = -1,}),.custom_mime_types = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.conn = ((void*)0),.query = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.form = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.files = new_map(sizeof(string), sizeof(Array_net__http__FileData), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.res = ((net__http__Response){.body = (string){.str=(byteptr)"", .is_lit=1},.header = ((net__http__Header){.data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.cur_pos = 0,}),.status_code = 0,.status_msg = (string){.str=(byteptr)"", .is_lit=1},.http_version = (string){.str=(byteptr)"", .is_lit=1},}),.form_error = (string){.str=(byteptr)"", .is_lit=1},.livereload_poll_interval_ms = 250,}),})));
	(*(user_context)).Context = *ctx;
	veb__handle_route_T_main__App_main__Context(global_app, (voidptr)&(*(user_context)), url, host, params->routes);
	_option_veb__Context_ptr _t10;
	_option_ok(&(veb__Context*[]) { &(*(user_context)).Context }, (_option*)(&_t10), sizeof(veb__Context*));
	return _t10;
}
VV_LOCAL_SYMBOL void veb__handle_route_T_main__App_main__Context(main__App* app, main__Context* user_context, net__urllib__URL url, string host, Map_string_veb__Route* routes) {
	bool veb__handle_route_T_main__App_main__Context_defer_0 = false;
	bool not_found;
	bool middleware_has_sent_response;
	bool was_done;
	veb__Route route;
	route = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
	middleware_has_sent_response = false;
	not_found = false;
	veb__handle_route_T_main__App_main__Context_defer_0 = true;
	Array_string _t1 = {0};
	Array_string _t1_orig = string_split(url.path, _SLIT("/"));
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(string));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		string it = ((string*) _t1_orig.data)[_t2];
		if ((it).len != 0) {
			array_push((array*)&_t1, &it);
		}
	}
	Array_string url_words =_t1;
	#if 0
	{
	}
	#endif
	if (user_context->Context.done) {
		// Defer begin
		if (veb__handle_route_T_main__App_main__Context_defer_0) {
			was_done = true;
			#if 1 && false == false
			{
				if (!not_found && !middleware_has_sent_response) {
					was_done = user_context->Context.done;
					user_context->Context.done = false;
					veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
					veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
				}
			}
			#endif
			if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
				eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
			} else if (!user_context->Context.takeover) {
			}
		}
		// Defer end
		return;
	}
	#if 1 && false == false
	{
		if (veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_T_main__Context(&app->Middleware)) == false) {
			middleware_has_sent_response = true;
			// Defer begin
			if (veb__handle_route_T_main__App_main__Context_defer_0) {
				was_done = true;
				#if 1 && false == false
				{
					if (!not_found && !middleware_has_sent_response) {
						was_done = user_context->Context.done;
						user_context->Context.done = false;
						veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
						veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
					}
				}
				#endif
				if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
				} else if (!user_context->Context.takeover) {
				}
			}
			// Defer end
			return;
		}
	}
	#endif
	#if 1 && false == false
	{
		if (veb__serve_if_static_T_main__App_main__Context(app, user_context, url, host)) {
			// Defer begin
			if (veb__handle_route_T_main__App_main__Context_defer_0) {
				was_done = true;
				#if 1 && false == false
				{
					if (!not_found && !middleware_has_sent_response) {
						was_done = user_context->Context.done;
						user_context->Context.done = false;
						veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
						veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
					}
				}
				#endif
				if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
				} else if (!user_context->Context.takeover) {
				}
			}
			// Defer end
			return;
		}
	}
	#endif
	/* $for method in main.App.methods */ {
		FunctionData method = {0};
		/* method 0 */ {
			method.name = _SLIT("index");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t11 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t10 = {0};
				if (_t11) {
					*((veb__Route*)&_t10.data) = *((veb__Route*)_t11);
				} else {
					_t10.state = 2; _t10.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t10.state != 0) {
					IError err = _t10.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t10.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t10.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t12 = {0};
					Array_string _t12_orig = string_split(route.path, _SLIT("/"));
					int _t12_len = _t12_orig.len;
					_t12 = __new_array(0, _t12_len, sizeof(string));

					for (int _t13 = 0; _t13 < _t12_len; ++_t13) {
						string it = ((string*) _t12_orig.data)[_t13];
						if ((it).len != 0) {
							array_push((array*)&_t12, &it);
						}
					}
					Array_string route_words =_t12;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t16 = array_slice(method.args, 1, 2147483647);
								for (int _t17 = 0; _t17 < _t16.len; ++_t17) {
									MethodParam param = ((MethodParam*)_t16.data)[_t17];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.index due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_index(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t22 = array_slice(method.args, 1, 2147483647);
								for (int _t23 = 0; _t23 < _t22.len; ++_t23) {
									MethodParam param = ((MethodParam*)_t22.data)[_t23];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.index due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_index(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t26;
						if (_t26 = veb__route_matches(url_words, route_words), _t26.state == 0) {
							Array_string params = *(Array_string*)_t26.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.index due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 1 */ {
			method.name = _SLIT("find_index");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/index.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t32 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t31 = {0};
				if (_t32) {
					*((veb__Route*)&_t31.data) = *((veb__Route*)_t32);
				} else {
					_t31.state = 2; _t31.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t31.state != 0) {
					IError err = _t31.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t31.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t31.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t33 = {0};
					Array_string _t33_orig = string_split(route.path, _SLIT("/"));
					int _t33_len = _t33_orig.len;
					_t33 = __new_array(0, _t33_len, sizeof(string));

					for (int _t34 = 0; _t34 < _t33_len; ++_t34) {
						string it = ((string*) _t33_orig.data)[_t34];
						if ((it).len != 0) {
							array_push((array*)&_t33, &it);
						}
					}
					Array_string route_words =_t33;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t37 = array_slice(method.args, 1, 2147483647);
								for (int _t38 = 0; _t38 < _t37.len; ++_t38) {
									MethodParam param = ((MethodParam*)_t37.data)[_t38];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.find_index due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_find_index(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t43 = array_slice(method.args, 1, 2147483647);
								for (int _t44 = 0; _t44 < _t43.len; ++_t44) {
									MethodParam param = ((MethodParam*)_t43.data)[_t44];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.find_index due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_find_index(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t47;
						if (_t47 = veb__route_matches(url_words, route_words), _t47.state == 0) {
							Array_string params = *(Array_string*)_t47.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.find_index due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 2 */ {
			method.name = _SLIT("error");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/error.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t53 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t52 = {0};
				if (_t53) {
					*((veb__Route*)&_t52.data) = *((veb__Route*)_t53);
				} else {
					_t52.state = 2; _t52.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t52.state != 0) {
					IError err = _t52.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t52.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t52.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t54 = {0};
					Array_string _t54_orig = string_split(route.path, _SLIT("/"));
					int _t54_len = _t54_orig.len;
					_t54 = __new_array(0, _t54_len, sizeof(string));

					for (int _t55 = 0; _t55 < _t54_len; ++_t55) {
						string it = ((string*) _t54_orig.data)[_t55];
						if ((it).len != 0) {
							array_push((array*)&_t54, &it);
						}
					}
					Array_string route_words =_t54;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t58 = array_slice(method.args, 1, 2147483647);
								for (int _t59 = 0; _t59 < _t58.len; ++_t59) {
									MethodParam param = ((MethodParam*)_t58.data)[_t59];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.error due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_error(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t64 = array_slice(method.args, 1, 2147483647);
								for (int _t65 = 0; _t65 < _t64.len; ++_t65) {
									MethodParam param = ((MethodParam*)_t64.data)[_t65];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.error due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_error(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t68;
						if (_t68 = veb__route_matches(url_words, route_words), _t68.state == 0) {
							Array_string params = *(Array_string*)_t68.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.error due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 3 */ {
			method.name = _SLIT("login");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/login.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t74 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t73 = {0};
				if (_t74) {
					*((veb__Route*)&_t73.data) = *((veb__Route*)_t74);
				} else {
					_t73.state = 2; _t73.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t73.state != 0) {
					IError err = _t73.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t73.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t73.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t75 = {0};
					Array_string _t75_orig = string_split(route.path, _SLIT("/"));
					int _t75_len = _t75_orig.len;
					_t75 = __new_array(0, _t75_len, sizeof(string));

					for (int _t76 = 0; _t76 < _t75_len; ++_t76) {
						string it = ((string*) _t75_orig.data)[_t76];
						if ((it).len != 0) {
							array_push((array*)&_t75, &it);
						}
					}
					Array_string route_words =_t75;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t79 = array_slice(method.args, 1, 2147483647);
								for (int _t80 = 0; _t80 < _t79.len; ++_t80) {
									MethodParam param = ((MethodParam*)_t79.data)[_t80];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.login due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_login(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t85 = array_slice(method.args, 1, 2147483647);
								for (int _t86 = 0; _t86 < _t85.len; ++_t86) {
									MethodParam param = ((MethodParam*)_t85.data)[_t86];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.login due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_login(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t89;
						if (_t89 = veb__route_matches(url_words, route_words), _t89.state == 0) {
							Array_string params = *(Array_string*)_t89.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.login due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 4 */ {
			method.name = _SLIT("loginapi");
			method.attrs = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/loginapi"), _SLIT("post")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t95 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t94 = {0};
				if (_t95) {
					*((veb__Route*)&_t94.data) = *((veb__Route*)_t95);
				} else {
					_t94.state = 2; _t94.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t94.state != 0) {
					IError err = _t94.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t94.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t94.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t96 = {0};
					Array_string _t96_orig = string_split(route.path, _SLIT("/"));
					int _t96_len = _t96_orig.len;
					_t96 = __new_array(0, _t96_len, sizeof(string));

					for (int _t97 = 0; _t97 < _t96_len; ++_t97) {
						string it = ((string*) _t96_orig.data)[_t97];
						if ((it).len != 0) {
							array_push((array*)&_t96, &it);
						}
					}
					Array_string route_words =_t96;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t100 = array_slice(method.args, 1, 2147483647);
								for (int _t101 = 0; _t101 < _t100.len; ++_t101) {
									MethodParam param = ((MethodParam*)_t100.data)[_t101];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.loginapi due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_loginapi(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t106 = array_slice(method.args, 1, 2147483647);
								for (int _t107 = 0; _t107 < _t106.len; ++_t107) {
									MethodParam param = ((MethodParam*)_t106.data)[_t107];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.loginapi due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_loginapi(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t110;
						if (_t110 = veb__route_matches(url_words, route_words), _t110.state == 0) {
							Array_string params = *(Array_string*)_t110.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.loginapi due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 5 */ {
			method.name = _SLIT("signup");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/signup.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t116 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t115 = {0};
				if (_t116) {
					*((veb__Route*)&_t115.data) = *((veb__Route*)_t116);
				} else {
					_t115.state = 2; _t115.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t115.state != 0) {
					IError err = _t115.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t115.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t115.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t117 = {0};
					Array_string _t117_orig = string_split(route.path, _SLIT("/"));
					int _t117_len = _t117_orig.len;
					_t117 = __new_array(0, _t117_len, sizeof(string));

					for (int _t118 = 0; _t118 < _t117_len; ++_t118) {
						string it = ((string*) _t117_orig.data)[_t118];
						if ((it).len != 0) {
							array_push((array*)&_t117, &it);
						}
					}
					Array_string route_words =_t117;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t121 = array_slice(method.args, 1, 2147483647);
								for (int _t122 = 0; _t122 < _t121.len; ++_t122) {
									MethodParam param = ((MethodParam*)_t121.data)[_t122];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.signup due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_signup(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t127 = array_slice(method.args, 1, 2147483647);
								for (int _t128 = 0; _t128 < _t127.len; ++_t128) {
									MethodParam param = ((MethodParam*)_t127.data)[_t128];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.signup due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_signup(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t131;
						if (_t131 = veb__route_matches(url_words, route_words), _t131.state == 0) {
							Array_string params = *(Array_string*)_t131.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.signup due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 6 */ {
			method.name = _SLIT("signupapi");
			method.attrs = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/signupapi"), _SLIT("post")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t137 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t136 = {0};
				if (_t137) {
					*((veb__Route*)&_t136.data) = *((veb__Route*)_t137);
				} else {
					_t136.state = 2; _t136.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t136.state != 0) {
					IError err = _t136.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t136.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t136.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t138 = {0};
					Array_string _t138_orig = string_split(route.path, _SLIT("/"));
					int _t138_len = _t138_orig.len;
					_t138 = __new_array(0, _t138_len, sizeof(string));

					for (int _t139 = 0; _t139 < _t138_len; ++_t139) {
						string it = ((string*) _t138_orig.data)[_t139];
						if ((it).len != 0) {
							array_push((array*)&_t138, &it);
						}
					}
					Array_string route_words =_t138;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t142 = array_slice(method.args, 1, 2147483647);
								for (int _t143 = 0; _t143 < _t142.len; ++_t143) {
									MethodParam param = ((MethodParam*)_t142.data)[_t143];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.signupapi due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_signupapi(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t148 = array_slice(method.args, 1, 2147483647);
								for (int _t149 = 0; _t149 < _t148.len; ++_t149) {
									MethodParam param = ((MethodParam*)_t148.data)[_t149];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.signupapi due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_signupapi(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t152;
						if (_t152 = veb__route_matches(url_words, route_words), _t152.state == 0) {
							Array_string params = *(Array_string*)_t152.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.signupapi due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 7 */ {
			method.name = _SLIT("member");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/member.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t158 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t157 = {0};
				if (_t158) {
					*((veb__Route*)&_t157.data) = *((veb__Route*)_t158);
				} else {
					_t157.state = 2; _t157.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t157.state != 0) {
					IError err = _t157.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t157.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t157.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t159 = {0};
					Array_string _t159_orig = string_split(route.path, _SLIT("/"));
					int _t159_len = _t159_orig.len;
					_t159 = __new_array(0, _t159_len, sizeof(string));

					for (int _t160 = 0; _t160 < _t159_len; ++_t160) {
						string it = ((string*) _t159_orig.data)[_t160];
						if ((it).len != 0) {
							array_push((array*)&_t159, &it);
						}
					}
					Array_string route_words =_t159;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t163 = array_slice(method.args, 1, 2147483647);
								for (int _t164 = 0; _t164 < _t163.len; ++_t164) {
									MethodParam param = ((MethodParam*)_t163.data)[_t164];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.member due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_member(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t169 = array_slice(method.args, 1, 2147483647);
								for (int _t170 = 0; _t170 < _t169.len; ++_t170) {
									MethodParam param = ((MethodParam*)_t169.data)[_t170];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.member due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_member(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t173;
						if (_t173 = veb__route_matches(url_words, route_words), _t173.state == 0) {
							Array_string params = *(Array_string*)_t173.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.member due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 8 */ {
			method.name = _SLIT("memberapi");
			method.attrs = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/memberapi"), _SLIT("post")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t179 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t178 = {0};
				if (_t179) {
					*((veb__Route*)&_t178.data) = *((veb__Route*)_t179);
				} else {
					_t178.state = 2; _t178.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t178.state != 0) {
					IError err = _t178.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t178.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t178.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t180 = {0};
					Array_string _t180_orig = string_split(route.path, _SLIT("/"));
					int _t180_len = _t180_orig.len;
					_t180 = __new_array(0, _t180_len, sizeof(string));

					for (int _t181 = 0; _t181 < _t180_len; ++_t181) {
						string it = ((string*) _t180_orig.data)[_t181];
						if ((it).len != 0) {
							array_push((array*)&_t180, &it);
						}
					}
					Array_string route_words =_t180;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t184 = array_slice(method.args, 1, 2147483647);
								for (int _t185 = 0; _t185 < _t184.len; ++_t185) {
									MethodParam param = ((MethodParam*)_t184.data)[_t185];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.memberapi due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_memberapi(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t190 = array_slice(method.args, 1, 2147483647);
								for (int _t191 = 0; _t191 < _t190.len; ++_t191) {
									MethodParam param = ((MethodParam*)_t190.data)[_t191];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.memberapi due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_memberapi(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t194;
						if (_t194 = veb__route_matches(url_words, route_words), _t194.state == 0) {
							Array_string params = *(Array_string*)_t194.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.memberapi due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 9 */ {
			method.name = _SLIT("challenge");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/challenge.html")}));

			method.args = new_array_from_c_array(2, 2, sizeof(MethodParam), _MOV((MethodParam[2]){{107, _SLIT("ctx")}, {21, _SLIT("display_challenge")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t200 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t199 = {0};
				if (_t200) {
					*((veb__Route*)&_t199.data) = *((veb__Route*)_t200);
				} else {
					_t199.state = 2; _t199.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t199.state != 0) {
					IError err = _t199.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t199.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t199.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t201 = {0};
					Array_string _t201_orig = string_split(route.path, _SLIT("/"));
					int _t201_len = _t201_orig.len;
					_t201 = __new_array(0, _t201_len, sizeof(string));

					for (int _t202 = 0; _t202 < _t201_len; ++_t202) {
						string it = ((string*) _t201_orig.data)[_t202];
						if ((it).len != 0) {
							array_push((array*)&_t201, &it);
						}
					}
					Array_string route_words =_t201;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t205 = array_slice(method.args, 1, 2147483647);
								for (int _t206 = 0; _t206 < _t205.len; ++_t206) {
									MethodParam param = ((MethodParam*)_t205.data)[_t206];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								main__App_challenge(app, user_context, ((string*)args.data) [0] );
							} else {
								/* skipping main.App.challenge due to mismatched arguments list: node.args=1 m.params=3 */
								;
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t211 = array_slice(method.args, 1, 2147483647);
								for (int _t212 = 0; _t212 < _t211.len; ++_t212) {
									MethodParam param = ((MethodParam*)_t211.data)[_t212];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								main__App_challenge(app, user_context, ((string*)args.data) [0] );
							} else {
								/* skipping main.App.challenge due to mismatched arguments list: node.args=1 m.params=3 */
								;
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t215;
						if (_t215 = veb__route_matches(url_words, route_words), _t215.state == 0) {
							Array_string params = *(Array_string*)_t215.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							main__App_challenge(app, user_context, ((string*)method_args.data) [0] );
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 10 */ {
			method.name = _SLIT("flagapi");
			method.attrs = new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/flagapi"), _SLIT("post")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t221 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t220 = {0};
				if (_t221) {
					*((veb__Route*)&_t220.data) = *((veb__Route*)_t221);
				} else {
					_t220.state = 2; _t220.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t220.state != 0) {
					IError err = _t220.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t220.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t220.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t222 = {0};
					Array_string _t222_orig = string_split(route.path, _SLIT("/"));
					int _t222_len = _t222_orig.len;
					_t222 = __new_array(0, _t222_len, sizeof(string));

					for (int _t223 = 0; _t223 < _t222_len; ++_t223) {
						string it = ((string*) _t222_orig.data)[_t223];
						if ((it).len != 0) {
							array_push((array*)&_t222, &it);
						}
					}
					Array_string route_words =_t222;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t226 = array_slice(method.args, 1, 2147483647);
								for (int _t227 = 0; _t227 < _t226.len; ++_t227) {
									MethodParam param = ((MethodParam*)_t226.data)[_t227];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.flagapi due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_flagapi(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t232 = array_slice(method.args, 1, 2147483647);
								for (int _t233 = 0; _t233 < _t232.len; ++_t233) {
									MethodParam param = ((MethodParam*)_t232.data)[_t233];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.flagapi due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_flagapi(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t236;
						if (_t236 = veb__route_matches(url_words, route_words), _t236.state == 0) {
							Array_string params = *(Array_string*)_t236.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.flagapi due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 11 */ {
			method.name = _SLIT("team");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/team.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t242 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t241 = {0};
				if (_t242) {
					*((veb__Route*)&_t241.data) = *((veb__Route*)_t242);
				} else {
					_t241.state = 2; _t241.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t241.state != 0) {
					IError err = _t241.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t241.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t241.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t243 = {0};
					Array_string _t243_orig = string_split(route.path, _SLIT("/"));
					int _t243_len = _t243_orig.len;
					_t243 = __new_array(0, _t243_len, sizeof(string));

					for (int _t244 = 0; _t244 < _t243_len; ++_t244) {
						string it = ((string*) _t243_orig.data)[_t244];
						if ((it).len != 0) {
							array_push((array*)&_t243, &it);
						}
					}
					Array_string route_words =_t243;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t247 = array_slice(method.args, 1, 2147483647);
								for (int _t248 = 0; _t248 < _t247.len; ++_t248) {
									MethodParam param = ((MethodParam*)_t247.data)[_t248];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.team due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_team(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t253 = array_slice(method.args, 1, 2147483647);
								for (int _t254 = 0; _t254 < _t253.len; ++_t254) {
									MethodParam param = ((MethodParam*)_t253.data)[_t254];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.team due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_team(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t257;
						if (_t257 = veb__route_matches(url_words, route_words), _t257.state == 0) {
							Array_string params = *(Array_string*)_t257.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.team due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 12 */ {
			method.name = _SLIT("ranking");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/ranking.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t263 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t262 = {0};
				if (_t263) {
					*((veb__Route*)&_t262.data) = *((veb__Route*)_t263);
				} else {
					_t262.state = 2; _t262.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t262.state != 0) {
					IError err = _t262.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t262.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t262.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t264 = {0};
					Array_string _t264_orig = string_split(route.path, _SLIT("/"));
					int _t264_len = _t264_orig.len;
					_t264 = __new_array(0, _t264_len, sizeof(string));

					for (int _t265 = 0; _t265 < _t264_len; ++_t265) {
						string it = ((string*) _t264_orig.data)[_t265];
						if ((it).len != 0) {
							array_push((array*)&_t264, &it);
						}
					}
					Array_string route_words =_t264;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t268 = array_slice(method.args, 1, 2147483647);
								for (int _t269 = 0; _t269 < _t268.len; ++_t269) {
									MethodParam param = ((MethodParam*)_t268.data)[_t269];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.ranking due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_ranking(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t274 = array_slice(method.args, 1, 2147483647);
								for (int _t275 = 0; _t275 < _t274.len; ++_t275) {
									MethodParam param = ((MethodParam*)_t274.data)[_t275];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.ranking due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_ranking(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t278;
						if (_t278 = veb__route_matches(url_words, route_words), _t278.state == 0) {
							Array_string params = *(Array_string*)_t278.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.ranking due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 13 */ {
			method.name = _SLIT("rankapi");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/rankapi")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t284 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t283 = {0};
				if (_t284) {
					*((veb__Route*)&_t283.data) = *((veb__Route*)_t284);
				} else {
					_t283.state = 2; _t283.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t283.state != 0) {
					IError err = _t283.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t283.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t283.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t285 = {0};
					Array_string _t285_orig = string_split(route.path, _SLIT("/"));
					int _t285_len = _t285_orig.len;
					_t285 = __new_array(0, _t285_len, sizeof(string));

					for (int _t286 = 0; _t286 < _t285_len; ++_t286) {
						string it = ((string*) _t285_orig.data)[_t286];
						if ((it).len != 0) {
							array_push((array*)&_t285, &it);
						}
					}
					Array_string route_words =_t285;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t289 = array_slice(method.args, 1, 2147483647);
								for (int _t290 = 0; _t290 < _t289.len; ++_t290) {
									MethodParam param = ((MethodParam*)_t289.data)[_t290];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.rankapi due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_rankapi(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t295 = array_slice(method.args, 1, 2147483647);
								for (int _t296 = 0; _t296 < _t295.len; ++_t296) {
									MethodParam param = ((MethodParam*)_t295.data)[_t296];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.rankapi due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_rankapi(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t299;
						if (_t299 = veb__route_matches(url_words, route_words), _t299.state == 0) {
							Array_string params = *(Array_string*)_t299.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.rankapi due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 14 */ {
			method.name = _SLIT("notice");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/notice.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t305 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t304 = {0};
				if (_t305) {
					*((veb__Route*)&_t304.data) = *((veb__Route*)_t305);
				} else {
					_t304.state = 2; _t304.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t304.state != 0) {
					IError err = _t304.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t304.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t304.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t306 = {0};
					Array_string _t306_orig = string_split(route.path, _SLIT("/"));
					int _t306_len = _t306_orig.len;
					_t306 = __new_array(0, _t306_len, sizeof(string));

					for (int _t307 = 0; _t307 < _t306_len; ++_t307) {
						string it = ((string*) _t306_orig.data)[_t307];
						if ((it).len != 0) {
							array_push((array*)&_t306, &it);
						}
					}
					Array_string route_words =_t306;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t310 = array_slice(method.args, 1, 2147483647);
								for (int _t311 = 0; _t311 < _t310.len; ++_t311) {
									MethodParam param = ((MethodParam*)_t310.data)[_t311];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.notice due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_notice(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t316 = array_slice(method.args, 1, 2147483647);
								for (int _t317 = 0; _t317 < _t316.len; ++_t317) {
									MethodParam param = ((MethodParam*)_t316.data)[_t317];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.notice due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_notice(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t320;
						if (_t320 = veb__route_matches(url_words, route_words), _t320.state == 0) {
							Array_string params = *(Array_string*)_t320.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.notice due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
		/* method 15 */ {
			method.name = _SLIT("console");
			method.attrs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("/console.html")}));

			method.args = new_array_from_c_array(1, 1, sizeof(MethodParam), _MOV((MethodParam[1]){{107, _SLIT("ctx")}}));

			method.typ = 0;
			method.return_type = 115;
			#if 115 == 115 && false == false
			{
				veb__Route* _t326 = (veb__Route*)(map_get_check(ADDR(map, (*routes)), &(string[]){method.name}));
				_option_veb__Route _t325 = {0};
				if (_t326) {
					*((veb__Route*)&_t325.data) = *((veb__Route*)_t326);
				} else {
					_t325.state = 2; _t325.err = _v_error(_SLIT("map key does not exist"));
				}
				;
				if (_t325.state != 0) {
					IError err = _t325.err;
					eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] parsed attributes for the `"), 0xfe10, {.d_s = method.name}}, {_SLIT("` are not found, skipping..."), 0, { .d_c = 0 }}})));
					*(veb__Route*) _t325.data = ((veb__Route){.methods = __new_array_noscan(0, 0, sizeof(net__http__Method)),.path = (string){.str=(byteptr)"", .is_lit=1},.host = (string){.str=(byteptr)"", .is_lit=1},.middlewares = __new_array(0, 0, sizeof(voidptr)),.after_middlewares = __new_array(0, 0, sizeof(voidptr)),});
				}
				
				route = (*(veb__Route*)_t325.data);
				if ((Array_net__http__Method_contains(route.methods, user_context->Context.req.method))) {
					Array_string _t327 = {0};
					Array_string _t327_orig = string_split(route.path, _SLIT("/"));
					int _t327_len = _t327_orig.len;
					_t327 = __new_array(0, _t327_len, sizeof(string));

					for (int _t328 = 0; _t328 < _t327_len; ++_t328) {
						string it = ((string*) _t327_orig.data)[_t328];
						if ((it).len != 0) {
							array_push((array*)&_t327, &it);
						}
					}
					Array_string route_words =_t327;
					if ((route.host).len == 0 || string__eq(route.host, host)) {
						bool can_have_data_args = user_context->Context.req.method == net__http__Method__post || user_context->Context.req.method == net__http__Method__get;
						if (!string_contains(route.path, _SLIT("/:")) && Array_string_arr_eq(url_words, route_words)) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t331 = array_slice(method.args, 1, 2147483647);
								for (int _t332 = 0; _t332 < _t331.len; ++_t332) {
									MethodParam param = ((MethodParam*)_t331.data)[_t332];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.console due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_console(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						if (url_words.len == 0 && Array_string_arr_eq(route_words, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("index")}))) && fast_string_eq(method.name, _SLIT("index"))) {
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							if (method.args.len > 1 && can_have_data_args) {
								Array_string args = __new_array_with_default(0, (int)(method.args.len + 1), sizeof(string), 0);
								Map_string_string data = (user_context->Context.req.method == net__http__Method__get ? (user_context->Context.query) : (user_context->Context.form));
								Array_MethodParam _t337 = array_slice(method.args, 1, 2147483647);
								for (int _t338 = 0; _t338 < _t337.len; ++_t338) {
									MethodParam param = ((MethodParam*)_t337.data)[_t338];
									array_push((array*)&args, _MOV((string[]){ (*(string*)map_get((map*)&data, &(string[]){param.name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })) }));
								}
								/* skipping main.App.console due to mismatched arguments list: node.args=2 m.params=2 */
								;
							} else {
								main__App_console(app, user_context);
							}
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
						_option_Array_string _t341;
						if (_t341 = veb__route_matches(url_words, route_words), _t341.state == 0) {
							Array_string params = *(Array_string*)_t341.data;
							#if 1 && false == false
							{
								if (veb__validate_middleware_T_main__Context(user_context, route.middlewares) == false) {
									middleware_has_sent_response = true;
									// Defer begin
									if (veb__handle_route_T_main__App_main__Context_defer_0) {
										was_done = true;
										#if 1 && false == false
										{
											if (!not_found && !middleware_has_sent_response) {
												was_done = user_context->Context.done;
												user_context->Context.done = false;
												veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
												veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
											}
										}
										#endif
										if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
											eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
										} else if (!user_context->Context.takeover) {
										}
									}
									// Defer end
									return;
								}
							}
							#endif
							Array_string method_args = array_clone_to_depth(&params, 0);
							if ((int)(method_args.len + 1) != method.args.len) {
								eprintln(str_intp(5, _MOV((StrIntpData[]){{_SLIT("[veb] warning: uneven parameters count ("), 0xfe07, {.d_i32 = method.args.len}}, {_SLIT(") in `"), 0xfe10, {.d_s = method.name}}, {_SLIT("`, compared to the veb route `"), 0xfe10, {.d_s = Array_string_str(method.attrs)}}, {_SLIT("` ("), 0xfe07, {.d_i32 = method_args.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
							}
							/* skipping main.App.console due to mismatched arguments list: node.args=2 m.params=2 */
							;
							// Defer begin
							if (veb__handle_route_T_main__App_main__Context_defer_0) {
								was_done = true;
								#if 1 && false == false
								{
									if (!not_found && !middleware_has_sent_response) {
										was_done = user_context->Context.done;
										user_context->Context.done = false;
										veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
										veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
									}
								}
								#endif
								if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
									eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
								} else if (!user_context->Context.takeover) {
								}
							}
							// Defer end
							return;
						}
					}
				}
			}
			#endif
		}
	}// $for
	main__Context_not_found(user_context);
	not_found = true;
	// Defer begin
	if (veb__handle_route_T_main__App_main__Context_defer_0) {
		was_done = true;
		#if 1 && false == false
		{
			if (!not_found && !middleware_has_sent_response) {
				was_done = user_context->Context.done;
				user_context->Context.done = false;
				veb__validate_middleware_T_main__Context(user_context, veb__Middleware_T_main__Context_get_global_handlers_after_T_main__Context(&app->Middleware));
				veb__validate_middleware_T_main__Context(user_context, route.after_middlewares);
			}
		}
		#endif
		if (!was_done && !user_context->Context.done && !user_context->Context.takeover) {
			eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] handler for route \""), 0xfe10, {.d_s = url.path}}, {_SLIT("\" does not send any data!"), 0, { .d_c = 0 }}})));
		} else if (!user_context->Context.takeover) {
		}
	}
	// Defer end
	return;
}
VV_LOCAL_SYMBOL _option_Array_string veb__route_matches(Array_string url_words, Array_string route_words) {
	if (route_words.len == 1 && string_starts_with((*(string*)array_get(route_words, 0)), _SLIT(":")) && string_ends_with((*(string*)array_get(route_words, 0)), _SLIT("..."))) {
		_option_Array_string _t1;
		_option_ok(&(Array_string[]) { new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string__plus(_SLIT("/"), Array_string_join(url_words, _SLIT("/")))})) }, (_option*)(&_t1), sizeof(Array_string));
		return _t1;
	}
	if (url_words.len < route_words.len) {
		return (_option_Array_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_string params = __new_array_with_default(0, url_words.len, sizeof(string), 0);
	if (url_words.len == route_words.len) {
		for (int i = 0; i < url_words.len; ++i) {
			if (string_starts_with((*(string*)array_get(route_words, i)), _SLIT(":"))) {
				array_push((array*)&params, _MOV((string[]){ (*(string*)array_get(url_words, i)) }));
			} else if (!string__eq((*(string*)array_get(route_words, i)), (*(string*)array_get(url_words, i)))) {
				return (_option_Array_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		_option_Array_string _t5;
		_option_ok(&(Array_string[]) { params }, (_option*)(&_t5), sizeof(Array_string));
		return _t5;
	}
	if (route_words.len == 0 || !string_ends_with((*(string*)array_get(route_words, (int)(route_words.len - 1))), _SLIT("..."))) {
		return (_option_Array_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	for (int i = 0; i < (int)(route_words.len - 1); ++i) {
		if (string_starts_with((*(string*)array_get(route_words, i)), _SLIT(":"))) {
			array_push((array*)&params, _MOV((string[]){ (*(string*)array_get(url_words, i)) }));
		} else if (!string__eq((*(string*)array_get(route_words, i)), (*(string*)array_get(url_words, i)))) {
			return (_option_Array_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	array_push((array*)&params, _MOV((string[]){ Array_string_join(array_slice(url_words, (int)(route_words.len - 1), url_words.len), _SLIT("/")) }));
	_option_Array_string _t10;
	_option_ok(&(Array_string[]) { params }, (_option*)(&_t10), sizeof(Array_string));
	return _t10;
}
VV_LOCAL_SYMBOL bool veb__serve_if_static_T_main__App_main__Context(main__App* app, main__Context* user_context, net__urllib__URL url, string host) {
	string asked_path = url.path;
	string base_path = os__base(asked_path);
	if (!string_contains(base_path, _SLIT(".")) && !string_ends_with(asked_path, _SLIT("/"))) {
		asked_path = string__plus(asked_path, _SLIT("/"));
	}
	if (string_ends_with(asked_path, _SLIT("/"))) {
		if (((*(string*)map_get(ADDR(map, app->StaticHandler.static_files), &(string[]){string__plus(asked_path, _SLIT("index.html"))}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }))).len != 0) {
			asked_path = string__plus(asked_path, _SLIT("index.html"));
		} else if (((*(string*)map_get(ADDR(map, app->StaticHandler.static_files), &(string[]){string__plus(asked_path, _SLIT("index.htm"))}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }))).len != 0) {
			asked_path = string__plus(asked_path, _SLIT("index.htm"));
		}
	}
	string* _t2 = (string*)(map_get_check(ADDR(map, app->StaticHandler.static_files), &(string[]){asked_path}));
	_option_string _t1 = {0};
	if (_t2) {
		*((string*)&_t1.data) = *((string*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("map key does not exist"));
	}
	;
	if (_t1.state != 0) {
		IError err = _t1.err;
		return false;
	}
	
	string static_file = (*(string*)_t1.data);
	string ext = string_to_lower(os__file_ext(static_file));
	string* _t5 = (string*)(map_get_check(ADDR(map, app->StaticHandler.static_mime_types), &(string[]){ext}));
	_option_string _t4 = {0};
	if (_t5) {
		*((string*)&_t4.data) = *((string*)_t5);
	} else {
		_t4.state = 2; _t4.err = _v_error(_SLIT("map key does not exist"));
	}
	;
	if (_t4.state != 0) {
		IError err = _t4.err;
		*(string*) _t4.data = (*(string*)map_get(ADDR(map, _const_veb__mime_types), &(string[]){ext}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
	}
	
	string mime_type = (*(string*)_t4.data);
	string* _t7 = (string*)(map_get_check(ADDR(map, app->StaticHandler.static_hosts), &(string[]){asked_path}));
	_option_string _t6 = {0};
	if (_t7) {
		*((string*)&_t6.data) = *((string*)_t7);
	} else {
		_t6.state = 2; _t6.err = _v_error(_SLIT("map key does not exist"));
	}
	;
	if (_t6.state != 0) {
		IError err = _t6.err;
		*(string*) _t6.data = _SLIT("");
	}
	
	string static_host = (*(string*)_t6.data);
	if ((static_file).len == 0 || (mime_type).len == 0) {
		return false;
	}
	if ((static_host).len != 0 && !string__eq(static_host, host)) {
		return false;
	}
	veb__Context_send_file(&user_context->Context, mime_type, static_file);
	return true;
}
VV_LOCAL_SYMBOL _result_void veb__send_string(net__TcpConn* conn, string s) {
	if (((voidptr)(conn)) == ((void*)0)) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("connection was closed before send_string")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_int _t2 = net__TcpConn_write_string(conn, s);
	if (_t2.is_error) {
		_result_void _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 ;
	return (_result_void){0};
}
VV_LOCAL_SYMBOL _result_int veb__send_string_ptr(net__TcpConn* conn, u8* ptr, int len) {
	if (((voidptr)(conn)) == ((void*)0)) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("connection was closed before send_string")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return net__TcpConn_write_ptr(conn, ptr, len);
}
VV_LOCAL_SYMBOL _result_void veb__fast_send_resp_header(net__TcpConn* conn, net__http__Response resp) {
	strings__Builder sb = strings__new_builder((int)(resp.body.len + 200));
	strings__Builder_write_string(&sb, _SLIT("HTTP/"));
	strings__Builder_write_string(&sb, resp.http_version);
	strings__Builder_write_string(&sb, _SLIT(" "));
	strings__Builder_write_decimal(&sb, resp.status_code);
	strings__Builder_write_string(&sb, _SLIT(" "));
	strings__Builder_write_string(&sb, resp.status_msg);
	strings__Builder_write_string(&sb, _SLIT("\r\n"));
	net__http__Header_render_into_sb(resp.header, (voidptr)&sb, ((net__http__HeaderRenderConfig){.version = net__http__Response_version(resp),.coerce = 0,.canonicalize = 0,}));
	strings__Builder_write_string(&sb, _SLIT("\r\n"));
	_result_void _t1 = veb__send_string(conn, strings__Builder_str(&sb));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
VV_LOCAL_SYMBOL _result_void veb__fast_send_resp(net__TcpConn* conn, net__http__Response resp) {
	_result_void _t1 = veb__fast_send_resp_header(conn, resp);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	_result_void _t3 = veb__send_string(conn, resp.body);
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	return (_result_void){0};
}
void veb__Context_error(veb__Context* ctx, string s) {
	eprintln(str_intp(2, _MOV((StrIntpData[]){{_SLIT("[veb] Context.error: "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
	ctx->form_error = s;
}
VV_LOCAL_SYMBOL string main__cookie_id(main__Context _v_toheap_ctx) {
main__Context* ctx = HEAP(main__Context, _v_toheap_ctx);
	_option_string _t1 = veb__Context_get_cookie(&(*(ctx)).Context, _SLIT("id"));
	if (_t1.state != 0) {
		IError err = _t1.err;
		*(string*) _t1.data = _SLIT("");
	}
	
 	string c_id = (*(string*)_t1.data);
	return encoding__base64__url_decode_str(c_id);
}
VV_LOCAL_SYMBOL string main__cookie_passwd(main__Context _v_toheap_ctx) {
main__Context* ctx = HEAP(main__Context, _v_toheap_ctx);
	_option_string _t1 = veb__Context_get_cookie(&(*(ctx)).Context, _SLIT("passwd"));
	if (_t1.state != 0) {
		IError err = _t1.err;
		*(string*) _t1.data = _SLIT("");
	}
	
 	string c_pwd = (*(string*)_t1.data);
	return encoding__base64__url_decode_str(c_pwd);
}
VV_LOCAL_SYMBOL string main__cookie_mess(main__Context* ctx) {
	_option_string _t1 = veb__Context_get_cookie(&ctx->Context, _SLIT("mess"));
	if (_t1.state != 0) {
		IError err = _t1.err;
		*(string*) _t1.data = _SLIT("");
	}
	
 	string mess = (*(string*)_t1.data);
	veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = _SLIT(""),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
	return encoding__base64__url_decode_str(mess);
}
VV_LOCAL_SYMBOL void main__main(void) {
	cmd__CmdSet cmd_set = cmd__start(_const_main__version);
	_option_db__sqlite__DB _t1 = sql_db__connect_db(cmd_set.nohup, cmd_set.args);
	if (_t1.state != 0) {
		IError err = _t1.err;
		_v_exit(1);
		VUNREACHABLE();
	;
	}
	
 	db__sqlite__DB *db = HEAP(db__sqlite__DB, ((*(db__sqlite__DB*)_t1.data)));
	println(str_intp(2, _MOV((StrIntpData[]){{_SLIT("\346\232\202\344\270\215\346\224\257\346\214\201\350\256\276\347\275\256\347\272\277\347\250\213\346\225\260: "), 0xfe07, {.d_i32 = cmd_set.workers}}, {_SLIT0, 0, { .d_c = 0 }}})));
	main__App* app = main__new_app((*(db)));
	_result_void _t2 = veb__run_at_T_main__App_main__Context(app, ((veb__RunParams){.family = net__AddrFamily__ip6,.host = (string){.str=(byteptr)"", .is_lit=1},.port = cmd_set.port,.show_startup_message = true,.timeout_in_seconds = 30,}));
	if (_t2.is_error) {
		IError err = _t2.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 ;
}
VV_LOCAL_SYMBOL main__App* main__new_app(db__sqlite__DB _v_toheap_db) {
db__sqlite__DB* db = HEAP(db__sqlite__DB, _v_toheap_db);
	main__App* app = ((main__App*)memdup(&(main__App){.StaticHandler = ((veb__StaticHandler){.static_files = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.static_mime_types = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.static_hosts = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}),.Middleware = ((veb__Middleware_T_main__Context){.global_handlers = __new_array(0, 0, sizeof(voidptr)),.global_handlers_after = __new_array(0, 0, sizeof(voidptr)),.route_handlers = __new_array(0, 0, sizeof(veb__RouteMiddleware)),.route_handlers_after = __new_array(0, 0, sizeof(veb__RouteMiddleware)),}),.db = (*(db)),}, sizeof(main__App)));
	sql_db__test_main_function((voidptr)&app->db);
	map_set(&app->StaticHandler.static_mime_types, &(string[]){_SLIT(".cjs")}, &(string[]) { _SLIT("txt/javascript") });
	map_set(&app->StaticHandler.static_mime_types, &(string[]){_SLIT(".map")}, &(string[]) { _SLIT("txt/javascript") });
	map_set(&app->StaticHandler.static_mime_types, &(string[]){_SLIT(".vbs")}, &(string[]) { _SLIT("txt/javascript") });
	map_set(&app->StaticHandler.static_mime_types, &(string[]){_SLIT(".yml")}, &(string[]) { _SLIT("txt/javascript") });
	map_set(&app->StaticHandler.static_mime_types, &(string[]){_SLIT(".mts")}, &(string[]) { _SLIT("txt/javascript") });
	map_set(&app->StaticHandler.static_mime_types, &(string[]){_SLIT(".hml")}, &(string[]) { _SLIT("txt/javascript") });
	map_set(&app->StaticHandler.static_mime_types, &(string[]){_SLIT(".md")}, &(string[]) { _SLIT("txt/plain") });
	map_set(&app->StaticHandler.static_mime_types, &(string[]){_SLIT(".markdown")}, &(string[]) { _SLIT("txt/plain") });
	map_set(&app->StaticHandler.static_mime_types, &(string[]){_SLIT(".jade")}, &(string[]) { _SLIT("txt/plain") });
	map_set(&app->StaticHandler.static_mime_types, &(string[]){_SLIT(".png~")}, &(string[]) { _SLIT("image/png") });
	_result_bool _t1 = veb__StaticHandler_handle_static(&app->StaticHandler, _SLIT("static"), true);
	if (_t1.is_error) {
		IError err = _t1.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 ;
	veb__Middleware_T_main__Context_use_T_main__Context(&app->Middleware, veb__cors_T_main__Context(((veb__CorsOptions){.origins = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("*")})),.allow_credentials = 0,.allowed_headers = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("*")})),.allowed_methods = new_array_from_c_array_noscan(6, 6, sizeof(net__http__Method), _MOV((net__http__Method[6]){net__http__Method__get, net__http__Method__head, net__http__Method__patch, net__http__Method__put, net__http__Method__post, net__http__Method__delete})),.expose_headers = __new_array(0, 0, sizeof(string)),.max_age = (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },})));
	return app;
}
VV_LOCAL_SYMBOL veb__Result main__App_index(main__App* app, main__Context* ctx) {
	string mess = main__cookie_mess(ctx);
		strings__Builder sb_index4234 = strings__new_builder(6390);
		strings__Builder_write_string(&sb_index4234, str_intp(2, _MOV((StrIntpData[]){{_SLIT("<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=firefox\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <!-- \n    - \345\244\264\351\203\250tag\n  -->\n  <title>\347\254\254\344\272\214\345\261\212VYCTF\346\226\260\347\224\237\350\265\233</title>\n  <meta name=\"title\" content=\"VTF Copyleft \302\2512024 VYCMa Open Source China\">\n  <meta name=\"description\" content=\"CTF competition platform by vlang\">\n\n  <!-- \n    - \345\244\264\351\203\250\346\240\207\347\255\276\n  -->\n  <link rel=\"shortcut icon\" href=\"../image/sakana.png\" type=\"/image/svg+xml\">\n\n  <!-- \n    - \345\274\225\345\205\245css\346\226\207\344\273\266\n  -->\n  <link rel=\"stylesheet\" href=\"../css/style.css\">\n\n</head>\n\n<body id=\"top\">\n<header class=\"header\" data-header>\n  <div class=\"container\">\n\n    <a href=\"/\" class=\"logo\">\n      <img src=\"../image/vtf-logo.svg\" width=\"40\" alt=\"vtf-logo\">\n    </a>\n\n    <nav class=\"navbar\" data-navbar>\n\n      <div class=\"navbar-top\">\n        <a href=\"/\" class=\"logo\">\n          <img src=\"../image/vtf-logo.svg\" width=\"80\" alt=\"vtf-logo\">\n        </a>\n\n        <button class=\"nav-close-btn\" aria-label=\"close menu\" data-nav-toggler>\n          <ion-icon name=\"close-outline\" aria-hidden=\"true\"></ion-icon>\n        </button>\n      </div>\n\n      <ul class=\"navbar-list\">\n        <li>\n          <a href=\"console.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\247\345\210\266\345\217\260</a>\n        </li>\n        <li>\n          <a href=\"notice.html\" class=\"navbar-link hover-1\" data-nav-toggler>\345\221\212\347\244\272</a>\n        </li>\n\n        <li>\n          <a href=\"challenge.html\" class=\"navbar-link hover-1\" data-nav-toggler>\351\242\230\347\233\256</a>\n        </li>\n\n        <li>\n          <a href=\"ranking.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\222\345\220\215</a>\n        </li>\n\n        <li>\n          <a id=\"navbar4\" href=\"team.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\210\230\351\230\237</a>\n        </li>\n\n        <li>\n          <a id=\"navbar5\" href=\"member.html\" class=\"navbar-link hover-1\" data-nav-toggler>\344\270\252\344\272\272</a>\n        </li>\n\n      </ul>\n\n      <p class=\"navbar-bottom\">\n        <img src=\"../image/VYCMa.webp\" width=\"180\" alt=\"VYCMa\">\n      </p>\n\n      <p class=\"copyright-text\">\n        vtf platform copyleft \302\2512024 VYOSC.<br>\n        Open source follows the VY General License.<br>\n        vtf\346\257\224\350\265\233\345\271\263\345\217\260\347\224\261\302\2512024 VY\345\274\200\346\272\220\344\270\255\345\233\275 \345\274\200\346\272\220.<br>\n        \345\274\200\346\272\220\345\215\217\350\256\256\351\201\265\345\276\252VY\351\200\232\347\224\250\350\256\270\345\217\257\350\257\201.\n      </p>\n\n    </nav>\n\n    <button class=\"nav-open-btn\" aria-label=\"open menu\" data-nav-toggler>\n      <ion-icon name=\"menu-outline\" aria-hidden=\"true\"></ion-icon>\n    </button>\n\n  </div>\n</header>\n\n<!-- \n    - \345\257\274\345\205\245js\n  -->\n<script src=\"../js/script.js\"></script>\n<script src=\"../js/console.js\"></script>\n<script src=\"../js/rank.js\"></script>\n<script src=\"../js/mychart.js\"></script>\n\n<!--\n    - \345\217\257\350\247\206\345\214\226\347\225\214\351\235\242\n-->\n<script src=\"../js/node_modules/chart.js/dist/chart.umd.js\"></script>\n\n<script>\n  showinfo(\'"), 0xfe10, {.d_s = veb__filter(mess)}}, {_SLIT("\');\n  Chart.defaults.borderColor = \'rgba(0, 0, 0, 0.5)\';\n  Chart.defaults.color = \'rgb(255, 255, 255)\';\n</script>\n\n<!-- \n    - UI\351\223\276\346\216\245\n  -->\n<script type=\"module\" src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.esm.js\"></script>\n<script nomodule src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.js\"></script>\n\n<\n<main>\n  <a class=\"section-text\">\347\254\254\344\272\214\345\261\212VYCTF\346\214\221\346\210\230\350\265\233</a>\n  <img src=\"../image/vyctf.webp\" width=\"300\" alt=\"vtf-logo\">\n  <a class=\"text\">\345\274\200\345\247\213\346\227\266\351\227\264: 2024.10.31 8:00<br>\346\210\252\346\255\242\346\227\266\351\227\264: 2024.11.03 8:00</a>\n</main>\n\n\n<style>\n  main {\n    background: rgba(252, 93, 93, 0);\n    width: 350px;\n    padding: 20px;\n    position: absolute;\n    top: 15%;\n    left: 0;\n    right: 0;\n    margin: auto;\n  }\n\n  .modal {\n    position: fixed;\n    /* \345\233\272\345\256\232\345\234\250\350\247\206\345\217\243 */\n    z-index: 1;\n    /* \347\275\256\344\272\216\351\241\266\345\261\202 */\n    left: 0;\n    top: 0;\n    width: 100%;\n    /* \345\256\275\345\272\246\345\205\250\345\261\217 */\n    height: 100%;\n    /* \351\253\230\345\272\246\345\205\250\345\261\217 */\n    overflow: auto;\n    /* \345\205\201\350\256\270\346\273\232\345\212\250 */\n    background-color: rgba(0, 0, 0, 0.4);\n    /* \351\273\221\350\211\262\350\203\214\346\231\257\357\274\214\345\215\212\351\200\217\346\230\216 */\n  }\n\n  /* \346\250\241\346\200\201\346\241\206\345\206\205\345\256\271\346\240\267\345\274\217 */\n  .modal-content {\n    background-color: var(--bg-card-color);\n    margin: 15% auto;\n    /* 15% \345\236\202\347\233\264\344\275\215\347\275\256\357\274\214\346\260\264\345\271\263\345\261\205\344\270\255 */\n    padding: 20px;\n    border: 3px solid var(--bg-background-color);\n    width: 60%;\n    /* \346\210\226\346\214\207\345\256\232\345\256\275\345\272\246 */\n    max-width: 1000px;\n    border-radius: 10px;\n    color: var(--text-botton-white);\n  }\n\n  /* \350\276\223\345\205\245\346\241\206\346\240\267\345\274\217 */\n  .form .inputBox {\n    width: 100%;\n    margin-top: 20px;\n  }\n\n  /*\n    ========================\346\250\241\346\200\201\346\241\206=====================\n  */\n\n  .form .inputBox input {\n    width: 100%;\n    padding: 10px 20px;\n    background: rgba(255, 255, 255, 0.2);\n    outline: none;\n    border: none;\n    border-radius: 5px;\n    border: 1px solid rgba(255, 255, 255, 0.5);\n    border-right: 1px solid rgba(255, 255, 255, 0.2);\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n    font-size: 16px;\n    letter-spacing: 1px;\n    color: var(--text-botton-white);\n  }\n\n  .form .inputBox input::placeholder {\n    color: var(--text-botton-white);\n  }\n\n  /* \347\231\273\345\275\225\346\214\211\351\222\256\346\240\267\345\274\217 */\n\n  .form .inputBox a {\n    text-align: center;\n    margin: 0 auto;\n    background: var(--bg-botton-white);\n    color: var(--text-wild-blue-yonder);\n    max-width: 80px;\n    padding: 10px;\n    font-weight: 600;\n    border-radius: 10px;\n    cursor: pointer;\n  }\n</style>\n</body>\n</html>\n"), 0, { .d_c = 0 }}})));
		string _tmpl_res_index4234 = strings__Builder_str(&sb_index4234);
	veb__Context_html(ctx, _tmpl_res_index4234);
	strings__Builder_free(&sb_index4234);
	string_free(&_tmpl_res_index4234);
	;
}
VV_LOCAL_SYMBOL veb__Result main__App_find_index(main__App* app, main__Context* ctx) {
	return veb__Context_redirect(&ctx->Context, _SLIT("/"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
}
VV_LOCAL_SYMBOL veb__Result main__App_error(main__App* app, main__Context* ctx) {
	string mess = main__cookie_mess(ctx);
		strings__Builder sb_error4532 = strings__new_builder(4170);
		strings__Builder_write_string(&sb_error4532, str_intp(2, _MOV((StrIntpData[]){{_SLIT("<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=firefox\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <!-- \n    - \345\244\264\351\203\250tag\n  -->\n  <title>\347\254\254\344\272\214\345\261\212VYCTF\346\226\260\347\224\237\350\265\233</title>\n  <meta name=\"title\" content=\"VTF Copyleft \302\2512024 VYCMa Open Source China\">\n  <meta name=\"description\" content=\"CTF competition platform by vlang\">\n\n  <!-- \n    - \345\244\264\351\203\250\346\240\207\347\255\276\n  -->\n  <link rel=\"shortcut icon\" href=\"../image/sakana.png\" type=\"/image/svg+xml\">\n\n  <!-- \n    - \345\274\225\345\205\245css\346\226\207\344\273\266\n  -->\n  <link rel=\"stylesheet\" href=\"../css/style.css\">\n\n</head>\n\n<body id=\"top\">\n<header class=\"header\" data-header>\n  <div class=\"container\">\n\n    <a href=\"/\" class=\"logo\">\n      <img src=\"../image/vtf-logo.svg\" width=\"40\" alt=\"vtf-logo\">\n    </a>\n\n    <nav class=\"navbar\" data-navbar>\n\n      <div class=\"navbar-top\">\n        <a href=\"/\" class=\"logo\">\n          <img src=\"../image/vtf-logo.svg\" width=\"80\" alt=\"vtf-logo\">\n        </a>\n\n        <button class=\"nav-close-btn\" aria-label=\"close menu\" data-nav-toggler>\n          <ion-icon name=\"close-outline\" aria-hidden=\"true\"></ion-icon>\n        </button>\n      </div>\n\n      <ul class=\"navbar-list\">\n        <li>\n          <a href=\"console.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\247\345\210\266\345\217\260</a>\n        </li>\n        <li>\n          <a href=\"notice.html\" class=\"navbar-link hover-1\" data-nav-toggler>\345\221\212\347\244\272</a>\n        </li>\n\n        <li>\n          <a href=\"challenge.html\" class=\"navbar-link hover-1\" data-nav-toggler>\351\242\230\347\233\256</a>\n        </li>\n\n        <li>\n          <a href=\"ranking.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\222\345\220\215</a>\n        </li>\n\n        <li>\n          <a id=\"navbar4\" href=\"team.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\210\230\351\230\237</a>\n        </li>\n\n        <li>\n          <a id=\"navbar5\" href=\"member.html\" class=\"navbar-link hover-1\" data-nav-toggler>\344\270\252\344\272\272</a>\n        </li>\n\n      </ul>\n\n      <p class=\"navbar-bottom\">\n        <img src=\"../image/VYCMa.webp\" width=\"180\" alt=\"VYCMa\">\n      </p>\n\n      <p class=\"copyright-text\">\n        vtf platform copyleft \302\2512024 VYOSC.<br>\n        Open source follows the VY General License.<br>\n        vtf\346\257\224\350\265\233\345\271\263\345\217\260\347\224\261\302\2512024 VY\345\274\200\346\272\220\344\270\255\345\233\275 \345\274\200\346\272\220.<br>\n        \345\274\200\346\272\220\345\215\217\350\256\256\351\201\265\345\276\252VY\351\200\232\347\224\250\350\256\270\345\217\257\350\257\201.\n      </p>\n\n    </nav>\n\n    <button class=\"nav-open-btn\" aria-label=\"open menu\" data-nav-toggler>\n      <ion-icon name=\"menu-outline\" aria-hidden=\"true\"></ion-icon>\n    </button>\n\n  </div>\n</header>\n\n<!-- \n    - \345\257\274\345\205\245js\n  -->\n<script src=\"../js/script.js\"></script>\n<script src=\"../js/console.js\"></script>\n<script src=\"../js/rank.js\"></script>\n<script src=\"../js/mychart.js\"></script>\n\n<!--\n    - \345\217\257\350\247\206\345\214\226\347\225\214\351\235\242\n-->\n<script src=\"../js/node_modules/chart.js/dist/chart.umd.js\"></script>\n\n<script>\n  showinfo(\'"), 0xfe10, {.d_s = veb__filter(mess)}}, {_SLIT("\');\n  Chart.defaults.borderColor = \'rgba(0, 0, 0, 0.5)\';\n  Chart.defaults.color = \'rgb(255, 255, 255)\';\n</script>\n\n<!-- \n    - UI\351\223\276\346\216\245\n  -->\n<script type=\"module\" src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.esm.js\"></script>\n<script nomodule src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.js\"></script>\n\n<\n  <main>\n      <img src=\"../image/404.webp\" width=\"240\" alt=\"404\">\n      <a class=\"section-text\">\350\267\257\345\276\204\351\243\230\345\220\221\344\272\206\350\215\222\345\216\237</a>\n  </main>\n\n  <style>\n    main{\n      background: rgba(255, 255, 255, 0);\n      width: 280px;\n      padding: 20px;\n      position: absolute;\n      top: 20%;\n      left: 0;\n      right:0;\n      margin: auto;\n}\n  </style>\n\n\n</body>\n</html>\n"), 0, { .d_c = 0 }}})));
		string _tmpl_res_error4532 = strings__Builder_str(&sb_error4532);
	veb__Context_html(ctx, _tmpl_res_error4532);
	strings__Builder_free(&sb_error4532);
	string_free(&_tmpl_res_error4532);
	;
}
veb__Result main__Context_not_found(main__Context* ctx) {
	net__http__Response_set_status(&ctx->Context.res, net__http__Status__not_found);
	return veb__Context_redirect(&ctx->Context, _SLIT("/error.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
}
VV_LOCAL_SYMBOL veb__Result main__App_login(main__App* app, main__Context* ctx) {
	string mess = main__cookie_mess(ctx);
	string c_id = main__cookie_id(*ctx);
	if ((c_id).len == 0) {
			strings__Builder sb_login4897 = strings__new_builder(6540);
			strings__Builder_write_string(&sb_login4897, str_intp(2, _MOV((StrIntpData[]){{_SLIT("<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=firefox\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <!-- \n    - \345\244\264\351\203\250tag\n  -->\n  <title>\347\254\254\344\272\214\345\261\212VYCTF\346\226\260\347\224\237\350\265\233</title>\n  <meta name=\"title\" content=\"VTF Copyleft \302\2512024 VYCMa Open Source China\">\n  <meta name=\"description\" content=\"CTF competition platform by vlang\">\n\n  <!-- \n    - \345\244\264\351\203\250\346\240\207\347\255\276\n  -->\n  <link rel=\"shortcut icon\" href=\"../image/sakana.png\" type=\"/image/svg+xml\">\n\n  <!-- \n    - \345\274\225\345\205\245css\346\226\207\344\273\266\n  -->\n  <link rel=\"stylesheet\" href=\"../css/style.css\">\n\n</head>\n\n<body id=\"top\">\n<header class=\"header\" data-header>\n  <div class=\"container\">\n\n    <a href=\"/\" class=\"logo\">\n      <img src=\"../image/vtf-logo.svg\" width=\"40\" alt=\"vtf-logo\">\n    </a>\n\n    <nav class=\"navbar\" data-navbar>\n\n      <div class=\"navbar-top\">\n        <a href=\"/\" class=\"logo\">\n          <img src=\"../image/vtf-logo.svg\" width=\"80\" alt=\"vtf-logo\">\n        </a>\n\n        <button class=\"nav-close-btn\" aria-label=\"close menu\" data-nav-toggler>\n          <ion-icon name=\"close-outline\" aria-hidden=\"true\"></ion-icon>\n        </button>\n      </div>\n\n      <ul class=\"navbar-list\">\n        <li>\n          <a href=\"console.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\247\345\210\266\345\217\260</a>\n        </li>\n        <li>\n          <a href=\"notice.html\" class=\"navbar-link hover-1\" data-nav-toggler>\345\221\212\347\244\272</a>\n        </li>\n\n        <li>\n          <a href=\"challenge.html\" class=\"navbar-link hover-1\" data-nav-toggler>\351\242\230\347\233\256</a>\n        </li>\n\n        <li>\n          <a href=\"ranking.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\222\345\220\215</a>\n        </li>\n\n        <li>\n          <a id=\"navbar4\" href=\"team.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\210\230\351\230\237</a>\n        </li>\n\n        <li>\n          <a id=\"navbar5\" href=\"member.html\" class=\"navbar-link hover-1\" data-nav-toggler>\344\270\252\344\272\272</a>\n        </li>\n\n      </ul>\n\n      <p class=\"navbar-bottom\">\n        <img src=\"../image/VYCMa.webp\" width=\"180\" alt=\"VYCMa\">\n      </p>\n\n      <p class=\"copyright-text\">\n        vtf platform copyleft \302\2512024 VYOSC.<br>\n        Open source follows the VY General License.<br>\n        vtf\346\257\224\350\265\233\345\271\263\345\217\260\347\224\261\302\2512024 VY\345\274\200\346\272\220\344\270\255\345\233\275 \345\274\200\346\272\220.<br>\n        \345\274\200\346\272\220\345\215\217\350\256\256\351\201\265\345\276\252VY\351\200\232\347\224\250\350\256\270\345\217\257\350\257\201.\n      </p>\n\n    </nav>\n\n    <button class=\"nav-open-btn\" aria-label=\"open menu\" data-nav-toggler>\n      <ion-icon name=\"menu-outline\" aria-hidden=\"true\"></ion-icon>\n    </button>\n\n  </div>\n</header>\n\n<!-- \n    - \345\257\274\345\205\245js\n  -->\n<script src=\"../js/script.js\"></script>\n<script src=\"../js/console.js\"></script>\n<script src=\"../js/rank.js\"></script>\n<script src=\"../js/mychart.js\"></script>\n\n<!--\n    - \345\217\257\350\247\206\345\214\226\347\225\214\351\235\242\n-->\n<script src=\"../js/node_modules/chart.js/dist/chart.umd.js\"></script>\n\n<script>\n  showinfo(\'"), 0xfe10, {.d_s = veb__filter(mess)}}, {_SLIT("\');\n  Chart.defaults.borderColor = \'rgba(0, 0, 0, 0.5)\';\n  Chart.defaults.color = \'rgb(255, 255, 255)\';\n</script>\n\n<!-- \n    - UI\351\223\276\346\216\245\n  -->\n<script type=\"module\" src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.esm.js\"></script>\n<script nomodule src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.js\"></script>\n\n<\n<main>\n  <div class=\"form\">\n    <h2>\347\231\273\345\275\225\350\264\246\345\217\267</h2>\n    <form>\n      <div class=\"inputBox\"><input id=\"email\" type=\"text\" placeholder=\"ID/\351\202\256\347\256\261\"></div>\n      <div class=\"inputBox\"><input id=\"passwd\" type=\"password\" placeholder=\"\345\257\206\347\240\201\"></div>\n\n      <div class=\"inputBox\"><a onclick=\"passwdlogin()\">\347\231\273\345\275\225</a></div>\n      <div class=\"forget-font\">\n        <a href=\"#\" onclick=\"ForgetPasswd()\" class=\"forget\">\345\277\230\350\256\260\345\257\206\347\240\201?</a>\n        <a href=\"signup.html\" class=\"forget\">\346\263\250\345\206\214\350\264\246\345\217\267</a>\n      </div>\n    </form>\n  </div>\n</main>\n\n<style>\n  main {\n    background: var(--bg-card-color);\n    width: 400px;\n    padding: 5px;\n    position: absolute;\n    top: 25%;\n    left: 0;\n    right: 0;\n    margin: auto;\n    border-radius: 10px;\n  }\n\n  .form {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    padding: 50px;\n  }\n\n  .form h2 {\n    text-align: center;\n    position: relative;\n    color: var(--text-botton-white);\n    font-size: 24px;\n    font-weight: 600;\n    letter-spacing: 5px;\n    margin-bottom: 30px;\n    cursor: pointer;\n  }\n\n  .form h2:hover:before {\n    width: 53px;\n  }\n\n  .form .inputBox {\n    width: 100%;\n    margin-top: 20px;\n  }\n\n  .form .inputBox input {\n    width: 100%;\n    padding: 10px 20px;\n    background: rgba(255, 255, 255, 0.2);\n    outline: none;\n    border: none;\n    border-radius: 5px;\n    border: 1px solid rgba(255, 255, 255, 0.5);\n    border-right: 1px solid rgba(255, 255, 255, 0.2);\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n    font-size: 16px;\n    letter-spacing: 1px;\n    color: var(--text-botton-white);\n  }\n\n  .form .inputBox input::placeholder {\n    color: var(--text-botton-white);\n  }\n\n  /* \347\231\273\345\275\225\346\214\211\351\222\256\346\240\267\345\274\217 */\n  .form .inputBox a {\n    text-align: center;\n    margin: 0 auto;\n    background: var(--bg-botton-white);\n    color: var(--text-wild-blue-yonder);\n    max-width: 80px;\n    padding: 10px;\n    font-weight: 600;\n    border-radius: 10px;\n    cursor: pointer;\n  }\n\n  .forget-font {\n    margin-top: 30px;\n  }\n\n  .forget {\n    margin-top: 3px;\n    color: var(--text-carolina-blue);\n    letter-spacing: 1px;\n  }\n</style>\n</body>\n</html>\n"), 0, { .d_c = 0 }}})));
			string _tmpl_res_login4897 = strings__Builder_str(&sb_login4897);
		veb__Context_html(ctx, _tmpl_res_login4897);
		strings__Builder_free(&sb_login4897);
		string_free(&_tmpl_res_login4897);
		;
	} else {
		return veb__Context_redirect(&ctx->Context, _SLIT("/member.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
	}
	return (veb__Result){0};
}
VV_LOCAL_SYMBOL veb__Result main__App_loginapi(main__App* app, main__Context* ctx) {
	string email = encoding__base64__url_decode_str((*(string*)map_get(ADDR(map, ctx->Context.form), &(string[]){_SLIT("email")}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
	string passwd = encoding__base64__url_decode_str((*(string*)map_get(ADDR(map, ctx->Context.form), &(string[]){_SLIT("passwd")}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
	sql_db__StatusReturn select_passwd = sql_db__select_passwd_db(app->db, veb__Context_ip(&ctx->Context), email, passwd);
	if (select_passwd.return_bool) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \347\224\250\346\210\267\344\270\215\345\255\230\345\234\250")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_text(&ctx->Context, _SLIT("401: User not found."));
	}
	if (select_passwd.find_passwd) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \345\257\206\347\240\201\351\224\231\350\257\257")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_text(&ctx->Context, _SLIT("403: Password is Wrong."));
	} else {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("id"),.value = (*(sql_db__Personal*)array_get(select_passwd.id_check, 0)).id,.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("passwd"),.value = encoding__base64__url_encode_str(passwd),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		veb__Context_redirect(&ctx->Context, _SLIT("/member.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
		return veb__Context_text(&ctx->Context, _SLIT("200: Seccess."));
	}
	return veb__Context_text(&ctx->Context, _SLIT("404: Not found."));
}
VV_LOCAL_SYMBOL veb__Result main__App_signup(main__App* app, main__Context* ctx) {
	string mess = main__cookie_mess(ctx);
	string c_id = main__cookie_id(*ctx);
	if ((c_id).len == 0) {
			strings__Builder sb_signup6157 = strings__new_builder(6420);
			strings__Builder_write_string(&sb_signup6157, str_intp(2, _MOV((StrIntpData[]){{_SLIT("<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=firefox\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <!-- \n    - \345\244\264\351\203\250tag\n  -->\n  <title>\347\254\254\344\272\214\345\261\212VYCTF\346\226\260\347\224\237\350\265\233</title>\n  <meta name=\"title\" content=\"VTF Copyleft \302\2512024 VYCMa Open Source China\">\n  <meta name=\"description\" content=\"CTF competition platform by vlang\">\n\n  <!-- \n    - \345\244\264\351\203\250\346\240\207\347\255\276\n  -->\n  <link rel=\"shortcut icon\" href=\"../image/sakana.png\" type=\"/image/svg+xml\">\n\n  <!-- \n    - \345\274\225\345\205\245css\346\226\207\344\273\266\n  -->\n  <link rel=\"stylesheet\" href=\"../css/style.css\">\n\n</head>\n\n<body id=\"top\">\n<header class=\"header\" data-header>\n  <div class=\"container\">\n\n    <a href=\"/\" class=\"logo\">\n      <img src=\"../image/vtf-logo.svg\" width=\"40\" alt=\"vtf-logo\">\n    </a>\n\n    <nav class=\"navbar\" data-navbar>\n\n      <div class=\"navbar-top\">\n        <a href=\"/\" class=\"logo\">\n          <img src=\"../image/vtf-logo.svg\" width=\"80\" alt=\"vtf-logo\">\n        </a>\n\n        <button class=\"nav-close-btn\" aria-label=\"close menu\" data-nav-toggler>\n          <ion-icon name=\"close-outline\" aria-hidden=\"true\"></ion-icon>\n        </button>\n      </div>\n\n      <ul class=\"navbar-list\">\n        <li>\n          <a href=\"console.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\247\345\210\266\345\217\260</a>\n        </li>\n        <li>\n          <a href=\"notice.html\" class=\"navbar-link hover-1\" data-nav-toggler>\345\221\212\347\244\272</a>\n        </li>\n\n        <li>\n          <a href=\"challenge.html\" class=\"navbar-link hover-1\" data-nav-toggler>\351\242\230\347\233\256</a>\n        </li>\n\n        <li>\n          <a href=\"ranking.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\222\345\220\215</a>\n        </li>\n\n        <li>\n          <a id=\"navbar4\" href=\"team.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\210\230\351\230\237</a>\n        </li>\n\n        <li>\n          <a id=\"navbar5\" href=\"member.html\" class=\"navbar-link hover-1\" data-nav-toggler>\344\270\252\344\272\272</a>\n        </li>\n\n      </ul>\n\n      <p class=\"navbar-bottom\">\n        <img src=\"../image/VYCMa.webp\" width=\"180\" alt=\"VYCMa\">\n      </p>\n\n      <p class=\"copyright-text\">\n        vtf platform copyleft \302\2512024 VYOSC.<br>\n        Open source follows the VY General License.<br>\n        vtf\346\257\224\350\265\233\345\271\263\345\217\260\347\224\261\302\2512024 VY\345\274\200\346\272\220\344\270\255\345\233\275 \345\274\200\346\272\220.<br>\n        \345\274\200\346\272\220\345\215\217\350\256\256\351\201\265\345\276\252VY\351\200\232\347\224\250\350\256\270\345\217\257\350\257\201.\n      </p>\n\n    </nav>\n\n    <button class=\"nav-open-btn\" aria-label=\"open menu\" data-nav-toggler>\n      <ion-icon name=\"menu-outline\" aria-hidden=\"true\"></ion-icon>\n    </button>\n\n  </div>\n</header>\n\n<!-- \n    - \345\257\274\345\205\245js\n  -->\n<script src=\"../js/script.js\"></script>\n<script src=\"../js/console.js\"></script>\n<script src=\"../js/rank.js\"></script>\n<script src=\"../js/mychart.js\"></script>\n\n<!--\n    - \345\217\257\350\247\206\345\214\226\347\225\214\351\235\242\n-->\n<script src=\"../js/node_modules/chart.js/dist/chart.umd.js\"></script>\n\n<script>\n  showinfo(\'"), 0xfe10, {.d_s = veb__filter(mess)}}, {_SLIT("\');\n  Chart.defaults.borderColor = \'rgba(0, 0, 0, 0.5)\';\n  Chart.defaults.color = \'rgb(255, 255, 255)\';\n</script>\n\n<!-- \n    - UI\351\223\276\346\216\245\n  -->\n<script type=\"module\" src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.esm.js\"></script>\n<script nomodule src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.js\"></script>\n\n<\n<main>\n  <div class=\"form\">\n    <h2>\346\263\250\345\206\214\350\264\246\345\217\267</h2>\n    <form>\n      <div class=\"inputBox\"><input id=\"id\" type=\"text\" placeholder=\"ID\"></div>\n      <div class=\"inputBox\"><input id=\"email\" type=\"text\" placeholder=\"\351\202\256\347\256\261\"></div>\n      <div class=\"inputBox\"><input id=\"passwd\" type=\"password\" placeholder=\"\345\257\206\347\240\201\"></div>\n      <div class=\"inputBox\"><input id=\"passwdagain\" type=\"password\" placeholder=\"\347\241\256\350\256\244\345\257\206\347\240\201\"></div>\n      <div class=\"inputBox\"><a onclick=\"signup()\">\346\263\250\345\206\214</a></div>\n      <a href=\"login.html\" class=\"forget\">\345\267\262\346\234\211\350\264\246\345\217\267</a>\n    </form>\n  </div>\n</main>\n\n<style>\n  main {\n    background: var(--bg-card-color);\n    width: 400px;\n    padding: 5px;\n    position: absolute;\n    top: 25%;\n    left: 0;\n    right: 0;\n    margin: auto;\n    border-radius: 10px;\n  }\n\n  .form {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    padding: 50px;\n  }\n\n  .form h2 {\n    text-align: center;\n    position: relative;\n    color: var(--text-botton-white);\n    font-size: 24px;\n    font-weight: 600;\n    letter-spacing: 5px;\n    margin-bottom: 30px;\n    cursor: pointer;\n  }\n\n  .form h2:hover:before {\n    width: 53px;\n  }\n\n  .form .inputBox {\n    width: 100%;\n    margin-top: 20px;\n  }\n\n  .form .inputBox input {\n    width: 100%;\n    padding: 10px 20px;\n    background: rgba(255, 255, 255, 0.2);\n    outline: none;\n    border: none;\n    border-radius: 5px;\n    border: 1px solid rgba(255, 255, 255, 0.5);\n    border-right: 1px solid rgba(255, 255, 255, 0.2);\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n    font-size: 16px;\n    letter-spacing: 1px;\n    color: var(--text-botton-white);\n  }\n\n  .form .inputBox input::placeholder {\n    color: var(--text-botton-white);\n  }\n\n  /* \347\231\273\345\275\225\346\214\211\351\222\256\346\240\267\345\274\217 */\n\n  .form .inputBox a {\n\n    text-align: center;\n    margin: 0 auto;\n    background: var(--bg-botton-white);\n    color: var(--text-wild-blue-yonder);\n    max-width: 80px;\n    padding: 10px;\n    font-weight: 600;\n    border-radius: 10px;\n    cursor: pointer;\n  }\n\n  .forget {\n    margin-top: 30px;\n    color: var(--text-carolina-blue);\n    letter-spacing: 1px;\n  }\n</style>\n</body>\n</html>\n"), 0, { .d_c = 0 }}})));
			string _tmpl_res_signup6157 = strings__Builder_str(&sb_signup6157);
		veb__Context_html(ctx, _tmpl_res_signup6157);
		strings__Builder_free(&sb_signup6157);
		string_free(&_tmpl_res_signup6157);
		;
	} else {
		return veb__Context_redirect(&ctx->Context, _SLIT("/member.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
	}
	return (veb__Result){0};
}
VV_LOCAL_SYMBOL veb__Result main__App_signupapi(main__App* app, main__Context* ctx) {
	string id = encoding__base64__url_decode_str((*(string*)map_get(ADDR(map, ctx->Context.form), &(string[]){_SLIT("id")}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
	string email = encoding__base64__url_decode_str((*(string*)map_get(ADDR(map, ctx->Context.form), &(string[]){_SLIT("email")}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
	string passwd = encoding__base64__url_decode_str((*(string*)map_get(ADDR(map, ctx->Context.form), &(string[]){_SLIT("passwd")}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
	if ((string_index(id, _SLIT("@"))).state != 2) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \345\220\215\347\247\260\344\270\255\347\246\201\346\255\242\345\214\205\345\220\253\"@\"")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_text(&ctx->Context, _SLIT("401: Usernames are forbidden to contain \"@\"."));
	}
	if ((string_index(email, _SLIT("@"))).state == 2) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: email\346\240\274\345\274\217\345\255\230\345\234\250\351\224\231\350\257\257")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_text(&ctx->Context, _SLIT("401: There is an error in the email format."));
	}
	if (sql_db__register_status(app->db, id, email, passwd)) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \346\243\200\346\265\213\345\210\260\346\217\220\344\272\244\346\227\240\346\225\210\346\225\260\346\215\256")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_text(&ctx->Context, _SLIT("403: Invalid data was detected"));
	}
	if (sql_db__register_db(app->db, id, email, passwd)) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \345\255\230\345\202\250\346\225\260\346\215\256\345\207\272\351\224\231")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_redirect(&ctx->Context, _SLIT("/error.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
	}
	veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("id"),.value = encoding__base64__url_encode_str(id),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
	veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("passwd"),.value = encoding__base64__url_encode_str(passwd),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
	return veb__Context_redirect(&ctx->Context, _SLIT("/error.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
}
VV_LOCAL_SYMBOL veb__Result main__App_member(main__App* app, main__Context* ctx) {
	string mess = main__cookie_mess(ctx);
	string c_id = main__cookie_id(*ctx);
	string c_pwd = main__cookie_passwd(*ctx);
	sql_db__StatusReturn login = sql_db__login_status(app->db, c_id, c_pwd);
	if ((c_id).len == 0) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \350\257\267\347\231\273\345\275\225\345\220\216\346\237\245\347\234\213")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_redirect(&ctx->Context, _SLIT("/login.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
	} else if (login.return_bool) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("whoami"),.value = encoding__base64__url_encode_str((*(sql_db__Personal*)array_first(login.id_check)).whoami),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		string name = c_id;
		string email = encoding__base64__url_decode_str((*(sql_db__Personal*)array_get(login.id_check, 0)).email);
			strings__Builder sb_member8246 = strings__new_builder(7560);
			strings__Builder_write_string(&sb_member8246, str_intp(4, _MOV((StrIntpData[]){{_SLIT("<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=firefox\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <!-- \n    - \345\244\264\351\203\250tag\n  -->\n  <title>\347\254\254\344\272\214\345\261\212VYCTF\346\226\260\347\224\237\350\265\233</title>\n  <meta name=\"title\" content=\"VTF Copyleft \302\2512024 VYCMa Open Source China\">\n  <meta name=\"description\" content=\"CTF competition platform by vlang\">\n\n  <!-- \n    - \345\244\264\351\203\250\346\240\207\347\255\276\n  -->\n  <link rel=\"shortcut icon\" href=\"../image/sakana.png\" type=\"/image/svg+xml\">\n\n  <!-- \n    - \345\274\225\345\205\245css\346\226\207\344\273\266\n  -->\n  <link rel=\"stylesheet\" href=\"../css/style.css\">\n\n</head>\n\n<body id=\"top\">\n<header class=\"header\" data-header>\n  <div class=\"container\">\n\n    <a href=\"/\" class=\"logo\">\n      <img src=\"../image/vtf-logo.svg\" width=\"40\" alt=\"vtf-logo\">\n    </a>\n\n    <nav class=\"navbar\" data-navbar>\n\n      <div class=\"navbar-top\">\n        <a href=\"/\" class=\"logo\">\n          <img src=\"../image/vtf-logo.svg\" width=\"80\" alt=\"vtf-logo\">\n        </a>\n\n        <button class=\"nav-close-btn\" aria-label=\"close menu\" data-nav-toggler>\n          <ion-icon name=\"close-outline\" aria-hidden=\"true\"></ion-icon>\n        </button>\n      </div>\n\n      <ul class=\"navbar-list\">\n        <li>\n          <a href=\"console.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\247\345\210\266\345\217\260</a>\n        </li>\n        <li>\n          <a href=\"notice.html\" class=\"navbar-link hover-1\" data-nav-toggler>\345\221\212\347\244\272</a>\n        </li>\n\n        <li>\n          <a href=\"challenge.html\" class=\"navbar-link hover-1\" data-nav-toggler>\351\242\230\347\233\256</a>\n        </li>\n\n        <li>\n          <a href=\"ranking.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\222\345\220\215</a>\n        </li>\n\n        <li>\n          <a id=\"navbar4\" href=\"team.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\210\230\351\230\237</a>\n        </li>\n\n        <li>\n          <a id=\"navbar5\" href=\"member.html\" class=\"navbar-link hover-1\" data-nav-toggler>\344\270\252\344\272\272</a>\n        </li>\n\n      </ul>\n\n      <p class=\"navbar-bottom\">\n        <img src=\"../image/VYCMa.webp\" width=\"180\" alt=\"VYCMa\">\n      </p>\n\n      <p class=\"copyright-text\">\n        vtf platform copyleft \302\2512024 VYOSC.<br>\n        Open source follows the VY General License.<br>\n        vtf\346\257\224\350\265\233\345\271\263\345\217\260\347\224\261\302\2512024 VY\345\274\200\346\272\220\344\270\255\345\233\275 \345\274\200\346\272\220.<br>\n        \345\274\200\346\272\220\345\215\217\350\256\256\351\201\265\345\276\252VY\351\200\232\347\224\250\350\256\270\345\217\257\350\257\201.\n      </p>\n\n    </nav>\n\n    <button class=\"nav-open-btn\" aria-label=\"open menu\" data-nav-toggler>\n      <ion-icon name=\"menu-outline\" aria-hidden=\"true\"></ion-icon>\n    </button>\n\n  </div>\n</header>\n\n<!-- \n    - \345\257\274\345\205\245js\n  -->\n<script src=\"../js/script.js\"></script>\n<script src=\"../js/console.js\"></script>\n<script src=\"../js/rank.js\"></script>\n<script src=\"../js/mychart.js\"></script>\n\n<!--\n    - \345\217\257\350\247\206\345\214\226\347\225\214\351\235\242\n-->\n<script src=\"../js/node_modules/chart.js/dist/chart.umd.js\"></script>\n\n<script>\n  showinfo(\'"), 0xfe10, {.d_s = veb__filter(mess)}}, {_SLIT("\');\n  Chart.defaults.borderColor = \'rgba(0, 0, 0, 0.5)\';\n  Chart.defaults.color = \'rgb(255, 255, 255)\';\n</script>\n\n<!-- \n    - UI\351\223\276\346\216\245\n  -->\n<script type=\"module\" src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.esm.js\"></script>\n<script nomodule src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.js\"></script>\n\n<\n<main>\n    <div class=\"form\">\n        <h2>"), 0xfe10, {.d_s = veb__filter(name)}}, {_SLIT("</h2>\n        <h3 class=\"mess-text\">\351\202\256\347\256\261:</h3>\n        <h3 class=\"con-text\">"), 0xfe10, {.d_s = veb__filter(email)}}, {_SLIT("</h3><br>\n        <div class=\"logout\"><a onclick=\"logout()\">\351\200\200\345\207\272</a></div>\n        <h4 class=\"mess-text\">\344\277\256\346\224\271\345\257\206\347\240\201:</h4>\n        <form>\n            <div class=\"inputBox\"><input id=\"old-passwd\" type=\"text\" placeholder=\"\345\210\235\345\247\213\345\257\206\347\240\201\"></div>\n            <div class=\"inputBox\"><input id=\"new-passwd\" type=\"password\" placeholder=\"\346\226\260\347\232\204\345\257\206\347\240\201\"></div>\n            <div class=\"inputBox\"><input id=\"passwd-again\" type=\"password\" placeholder=\"\347\241\256\350\256\244\345\257\206\347\240\201\"></div>\n            <div class=\"inputBox\"><a onclick=\"fixpasswd()\">\346\233\264\346\226\260</a></div>\n        </form>\n\n\n    </div>\n</main>\n\n<style>\n    main {\n        background: var(--bg-card-color);\n        width: 400px;\n        padding: 5px;\n        padding-bottom: 45px;\n        position: absolute;\n        top: 20%;\n        left: 0;\n        right: 0;\n        margin: auto;\n        border-radius: 10px;\n    }\n\n    .form {\n        position: relative;\n        width: 100%;\n        height: 100%;\n        padding: 50px;\n    }\n\n    .form h2 {\n        text-align: center;\n        position: relative;\n        color: var(--text-botton-white);\n        font-size: 24px;\n        font-weight: 600;\n        letter-spacing: 1px;\n        margin-bottom: 30px;\n        cursor: pointer;\n    }\n\n    .form h2:hover:before {\n        width: 53px;\n    }\n\n    .form .inputBox {\n        width: 100%;\n        margin-top: 20px;\n    }\n\n    .form .inputBox input {\n        width: 100%;\n        padding: 10px 20px;\n        background: rgba(255, 255, 255, 0.2);\n        outline: none;\n        border: none;\n        border-radius: 5px;\n        border: 1px solid rgba(255, 255, 255, 0.5);\n        border-right: 1px solid rgba(255, 255, 255, 0.2);\n        border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n        font-size: 16px;\n        letter-spacing: 1px;\n        color: var(--text-botton-white);\n    }\n\n    .form .inputBox input::placeholder {\n        color: var(--text-botton-white);\n    }\n\n    /* \347\231\273\345\275\225\346\214\211\351\222\256\346\240\267\345\274\217 */\n\n    .form .inputBox a {\n        text-align: center;\n        margin: 0 auto;\n        background: var(--bg-botton-white);\n        color: var(--text-wild-blue-yonder);\n        max-width: 80px;\n        padding: 10px;\n        font-weight: 600;\n        border-radius: 10px;\n        cursor: pointer;\n    }\n\n    /* \347\231\273\345\207\272\346\214\211\351\222\256\346\240\267\345\274\217 */\n\n    .form .logout {\n        width: 100%;\n        margin-top: 10px;\n    }\n\n    .form .logout input {\n        width: 100%;\n        padding: 10px 20px;\n        background: rgba(255, 255, 255, 0.2);\n        outline: none;\n        border: none;\n        border-radius: 5px;\n        border: 1px solid rgba(255, 255, 255, 0.5);\n        border-right: 1px solid rgba(255, 255, 255, 0.2);\n        border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n        font-size: 16px;\n        letter-spacing: 1px;\n        color: var(--text-botton-white);\n    }\n\n    .form .logout input::placeholder {\n        color: var(--text-have-url-color);\n    }\n\n    .form .logout a {\n        text-align: center;\n        position: absolute;\n        right: 14%;\n        top: 125px;\n        background: var(--bg-botton-white);\n        color: var(--text-wild-blue-yonder);\n        width: 80px;\n        padding: 10px;\n        font-weight: 600;\n        border-radius: 10px;\n        cursor: pointer;\n    }\n</style>\n</body>\n</html>\n"), 0, { .d_c = 0 }}})));
			string _tmpl_res_member8246 = strings__Builder_str(&sb_member8246);
		veb__Context_html(ctx, _tmpl_res_member8246);
		strings__Builder_free(&sb_member8246);
		string_free(&_tmpl_res_member8246);
		;
	} else {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("id"),.value = _SLIT(""),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_redirect(&ctx->Context, _SLIT("/error.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
	}
	return (veb__Result){0};
}
VV_LOCAL_SYMBOL veb__Result main__App_memberapi(main__App* app, main__Context* ctx) {
	string c_id = main__cookie_id(*ctx);
	string oldpasswd = encoding__base64__url_decode_str((*(string*)map_get(ADDR(map, ctx->Context.form), &(string[]){_SLIT("oldpasswd")}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
	string newpasswd = encoding__base64__url_decode_str((*(string*)map_get(ADDR(map, ctx->Context.form), &(string[]){_SLIT("newpasswd")}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
	if (sql_db__id_check(app->db, c_id, oldpasswd, newpasswd)) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("passwd"),.value = newpasswd,.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
	} else {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \344\277\256\346\224\271\345\257\206\347\240\201\345\244\261\350\264\245")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
	}
	return veb__Context_redirect(&ctx->Context, _SLIT("/member.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
}
VV_LOCAL_SYMBOL veb__Result main__App_challenge(main__App* app, main__Context* ctx, string display_challenge) {
	string mess = main__cookie_mess(ctx);
	string c_id = main__cookie_id(*ctx);
	string c_pwd = main__cookie_passwd(*ctx);
	sql_db__StatusReturn login = sql_db__login_status(app->db, c_id, c_pwd);
	if ((c_id).len == 0) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \350\257\267\347\231\273\345\275\225\345\220\216\346\237\245\347\234\213")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_redirect(&ctx->Context, _SLIT("/login.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
	} else if (login.return_bool) {
		int c_pid = sql_db__find_user(app->db, encoding__base64__url_encode_str(c_id), c_pwd).pid;
		Array_sql_db__Type list_of_type = sql_db__build_challenge(app->db);
			strings__Builder sb_challenge9492 = strings__new_builder(11430);
			strings__Builder_write_string(&sb_challenge9492, str_intp(2, _MOV((StrIntpData[]){{_SLIT("<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=firefox\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <!-- \n    - \345\244\264\351\203\250tag\n  -->\n  <title>\347\254\254\344\272\214\345\261\212VYCTF\346\226\260\347\224\237\350\265\233</title>\n  <meta name=\"title\" content=\"VTF Copyleft \302\2512024 VYCMa Open Source China\">\n  <meta name=\"description\" content=\"CTF competition platform by vlang\">\n\n  <!-- \n    - \345\244\264\351\203\250\346\240\207\347\255\276\n  -->\n  <link rel=\"shortcut icon\" href=\"../image/sakana.png\" type=\"/image/svg+xml\">\n\n  <!-- \n    - \345\274\225\345\205\245css\346\226\207\344\273\266\n  -->\n  <link rel=\"stylesheet\" href=\"../css/style.css\">\n\n</head>\n\n<body id=\"top\">\n<header class=\"header\" data-header>\n  <div class=\"container\">\n\n    <a href=\"/\" class=\"logo\">\n      <img src=\"../image/vtf-logo.svg\" width=\"40\" alt=\"vtf-logo\">\n    </a>\n\n    <nav class=\"navbar\" data-navbar>\n\n      <div class=\"navbar-top\">\n        <a href=\"/\" class=\"logo\">\n          <img src=\"../image/vtf-logo.svg\" width=\"80\" alt=\"vtf-logo\">\n        </a>\n\n        <button class=\"nav-close-btn\" aria-label=\"close menu\" data-nav-toggler>\n          <ion-icon name=\"close-outline\" aria-hidden=\"true\"></ion-icon>\n        </button>\n      </div>\n\n      <ul class=\"navbar-list\">\n        <li>\n          <a href=\"console.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\247\345\210\266\345\217\260</a>\n        </li>\n        <li>\n          <a href=\"notice.html\" class=\"navbar-link hover-1\" data-nav-toggler>\345\221\212\347\244\272</a>\n        </li>\n\n        <li>\n          <a href=\"challenge.html\" class=\"navbar-link hover-1\" data-nav-toggler>\351\242\230\347\233\256</a>\n        </li>\n\n        <li>\n          <a href=\"ranking.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\222\345\220\215</a>\n        </li>\n\n        <li>\n          <a id=\"navbar4\" href=\"team.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\210\230\351\230\237</a>\n        </li>\n\n        <li>\n          <a id=\"navbar5\" href=\"member.html\" class=\"navbar-link hover-1\" data-nav-toggler>\344\270\252\344\272\272</a>\n        </li>\n\n      </ul>\n\n      <p class=\"navbar-bottom\">\n        <img src=\"../image/VYCMa.webp\" width=\"180\" alt=\"VYCMa\">\n      </p>\n\n      <p class=\"copyright-text\">\n        vtf platform copyleft \302\2512024 VYOSC.<br>\n        Open source follows the VY General License.<br>\n        vtf\346\257\224\350\265\233\345\271\263\345\217\260\347\224\261\302\2512024 VY\345\274\200\346\272\220\344\270\255\345\233\275 \345\274\200\346\272\220.<br>\n        \345\274\200\346\272\220\345\215\217\350\256\256\351\201\265\345\276\252VY\351\200\232\347\224\250\350\256\270\345\217\257\350\257\201.\n      </p>\n\n    </nav>\n\n    <button class=\"nav-open-btn\" aria-label=\"open menu\" data-nav-toggler>\n      <ion-icon name=\"menu-outline\" aria-hidden=\"true\"></ion-icon>\n    </button>\n\n  </div>\n</header>\n\n<!-- \n    - \345\257\274\345\205\245js\n  -->\n<script src=\"../js/script.js\"></script>\n<script src=\"../js/console.js\"></script>\n<script src=\"../js/rank.js\"></script>\n<script src=\"../js/mychart.js\"></script>\n\n<!--\n    - \345\217\257\350\247\206\345\214\226\347\225\214\351\235\242\n-->\n<script src=\"../js/node_modules/chart.js/dist/chart.umd.js\"></script>\n\n<script>\n  showinfo(\'"), 0xfe10, {.d_s = veb__filter(mess)}}, {_SLIT("\');\n  Chart.defaults.borderColor = \'rgba(0, 0, 0, 0.5)\';\n  Chart.defaults.color = \'rgb(255, 255, 255)\';\n</script>\n\n<!-- \n    - UI\351\223\276\346\216\245\n  -->\n<script type=\"module\" src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.esm.js\"></script>\n<script nomodule src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.js\"></script>\n\n<\n<main>\n"), 0, { .d_c = 0 }}})));
			for (int _t2 = 0; _t2 < list_of_type.len; ++_t2) {
				sql_db__Type list = ((sql_db__Type*)list_of_type.data)[_t2];
				strings__Builder_write_string(&sb_challenge9492, str_intp(2, _MOV((StrIntpData[]){{_SLIT("  <h1 class=\"type-text\">"), 0xfe10, {.d_s = veb__filter(list.name)}}, {_SLIT("</h1>\n  <div class=\"tools-card\">\n"), 0, { .d_c = 0 }}})));
				for (int _t3 = 0; _t3 < list.type_text.len; ++_t3) {
					sql_db__Task challenge = ((sql_db__Task*)list.type_text.data)[_t3];
					strings__Builder_write_string(&sb_challenge9492, str_intp(13, _MOV((StrIntpData[]){{_SLIT("    <!--your challenge-->\n    <div class=\"card\">\n      <div class=\"card-border-top\">\n        <p class=\"score\">"), 0xfe07, {.d_i32 = challenge.score}}, {_SLIT("</p>\n        <span>"), 0xfe10, {.d_s = veb__filter(challenge.name)}}, {_SLIT("</span>\n        <p class=\"job\">"), 0xfe10, {.d_s = veb__filter(challenge.diff)}}, {_SLIT("</p>\n        <button onclick=\'showModal(\""), 0xfe10, {.d_s = veb__filter(challenge.name)}}, {_SLIT("\")\'>\n          <img src=\""), 0xfe10, {.d_s = veb__filter((*(sql_db__PersonalFlag*)array_get(challenge.challenge, (int)(c_pid - 1))).complete)}}, {_SLIT("\">\n        </button>\n      </div>\n    </div>\n    <!-- \346\250\241\346\200\201\346\241\206\346\234\254\350\272\253 -->\n    <div id=\""), 0xfe10, {.d_s = veb__filter(challenge.name)}}, {_SLIT("\" class=\"modal\">\n      <!-- \346\250\241\346\200\201\346\241\206\345\206\205\345\256\271 -->\n      <div class=\"modal-content\">\n        <span class=\"close\" onclick=\"closeModal()\">&times;</span>\n        <div class=\"form\">\n          <h1 id=\"name\">"), 0xfe10, {.d_s = veb__filter(challenge.name)}}, {_SLIT("</h1>\n          <h4>"), 0xfe10, {.d_s = veb__filter(challenge.diff)}}, {_SLIT(" "), 0xfe07, {.d_i32 = challenge.score}}, {_SLIT("</h4>\n          <a class=\"intro\">"), 0xfe10, {.d_s = veb__filter(challenge.intro)}}, {_SLIT("</a>\n          <div class=\"inputBox\"><input id=\""), 0xfe07, {.d_i32 = challenge.tid}}, {_SLIT("\" type=\"text\" placeholder=\"\350\257\267\350\276\223\345\205\245flag\"></div>\n          <div class=\"inputBox\"><a onclick=\"inputflag(\'"), 0xfe10, {.d_s = veb__filter(int_str(challenge.tid))}}, {_SLIT("\')\">\346\217\220\344\272\244</a></div>\n\n        </div>\n      </div>\n    </div>\n"), 0, { .d_c = 0 }}})));
				}
				strings__Builder_write_string(&sb_challenge9492, _SLIT("  </div>\n"));
			}
			strings__Builder_write_string(&sb_challenge9492, _SLIT("</main>\n\n<script>\n  // \346\230\276\347\244\272\346\250\241\346\200\201\346\241\206\347\232\204\345\207\275\346\225\260\n  var modal;\n\n  function showModal(name) {\n    myModal = document.getElementById(name);\n    myModal.style.display = \"block\";\n    modal = myModal;\n  }\n\n  // \345\205\263\351\227\255\346\250\241\346\200\201\346\241\206\347\232\204\345\207\275\346\225\260\n  function closeModal() {\n    modal.style.display = \"none\";\n  }\n\n  // \347\233\221\345\220\254\347\252\227\345\217\243\347\202\271\345\207\273\344\272\213\344\273\266\357\274\214\345\246\202\346\236\234\347\202\271\345\207\273\344\272\206\346\250\241\346\200\201\346\241\206\344\273\245\345\244\226\347\232\204\345\214\272\345\237\237\357\274\214\345\210\231\345\205\263\351\227\255\346\250\241\346\200\201\346\241\206\n  window.onclick = function (event) {\n    if (event.target == modal) {\n      closeModal();\n    }\n  }\n\n  // \344\275\277\344\273\213\347\273\215\344\277\235\346\214\201\346\215\242\350\241\214.\n  function set_a_text() {\n    var a_text = document.getElementsByClassName(\'intro\');\n    for (var i = 0; i < a_text.length; i++) {\n      a_text[i].innerHTML = a_text[i].innerHTML.replace(/\\n/g, \'<br>\');\n    }\n  }\n\n  set_a_text()\n\n</script>\n\n<style>\n  main {\n    /*background: var(--bg-card-color);*/\n    padding: 5px;\n    padding-bottom: 45px;\n    position: absolute;\n    top: 90px;\n    left: 0px;\n    right: 0px;\n    margin: auto;\n    border-radius: 10px;\n  }\n\n  .type-text {\n    margin: auto;\n    padding: 15px;\n    color: var(--text-wild-blue-yonder);\n  }\n\n  /* \345\205\263\351\227\255\346\214\211\351\222\256\346\240\267\345\274\217 */\n  .close {\n    color: #aaa;\n    float: right;\n    font-size: 28px;\n    font-weight: bold;\n    cursor: pointer;\n  }\n\n  .close:hover,\n  .close:focus {\n    color: black;\n    text-decoration: none;\n    cursor: pointer;\n  }\n\n  /*\n    ========================\346\250\241\346\200\201\346\241\206=====================\n*/\n  .modal {\n    display: none;\n    /* \351\273\230\350\256\244\351\232\220\350\227\217 */\n    position: fixed;\n    /* \345\233\272\345\256\232\345\234\250\350\247\206\345\217\243 */\n    z-index: 1;\n    /* \347\275\256\344\272\216\351\241\266\345\261\202 */\n    left: 0;\n    top: 0;\n    width: 100%;\n    /* \345\256\275\345\272\246\345\205\250\345\261\217 */\n    height: 100%;\n    /* \351\253\230\345\272\246\345\205\250\345\261\217 */\n    overflow: auto;\n    /* \345\205\201\350\256\270\346\273\232\345\212\250 */\n    background-color: rgba(0, 0, 0, 0.4);\n    /* \351\273\221\350\211\262\350\203\214\346\231\257\357\274\214\345\215\212\351\200\217\346\230\216 */\n  }\n\n  /* \346\250\241\346\200\201\346\241\206\345\206\205\345\256\271\346\240\267\345\274\217 */\n  .modal-content {\n    background-color: var(--bg-card-color);\n    margin: 15% auto;\n    /* 15% \345\236\202\347\233\264\344\275\215\347\275\256\357\274\214\346\260\264\345\271\263\345\261\205\344\270\255 */\n    padding: 20px;\n    border: 3px solid var(--bg-background-color);\n    width: 80%;\n    /* \346\210\226\346\214\207\345\256\232\345\256\275\345\272\246 */\n    max-width: 1000px;\n    border-radius: 10px;\n    color: var(--text-botton-white);\n  }\n\n  /* \350\276\223\345\205\245\346\241\206\346\240\267\345\274\217 */\n  .form .inputBox {\n    width: 100%;\n    margin-top: 20px;\n  }\n\n  .form .inputBox input {\n    width: 100%;\n    padding: 10px 20px;\n    background: rgba(255, 255, 255, 0.2);\n    outline: none;\n    border: none;\n    border-radius: 5px;\n    border: 1px solid rgba(255, 255, 255, 0.5);\n    border-right: 1px solid rgba(255, 255, 255, 0.2);\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n    font-size: 16px;\n    letter-spacing: 1px;\n    color: var(--text-botton-white);\n  }\n\n  .form .inputBox input::placeholder {\n    color: var(--text-botton-white);\n  }\n\n  /* \347\231\273\345\275\225\346\214\211\351\222\256\346\240\267\345\274\217 */\n\n  .form .inputBox a {\n    text-align: center;\n    background: var(--bg-botton-white);\n    color: var(--text-wild-blue-yonder);\n    max-width: 80px;\n    padding: 10px;\n    font-weight: 600;\n    border-radius: 10px;\n    cursor: pointer;\n  }\n\n  /*\n    ========================\347\250\213\345\272\217\350\216\267\345\217\226\351\203\250\345\210\206=====================\n*/\n  .tools-card {\n    border: 0px dashed;\n    display: grid;\n    grid-gap: 15px;\n    grid-template-columns: repeat(auto-fill, 200px);\n    justify-content: center;\n  }\n\n  .card {\n    width: 200px;\n    height: 100px;\n    background-image: var(--tools-card-color);\n    border: none;\n    border-radius: 10px;\n    padding-top: 10px;\n    position: relative;\n    margin: auto;\n    font-family: inherit;\n  }\n\n  .card span {\n    font-weight: 600;\n    color: var(--text-table-color);\n    text-align: center;\n    display: block;\n    padding-top: 5px;\n    font-size: 1.3em;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n\n  .card .score {\n    font-weight: 400;\n    color: var(--text-title-color);\n    display: block;\n    text-align: left;\n    padding-left: 10px;\n    font-size: 15px;\n  }\n\n  .card .job {\n    font-weight: 400;\n    color: var(--text-title-color);\n    display: block;\n    text-align: right;\n    padding-right: 10px;\n    padding-top: 15px;\n    font-size: 15px;\n  }\n\n  .card img {\n    max-width: 80px;\n    max-height: 80px;\n  }\n\n  .card button {\n    width: 200px;\n    height: 100px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    position: absolute;\n    top: 50%;\n    /* Center vertically */\n    left: 50%;\n    /* Center horizontally */\n    transform: translate(-50%, -50%);\n    /* Move the button to the exact center */\n\n    border-radius: 8px;\n    border: none;\n  }\n\n  .card button:hover {\n    background: var(--button-hover);\n    color: var(--button-hover-text);\n  }\n</style>\n</body>\n</html>\n"));
			string _tmpl_res_challenge9492 = strings__Builder_str(&sb_challenge9492);
		veb__Context_html(ctx, _tmpl_res_challenge9492);
		strings__Builder_free(&sb_challenge9492);
		string_free(&_tmpl_res_challenge9492);
		;
	} else {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("id"),.value = _SLIT(""),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_redirect(&ctx->Context, _SLIT("/error.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
	}
	return (veb__Result){0};
}
VV_LOCAL_SYMBOL veb__Result main__App_flagapi(main__App* app, main__Context* ctx) {
	string the_cookie_id = main__cookie_id(*ctx);
	string c_id = main__cookie_id(*ctx);
	string c_pwd = main__cookie_passwd(*ctx);
	sql_db__StatusReturn login = sql_db__login_status(app->db, c_id, c_pwd);
	if ((the_cookie_id).len == 0) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \350\257\267\347\231\273\345\275\225\345\220\216\346\217\220\344\272\244flag")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_text(&ctx->Context, _SLIT("401: Please login first."));
	} else if (login.return_bool) {
		string flag = encoding__base64__url_decode_str((*(string*)map_get(ADDR(map, ctx->Context.form), &(string[]){_SLIT("flag")}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
		int tid = string_int(encoding__base64__url_decode_str((*(string*)map_get(ADDR(map, ctx->Context.form), &(string[]){_SLIT("tid")}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }))));
		if (sql_db__post_flag(app->db, veb__Context_ip(&ctx->Context), tid, flag, (*(sql_db__Personal*)array_first(login.id_check)).pid)) {
			veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("\346\217\220\344\272\244\346\210\220\345\212\237")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
			return veb__Context_text(&ctx->Context, _SLIT("200: Seccess."));
		}
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \346\217\220\344\272\244\345\244\261\350\264\245")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_text(&ctx->Context, _SLIT("403: Wrong."));
	} else {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \350\264\246\346\210\267\345\255\230\345\234\250\351\227\256\351\242\230")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_text(&ctx->Context, _SLIT("401: Please login first."));
	}
	return (veb__Result){0};
}
VV_LOCAL_SYMBOL veb__Result main__App_team(main__App* app, main__Context* ctx) {
	string mess = main__cookie_mess(ctx);
		strings__Builder sb_team11165 = strings__new_builder(4170);
		strings__Builder_write_string(&sb_team11165, str_intp(2, _MOV((StrIntpData[]){{_SLIT("<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=firefox\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <!-- \n    - \345\244\264\351\203\250tag\n  -->\n  <title>\347\254\254\344\272\214\345\261\212VYCTF\346\226\260\347\224\237\350\265\233</title>\n  <meta name=\"title\" content=\"VTF Copyleft \302\2512024 VYCMa Open Source China\">\n  <meta name=\"description\" content=\"CTF competition platform by vlang\">\n\n  <!-- \n    - \345\244\264\351\203\250\346\240\207\347\255\276\n  -->\n  <link rel=\"shortcut icon\" href=\"../image/sakana.png\" type=\"/image/svg+xml\">\n\n  <!-- \n    - \345\274\225\345\205\245css\346\226\207\344\273\266\n  -->\n  <link rel=\"stylesheet\" href=\"../css/style.css\">\n\n</head>\n\n<body id=\"top\">\n<header class=\"header\" data-header>\n  <div class=\"container\">\n\n    <a href=\"/\" class=\"logo\">\n      <img src=\"../image/vtf-logo.svg\" width=\"40\" alt=\"vtf-logo\">\n    </a>\n\n    <nav class=\"navbar\" data-navbar>\n\n      <div class=\"navbar-top\">\n        <a href=\"/\" class=\"logo\">\n          <img src=\"../image/vtf-logo.svg\" width=\"80\" alt=\"vtf-logo\">\n        </a>\n\n        <button class=\"nav-close-btn\" aria-label=\"close menu\" data-nav-toggler>\n          <ion-icon name=\"close-outline\" aria-hidden=\"true\"></ion-icon>\n        </button>\n      </div>\n\n      <ul class=\"navbar-list\">\n        <li>\n          <a href=\"console.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\247\345\210\266\345\217\260</a>\n        </li>\n        <li>\n          <a href=\"notice.html\" class=\"navbar-link hover-1\" data-nav-toggler>\345\221\212\347\244\272</a>\n        </li>\n\n        <li>\n          <a href=\"challenge.html\" class=\"navbar-link hover-1\" data-nav-toggler>\351\242\230\347\233\256</a>\n        </li>\n\n        <li>\n          <a href=\"ranking.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\222\345\220\215</a>\n        </li>\n\n        <li>\n          <a id=\"navbar4\" href=\"team.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\210\230\351\230\237</a>\n        </li>\n\n        <li>\n          <a id=\"navbar5\" href=\"member.html\" class=\"navbar-link hover-1\" data-nav-toggler>\344\270\252\344\272\272</a>\n        </li>\n\n      </ul>\n\n      <p class=\"navbar-bottom\">\n        <img src=\"../image/VYCMa.webp\" width=\"180\" alt=\"VYCMa\">\n      </p>\n\n      <p class=\"copyright-text\">\n        vtf platform copyleft \302\2512024 VYOSC.<br>\n        Open source follows the VY General License.<br>\n        vtf\346\257\224\350\265\233\345\271\263\345\217\260\347\224\261\302\2512024 VY\345\274\200\346\272\220\344\270\255\345\233\275 \345\274\200\346\272\220.<br>\n        \345\274\200\346\272\220\345\215\217\350\256\256\351\201\265\345\276\252VY\351\200\232\347\224\250\350\256\270\345\217\257\350\257\201.\n      </p>\n\n    </nav>\n\n    <button class=\"nav-open-btn\" aria-label=\"open menu\" data-nav-toggler>\n      <ion-icon name=\"menu-outline\" aria-hidden=\"true\"></ion-icon>\n    </button>\n\n  </div>\n</header>\n\n<!-- \n    - \345\257\274\345\205\245js\n  -->\n<script src=\"../js/script.js\"></script>\n<script src=\"../js/console.js\"></script>\n<script src=\"../js/rank.js\"></script>\n<script src=\"../js/mychart.js\"></script>\n\n<!--\n    - \345\217\257\350\247\206\345\214\226\347\225\214\351\235\242\n-->\n<script src=\"../js/node_modules/chart.js/dist/chart.umd.js\"></script>\n\n<script>\n  showinfo(\'"), 0xfe10, {.d_s = veb__filter(mess)}}, {_SLIT("\');\n  Chart.defaults.borderColor = \'rgba(0, 0, 0, 0.5)\';\n  Chart.defaults.color = \'rgb(255, 255, 255)\';\n</script>\n\n<!-- \n    - UI\351\223\276\346\216\245\n  -->\n<script type=\"module\" src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.esm.js\"></script>\n<script nomodule src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.js\"></script>\n\n<\n<main>\n  <img src=\"../image/404.webp\" width=\"240\" alt=\"404\">\n  <a class=\"section-text\">\345\211\215\351\235\242\347\232\204\345\214\272\345\237\237\344\273\245\345\220\216\345\206\215\346\235\245\346\216\242\347\264\242\345\220\247</a>\n</main>\n\n<style>\nmain{\n  background: rgba(255, 255, 255, 0);\n  width: 280px;\n  padding: 20px;\n  position: absolute;\n  top: 20%;\n  left: 0;\n  right:0;\n  margin: auto;\n}\n</style>\n\n\n</body>\n</html>\n"), 0, { .d_c = 0 }}})));
		string _tmpl_res_team11165 = strings__Builder_str(&sb_team11165);
	veb__Context_html(ctx, _tmpl_res_team11165);
	strings__Builder_free(&sb_team11165);
	string_free(&_tmpl_res_team11165);
	;
}
VV_LOCAL_SYMBOL veb__Result main__App_ranking(main__App* app, main__Context* ctx) {
	string mess = main__cookie_mess(ctx);
	Array_sql_db__Task challenge_name = sql_db__find_challenge(app->db);
		strings__Builder sb_ranking11390 = strings__new_builder(8340);
		strings__Builder_write_string(&sb_ranking11390, str_intp(2, _MOV((StrIntpData[]){{_SLIT("<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=firefox\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <!-- \n    - \345\244\264\351\203\250tag\n  -->\n  <title>\347\254\254\344\272\214\345\261\212VYCTF\346\226\260\347\224\237\350\265\233</title>\n  <meta name=\"title\" content=\"VTF Copyleft \302\2512024 VYCMa Open Source China\">\n  <meta name=\"description\" content=\"CTF competition platform by vlang\">\n\n  <!-- \n    - \345\244\264\351\203\250\346\240\207\347\255\276\n  -->\n  <link rel=\"shortcut icon\" href=\"../image/sakana.png\" type=\"/image/svg+xml\">\n\n  <!-- \n    - \345\274\225\345\205\245css\346\226\207\344\273\266\n  -->\n  <link rel=\"stylesheet\" href=\"../css/style.css\">\n\n</head>\n\n<body id=\"top\">\n<header class=\"header\" data-header>\n  <div class=\"container\">\n\n    <a href=\"/\" class=\"logo\">\n      <img src=\"../image/vtf-logo.svg\" width=\"40\" alt=\"vtf-logo\">\n    </a>\n\n    <nav class=\"navbar\" data-navbar>\n\n      <div class=\"navbar-top\">\n        <a href=\"/\" class=\"logo\">\n          <img src=\"../image/vtf-logo.svg\" width=\"80\" alt=\"vtf-logo\">\n        </a>\n\n        <button class=\"nav-close-btn\" aria-label=\"close menu\" data-nav-toggler>\n          <ion-icon name=\"close-outline\" aria-hidden=\"true\"></ion-icon>\n        </button>\n      </div>\n\n      <ul class=\"navbar-list\">\n        <li>\n          <a href=\"console.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\247\345\210\266\345\217\260</a>\n        </li>\n        <li>\n          <a href=\"notice.html\" class=\"navbar-link hover-1\" data-nav-toggler>\345\221\212\347\244\272</a>\n        </li>\n\n        <li>\n          <a href=\"challenge.html\" class=\"navbar-link hover-1\" data-nav-toggler>\351\242\230\347\233\256</a>\n        </li>\n\n        <li>\n          <a href=\"ranking.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\222\345\220\215</a>\n        </li>\n\n        <li>\n          <a id=\"navbar4\" href=\"team.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\210\230\351\230\237</a>\n        </li>\n\n        <li>\n          <a id=\"navbar5\" href=\"member.html\" class=\"navbar-link hover-1\" data-nav-toggler>\344\270\252\344\272\272</a>\n        </li>\n\n      </ul>\n\n      <p class=\"navbar-bottom\">\n        <img src=\"../image/VYCMa.webp\" width=\"180\" alt=\"VYCMa\">\n      </p>\n\n      <p class=\"copyright-text\">\n        vtf platform copyleft \302\2512024 VYOSC.<br>\n        Open source follows the VY General License.<br>\n        vtf\346\257\224\350\265\233\345\271\263\345\217\260\347\224\261\302\2512024 VY\345\274\200\346\272\220\344\270\255\345\233\275 \345\274\200\346\272\220.<br>\n        \345\274\200\346\272\220\345\215\217\350\256\256\351\201\265\345\276\252VY\351\200\232\347\224\250\350\256\270\345\217\257\350\257\201.\n      </p>\n\n    </nav>\n\n    <button class=\"nav-open-btn\" aria-label=\"open menu\" data-nav-toggler>\n      <ion-icon name=\"menu-outline\" aria-hidden=\"true\"></ion-icon>\n    </button>\n\n  </div>\n</header>\n\n<!-- \n    - \345\257\274\345\205\245js\n  -->\n<script src=\"../js/script.js\"></script>\n<script src=\"../js/console.js\"></script>\n<script src=\"../js/rank.js\"></script>\n<script src=\"../js/mychart.js\"></script>\n\n<!--\n    - \345\217\257\350\247\206\345\214\226\347\225\214\351\235\242\n-->\n<script src=\"../js/node_modules/chart.js/dist/chart.umd.js\"></script>\n\n<script>\n  showinfo(\'"), 0xfe10, {.d_s = veb__filter(mess)}}, {_SLIT("\');\n  Chart.defaults.borderColor = \'rgba(0, 0, 0, 0.5)\';\n  Chart.defaults.color = \'rgb(255, 255, 255)\';\n</script>\n\n<!-- \n    - UI\351\223\276\346\216\245\n  -->\n<script type=\"module\" src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.esm.js\"></script>\n<script nomodule src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.js\"></script>\n\n<\n<main>\n\n  <div class=\"layer-box\">\n    <h1>\346\216\222\350\241\214\346\246\234</h1>\n    <canvas id=\"myChart\"></canvas>\n    <div class=\"layer\">\n      <table>\n        <tr>\n          <th>\346\216\222\345\220\215</th>\n          <th>\351\200\211\346\211\213\345\220\215\347\247\260</th>\n          <th>\351\200\211\346\211\213\345\276\227\345\210\206</th>\n"), 0, { .d_c = 0 }}})));
		for (int _t1 = 0; _t1 < challenge_name.len; ++_t1) {
			sql_db__Task challenge = ((sql_db__Task*)challenge_name.data)[_t1];
			strings__Builder_write_string(&sb_ranking11390, str_intp(2, _MOV((StrIntpData[]){{_SLIT("          <th>"), 0xfe10, {.d_s = veb__filter(challenge.name)}}, {_SLIT("</th>\n"), 0, { .d_c = 0 }}})));
		}
		strings__Builder_write_string(&sb_ranking11390, _SLIT("        </tr>\n        <tbody>\n"));
		for (int i = 0; i < 10; ++i) {
			strings__Builder_write_string(&sb_ranking11390, str_intp(4, _MOV((StrIntpData[]){{_SLIT("          <tr>\n            <td id=\"td"), 0xfe07, {.d_i32 = i}}, {_SLIT("_rank\"></td>\n            <td id=\"td"), 0xfe07, {.d_i32 = i}}, {_SLIT("_team_id\"></td>\n            <td id=\"td"), 0xfe07, {.d_i32 = i}}, {_SLIT("_score\"></td>\n"), 0, { .d_c = 0 }}})));
			for (int j = 0; j < challenge_name.len; ++j) {
				strings__Builder_write_string(&sb_ranking11390, str_intp(3, _MOV((StrIntpData[]){{_SLIT("            <td id=\"td"), 0xfe07, {.d_i32 = i}}, {_SLIT("_"), 0xfe07, {.d_i32 = j}}, {_SLIT("\"></td>\n"), 0, { .d_c = 0 }}})));
			}
			strings__Builder_write_string(&sb_ranking11390, _SLIT("          </tr>\n"));
		}
		strings__Builder_write_string(&sb_ranking11390, _SLIT("        </tbody>\n\n      </table>\n    </div>\n    <div class=\"center\">\n      <ul id=\"page\" class=\"pagination\">\n        <li id=\"set_page\"><a class=\"\" onclick=\"alert(1);\" href=\"#\">\302\253</a></li>\n      </ul>\n    </div>\n  </div>\n\n  <style>\n    .layer-box {\n      background: var(--bg-card-color);\n      width: 70%;\n      max-width: 1200px;\n      position: absolute;\n      top: 15%;\n      left: 0;\n      right: 0;\n      margin: auto;\n      border-radius: 10px;\n      border-width: 10px;\n    }\n\n    .layer-box h1 {\n      top: 10px;\n      text-align: center;\n      position: relative;\n      color: var(--text-botton-white);\n      font-size: 24px;\n      font-weight: 600;\n      letter-spacing: 5px;\n      margin-bottom: 30px;\n      cursor: pointer;\n    }\n\n    body {\n      padding: 100px;\n      box-sizing: border-box;\n    }\n\n    table {\n      border-collapse: collapse;\n    }\n\n    td,\n    th {\n      text-align: center;\n      color: var(--text-botton-white);\n      font-size: 14px;\n      border-right: 1px solid var(--bg-card-color);\n      line-height: 30px;\n      box-sizing: border-box;\n      white-space: nowrap;\n      /*overflow: hidden; \351\232\220\350\227\217\350\266\205\345\207\272\345\256\271\345\231\250\347\232\204\345\206\205\345\256\271 */\n      /*text-overflow: ellipsis; \344\275\277\347\224\250\347\234\201\347\225\245\345\217\267\350\241\250\347\244\272\350\242\253\346\210\252\346\226\255\347\232\204\346\226\207\346\234\254 */\n      background: var(--bg-background-color);\n    }\n\n    .layer-box .layer {\n      overflow: hidden;\n      overflow-x: scroll;\n      /*text-align: center;*/\n    }\n\n    /* \351\200\211\351\241\265\346\240\207 */\n    table tr:nth-child(odd) td,\n    table tr:nth-child(odd) th {\n      background: var(--bg-oxford-blue-2);\n    }\n\n    .td-1 {\n      position: absolute;\n      left: 0;\n      z-index: 2;\n      width: 150px;\n      background: var(--bg-page-now);\n    }\n\n    .zhanwei {\n      width: 149px;\n    }\n\n    /* \345\210\206\351\241\265\347\254\246 */\n\n    ul.pagination {\n      display: inline-block;\n      margin: 0;\n    }\n\n    ul.pagination li {\n      display: inline;\n    }\n\n    ul.pagination li a {\n      color: var(--text-botton-white);\n      float: left;\n      padding: 7px 10px;\n      text-decoration: none;\n    }\n\n    ul.pagination li a.active {\n      background-color: var(--bg-page-now);\n      color: var(--text-page-now);\n    }\n\n    ul.pagination li a:hover:not(.active) {\n      background-color: var(--bg-page-color);\n    }\n\n    ul.pagination li a {\n      border-radius: 5px;\n    }\n\n    ul.pagination li a.active {\n      border-radius: 5px;\n    }\n\n    div.center {\n      text-align: center;\n    }\n  </style>\n\n  <script>\n    // \350\216\267\345\217\226\345\233\276\350\241\250\345\256\271\345\231\250\n    var canvas = document.getElementById(\'myChart\')\n    ranking_line(canvas);\n\n    Rankapi(1);\n  </script>\n</main>\n</body>\n</html>\n"));
		string _tmpl_res_ranking11390 = strings__Builder_str(&sb_ranking11390);
	veb__Context_html(ctx, _tmpl_res_ranking11390);
	strings__Builder_free(&sb_ranking11390);
	string_free(&_tmpl_res_ranking11390);
	;
}
VV_LOCAL_SYMBOL veb__Result main__App_rankapi(main__App* app, main__Context* ctx) {
	Array_main__Rank data = __new_array_with_default(0, 0, sizeof(main__Rank), 0);
	Array_sql_db__Personal _t1 = sql_db__get_personal(app->db);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		sql_db__Personal i = ((sql_db__Personal*)_t1.data)[_t2];
		Array_bool delta = __new_array_with_default_noscan(0, 0, sizeof(bool), 0);
		int score = 0;
		for (int _t3 = 0; _t3 < i.challenge.len; ++_t3) {
			sql_db__PersonalFlag j = ((sql_db__PersonalFlag*)i.challenge.data)[_t3];
			if (sql_db__bool_solve(j)) {
				array_push_noscan((array*)&delta, _MOV((bool[]){ true }));
				score += sql_db__challenge_score(app->db, j);
			} else {
				array_push_noscan((array*)&delta, _MOV((bool[]){ false }));
			}
		}
		array_push((array*)&data, _MOV((main__Rank[]){ ((main__Rank){.team_id = encoding__base64__url_decode_str(i.id),.score = score,.challenge = delta,}) }));
	}
	// json.encode
	cJSON* _t8 = json__encode_Array_main__Rank(data);
	string _t9 = json__json_print(_t8);
	cJSON_Delete(_t8); // del
	return veb__Context_text(&ctx->Context, (_t9));
}
VV_LOCAL_SYMBOL veb__Result main__App_notice(main__App* app, main__Context* ctx) {
	return veb__Context_redirect(&ctx->Context, _SLIT("/team.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
}
VV_LOCAL_SYMBOL veb__Result main__App_console(main__App* app, main__Context* ctx) {
	string mess = main__cookie_mess(ctx);
	string c_id = main__cookie_id(*ctx);
	string c_pwd = main__cookie_passwd(*ctx);
	sql_db__StatusReturn login = sql_db__login_root_status(app->db, c_id, c_pwd);
	if ((c_id).len == 0) {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("mess"),.value = encoding__base64__url_encode_str(_SLIT("Error: \350\257\267\347\231\273\345\275\225\345\220\216\346\237\245\347\234\213")),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_redirect(&ctx->Context, _SLIT("/login.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
	} else if (login.return_bool) {
			strings__Builder sb_console12590 = strings__new_builder(10230);
			strings__Builder_write_string(&sb_console12590, str_intp(2, _MOV((StrIntpData[]){{_SLIT("<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=firefox\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <!-- \n    - \345\244\264\351\203\250tag\n  -->\n  <title>\347\254\254\344\272\214\345\261\212VYCTF\346\226\260\347\224\237\350\265\233</title>\n  <meta name=\"title\" content=\"VTF Copyleft \302\2512024 VYCMa Open Source China\">\n  <meta name=\"description\" content=\"CTF competition platform by vlang\">\n\n  <!-- \n    - \345\244\264\351\203\250\346\240\207\347\255\276\n  -->\n  <link rel=\"shortcut icon\" href=\"../image/sakana.png\" type=\"/image/svg+xml\">\n\n  <!-- \n    - \345\274\225\345\205\245css\346\226\207\344\273\266\n  -->\n  <link rel=\"stylesheet\" href=\"../css/style.css\">\n\n</head>\n\n<body id=\"top\">\n<header class=\"header\" data-header>\n  <div class=\"container\">\n\n    <a href=\"/\" class=\"logo\">\n      <img src=\"../image/vtf-logo.svg\" width=\"40\" alt=\"vtf-logo\">\n    </a>\n\n    <nav class=\"navbar\" data-navbar>\n\n      <div class=\"navbar-top\">\n        <a href=\"/\" class=\"logo\">\n          <img src=\"../image/vtf-logo.svg\" width=\"80\" alt=\"vtf-logo\">\n        </a>\n\n        <button class=\"nav-close-btn\" aria-label=\"close menu\" data-nav-toggler>\n          <ion-icon name=\"close-outline\" aria-hidden=\"true\"></ion-icon>\n        </button>\n      </div>\n\n      <ul class=\"navbar-list\">\n        <li>\n          <a href=\"console.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\247\345\210\266\345\217\260</a>\n        </li>\n        <li>\n          <a href=\"notice.html\" class=\"navbar-link hover-1\" data-nav-toggler>\345\221\212\347\244\272</a>\n        </li>\n\n        <li>\n          <a href=\"challenge.html\" class=\"navbar-link hover-1\" data-nav-toggler>\351\242\230\347\233\256</a>\n        </li>\n\n        <li>\n          <a href=\"ranking.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\216\222\345\220\215</a>\n        </li>\n\n        <li>\n          <a id=\"navbar4\" href=\"team.html\" class=\"navbar-link hover-1\" data-nav-toggler>\346\210\230\351\230\237</a>\n        </li>\n\n        <li>\n          <a id=\"navbar5\" href=\"member.html\" class=\"navbar-link hover-1\" data-nav-toggler>\344\270\252\344\272\272</a>\n        </li>\n\n      </ul>\n\n      <p class=\"navbar-bottom\">\n        <img src=\"../image/VYCMa.webp\" width=\"180\" alt=\"VYCMa\">\n      </p>\n\n      <p class=\"copyright-text\">\n        vtf platform copyleft \302\2512024 VYOSC.<br>\n        Open source follows the VY General License.<br>\n        vtf\346\257\224\350\265\233\345\271\263\345\217\260\347\224\261\302\2512024 VY\345\274\200\346\272\220\344\270\255\345\233\275 \345\274\200\346\272\220.<br>\n        \345\274\200\346\272\220\345\215\217\350\256\256\351\201\265\345\276\252VY\351\200\232\347\224\250\350\256\270\345\217\257\350\257\201.\n      </p>\n\n    </nav>\n\n    <button class=\"nav-open-btn\" aria-label=\"open menu\" data-nav-toggler>\n      <ion-icon name=\"menu-outline\" aria-hidden=\"true\"></ion-icon>\n    </button>\n\n  </div>\n</header>\n\n<!-- \n    - \345\257\274\345\205\245js\n  -->\n<script src=\"../js/script.js\"></script>\n<script src=\"../js/console.js\"></script>\n<script src=\"../js/rank.js\"></script>\n<script src=\"../js/mychart.js\"></script>\n\n<!--\n    - \345\217\257\350\247\206\345\214\226\347\225\214\351\235\242\n-->\n<script src=\"../js/node_modules/chart.js/dist/chart.umd.js\"></script>\n\n<script>\n  showinfo(\'"), 0xfe10, {.d_s = veb__filter(mess)}}, {_SLIT("\');\n  Chart.defaults.borderColor = \'rgba(0, 0, 0, 0.5)\';\n  Chart.defaults.color = \'rgb(255, 255, 255)\';\n</script>\n\n<!-- \n    - UI\351\223\276\346\216\245\n  -->\n<script type=\"module\" src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.esm.js\"></script>\n<script nomodule src=\"../js/node_modules/ionicons/dist/ionicons/ionicons.js\"></script>\n\n<\n<main>\n  <link rel=\"stylesheet\" href=\"../css/console.css\">\n  <div class=\"viewport\">\n    <!-- \344\276\247\350\276\271\346\240\217 -->\n    <div id=\"sidebar\">\n      <ul class=\"nav\">\n        <li>\n          <a href=\"#panel\">\351\235\242\346\235\277</a>\n        </li>\n        <li>\n          <a href=\"#member\">\346\210\220\345\221\230</a>\n        </li>\n        <li>\n          <a href=\"#team\">\351\230\237\344\274\215</a>\n        </li>\n        <li>\n          <a href=\"#challenge\">\351\242\230\347\233\256</a>\n        </li>\n        <li>\n          <a href=\"#data\">\346\225\260\346\215\256</a>\n        </li>\n        <li>\n          <a href=\"#control\">\347\233\221\346\216\247</a>\n        </li>\n      </ul>\n    </div>\n\n    <!-- \345\206\205\345\256\271\345\214\272\345\237\237 -->\n    <div id=\"content\">\n\n      <h1 id=\"panel\">\351\235\242\346\235\277</h1>\n      <div class=\"content-bar\">\n        <h5>\346\257\224\350\265\233\344\277\241\346\201\257:</h5>\n        <div class=\"tools-card\">\n          <div class=\"card\">\n            <canvas id=\"canvas1\"></canvas>\n          </div>\n          <div class=\"card\">\n            <canvas id=\"canvas2\"></canvas>\n          </div>\n        </div>\n\n        <div class=\"set-card\">\n          <h5>\345\271\263\345\217\260\350\256\276\347\275\256:</h5>\n          <div class=\"drop-zone\" id=\"drop-zone\">\n            \346\213\226\345\212\250\345\233\276\347\211\207\345\210\260\350\277\231\351\207\214\344\277\256\346\224\271\346\230\276\347\244\272\345\233\276\346\240\207\n          </div>\n          <input type=\"text\" id=\"title-input\" placeholder=\"\346\226\260\347\232\204\346\240\207\351\242\230\">\n          <a onclick=\"updateTitle()\">\346\233\264\346\226\260</a>\n        </div>\n\n        <h5>\344\270\273\351\241\265\346\250\241\346\235\277:</h5>\n        <textarea id=\"message\" name=\"message\"></textarea>\n        <a onclick=\"updateTitle()\">\346\233\264\346\226\260</a>\n      </div>\n\n      <h1 id=\"member\">\346\210\220\345\221\230</h1>\n      <div class=\"content-bar\">\n        <h5>\346\237\245\350\257\242:</h5>\n        <div class=\"search\">\n          <input type=\"text\" id=\"title-input\" placeholder=\"\345\205\263\351\224\256\350\257\215\">\n          <select id=\"group\" value=\"x\">\n            <option value=\"1\">root</option>\n            <option value=\"2\">member</option>\n            <option value=\"x\">...</option>\n          </select>\n          <input type=\"text\" id=\"title-input\" placeholder=\"\346\226\260\347\232\204\346\240\207\351\242\230\">\n          <a onclick=\"updateTitle()\">\346\237\245\350\257\242</a>\n\n        </div>\n      </div>\n\n      <h1 id=\"team\">\351\230\237\344\274\215</h1>\n      <div class=\"content-bar\">\n\n      </div>\n      <h1 id=\"challenge\">\351\242\230\347\233\256</h1>\n      <div class=\"content-bar\">\n\n      </div>\n\n      <h1 id=\"data\">\346\225\260\346\215\256</h1>\n      <div class=\"content-bar\">\n\n      </div>\n\n      <h1 id=\"control\">\347\233\221\346\216\247</h1>\n      <div class=\"content-bar\">\n\n      </div>\n\n\n    </div>\n  </div>\n</main>\n\n<style>\n  h5 {\n    color: var(--text-set-white);\n  }\n\n  .tools-card {\n    border: 0px dashed;\n    display: grid;\n    grid-gap: 20px;\n    justify-content: center;\n    margin-bottom: 50px;\n  }\n\n  /* \351\273\230\350\256\244\350\256\276\347\275\256\344\270\244\345\210\227 */\n  .tools-card {\n    grid-template-columns: repeat(2, 1fr);\n  }\n\n  .card {\n    margin: 0 auto;\n    height: 200px;\n  }\n\n  .set-card {\n    display: grid;\n    grid-gap: 10px;\n  }\n\n  .drop-zone {\n    border: 2px dashed var(--text-set-white);\n    padding: 30px;\n    color: var(--text-set-white);\n    text-align: center;\n  }\n\n  search {\n    height: 100px;\n    padding: 10px 20px;\n  }\n\n  input {\n    width: 100%;\n    padding: 10px 20px;\n    background: rgba(255, 255, 255, 0.2);\n    outline: none;\n    border: none;\n    border-radius: 5px;\n    border: 1px solid rgba(255, 255, 255, 0.5);\n    border-right: 1px solid rgba(255, 255, 255, 0.2);\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n    font-size: 16px;\n    letter-spacing: 1px;\n    color: var(--text-botton-white);\n  }\n\n  input::placeholder {\n    color: var(--text-botton-white);\n  }\n\n  .content-bar a {\n    text-align: center;\n    margin: 0 auto;\n    background: var(--bg-botton-white);\n    color: var(--text-wild-blue-yonder);\n    width: 80px;\n    padding: 10px;\n    font-weight: 600;\n    border-radius: 10px;\n    cursor: pointer;\n  }\n\n  textarea {\n    width: 100% !important;\n    height: 300px;\n    box-sizing: border-box;\n    background-color: rgba(255, 255, 255, 0.7);\n  }\n\n  .search {\n    display: grid;\n    grid-template-columns: repeat(3, 30%);\n    gap: 1px;\n  }\n\n  @media (max-width: 600px) {\n    .tools-card {\n      grid-template-columns: 1fr;\n      /* \344\270\200\345\210\227\345\270\203\345\261\200 */\n    }\n\n    .search {\n      grid-template-columns: repeat(2, 1fr);\n      /* \344\270\244\345\210\227\345\270\203\345\261\200 */\n    }\n  }\n</style>\n\n<script>\n  var canvas1 = document.getElementById(\'canvas1\');\n  var canvas2 = document.getElementById(\'canvas2\');\n  ranking_doughnut(canvas1);\n  ranking_polararea(canvas2);\n\n  function updateTitle() {\n    alert(1);\n  }\n\n</script>\n\n<script>\n  // \345\271\263\346\273\221\347\247\273\345\212\250\n  document.addEventListener(\'DOMContentLoaded\', function () {\n    var links = document.querySelectorAll(\'#sidebar .nav a\');\n    links.forEach(function (link) {\n      link.addEventListener(\'click\', function (event) {\n        event.preventDefault();\n        var targetId = this.getAttribute(\'href\').substring(1); // \350\216\267\345\217\226id\357\274\214\345\216\273\346\216\211#\n        var targetElement = document.getElementById(targetId);\n        if (targetElement) {\n          targetElement.scrollIntoView({ behavior: \'smooth\' }); // \345\271\263\346\273\221\346\273\232\345\212\250\345\210\260\347\233\256\346\240\207\344\275\215\347\275\256\n        }\n      });\n    });\n  });\n</script>\n</body>\n</html>\n"), 0, { .d_c = 0 }}})));
			string _tmpl_res_console12590 = strings__Builder_str(&sb_console12590);
		veb__Context_html(ctx, _tmpl_res_console12590);
		strings__Builder_free(&sb_console12590);
		string_free(&_tmpl_res_console12590);
		;
	} else {
		veb__Context_set_cookie(&ctx->Context, ((net__http__Cookie){.name = _SLIT("id"),.value = _SLIT(""),.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = ((time__Time){.__v_unix = 0,.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}),.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}));
		return veb__Context_redirect(&ctx->Context, _SLIT("/error.html"), ((veb__RedirectParams){.typ = ((int)(net__http__Status__found)),}));
	}
	return (veb__Result){0};
}
void _vinit(int ___argc, voidptr ___argv) {
#if __STDC_HOSTED__ == 1
	signal(11, v_segmentation_fault_handler);
#endif
	builtin_init();
	_closure_mtx_init();
	// Initializations of consts for module strconv
	_const_strconv__digit_pairs = _SLIT("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_strconv__base_digits = _SLIT("0123456789abcdefghijklmnopqrstuvwxyz");
	// Initializations of consts for module builtin
	_const_digit_pairs = _SLIT("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	g_live_reload_info = *(voidptr*)&((voidptr[]){0}[0]); // global 5
	_const_min_i64 = ((i64)((int_literal)(-9223372036854775807 - 1)));
	_const_max_i64 = ((i64)(9223372036854775807));
	_const_none__ = I_None___to_Interface_IError(((None__*)memdup(&(None__){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(None__))));
	// Initializations of consts for module encoding.base64
	_const_encoding__base64__enc_table = _SLIT("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
	// Initializations of consts for module time
	_const_time__months_string = _SLIT("JanFebMarAprMayJunJulAugSepOctNovDec");
	_const_time__nanosecond = ((time__Duration)(1));
	_const_time__infinite = ((((i64)(9223372036854775807))));
	_const_time__microsecond = ((1000 * _const_time__nanosecond));
	_const_time__millisecond = ((1000 * _const_time__microsecond));
	_const_time__second = ((1000 * _const_time__millisecond));
	_const_time__minute = ((60 * _const_time__second));
	_const_time__hour = ((60 * _const_time__minute));
	// Initializations of consts for module net.urllib
	_const_net__urllib__err_msg_escape = _SLIT("unescape: invalid URL escape");
	// Initializations of consts for module vlog
	_const_vlog__false_log = _SLIT("\033[31m[False] \033[0m");
	_const_vlog__true_log = _SLIT("\033[32m[True] \033[0m");
	_const_vlog__set_log = _SLIT("\033[33m[Setting] \033[0m");
	_const_vlog__warn_log = _SLIT("\033[33m[Warn] \033[0m");
	// Initializations of consts for module picohttpparser
	_const_picohttpparser__token_char_map = _SLIT("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\1\1\1\1\1\0\0\1\1\0\1\1\0\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0\0\0\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\1\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0");
	// Initializations of consts for module orm
	_const_orm__num64 = new_array_from_c_array_noscan(2, 2, sizeof(int), _MOV((int[2]){9, 14}));
	_const_orm__nums = new_array_from_c_array_noscan(7, 7, sizeof(int), _MOV((int[7]){5, 6, 8, 11, 12, 13, 19}));
	_const_orm__float = new_array_from_c_array_noscan(2, 2, sizeof(int), _MOV((int[2]){16, 17}));
{
	_const_orm__type_string = 21;
}
{
	_const_orm__type_idx = new_map_init_noscan_value(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 12, sizeof(string), sizeof(int),
	_MOV((string[12]){
		_SLIT("i8"),
		_SLIT("i16"),
		_SLIT("int"),
		_SLIT("i64"),
		_SLIT("u8"),
		_SLIT("u16"),
		_SLIT("u32"),
		_SLIT("u64"),
		_SLIT("f32"),
		_SLIT("f64"),
		_SLIT("bool"),
		_SLIT("string"),
	}),
	_MOV((int[12]){
		5, 
		6, 
		8, 
		9, 
		11, 
		12, 
		13, 
		14, 
		16, 
		17, 
		19, 
		21, 
	})
)
;
}
	_const_orm__null_primitive = orm__Null_to_sumtype_orm__Primitive(ADDR(orm__Null, (((orm__Null){EMPTY_STRUCT_INITIALIZATION}))));
	// Initializations of consts for module os
	_const_os__path_separator = _SLIT("/");
	_const_os__args = arguments();
	// Initializations of consts for module encoding.html
	_const_encoding__html__escape_seq = new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("&"), _SLIT("&amp;"), _SLIT("<"), _SLIT("&lt;"), _SLIT(">"), _SLIT("&gt;")}));
	_const_encoding__html__escape_quote_seq = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("\""), _SLIT("&#34;"), _SLIT("'"), _SLIT("&#39;")}));
	// Initializations of consts for module crypto.sha256
	_const_crypto__sha256___k = new_array_from_c_array_noscan(64, 64, sizeof(int), _MOV((int[64]){
		0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98,
		0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1,
		0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
		0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85,
		0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1,
		0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116,
		0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee,
		0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2}));
	// Initializations of consts for module sql_db
	_const_sql_db__solved = _SLIT("../image/complete.webp");
	_const_sql_db__unsolved = _SLIT("../image/incomplete.png");
	// Initializations of consts for module rand
	default_rng = *(rand__PRNG**)&((rand__PRNG*[]){0}[0]); // global 5
	// Calling fn init() for module rand
	rand__init();
	// Initializations of consts for module net
{
	_const_net__aoffset = /*OffsetOf*/ (u32)(__offsetof(net__Addr, addr));
}
	_const_net__err_port_out_of_range = error_with_code(_SLIT("net: port out of range"), (int_literal)(0 + 5));
	_const_net__err_no_udp_remote = error_with_code(_SLIT("net: no udp remote"), (int_literal)(0 + 6));
	_const_net__err_timed_out = error_with_code(_SLIT("net: op timed out"), (int_literal)(0 + 9));
{
	_const_net__msg_dontwait = MSG_DONTWAIT;
}
	_const_net__error_ewouldblock = ((int)(EWOULDBLOCK));
	_const_net__error_eagain = ((int)(EAGAIN));
{
	_const_net__infinite_timeout = _const_time__infinite;
}
	_const_net__tcp_default_read_timeout = 30 * _const_time__second;
	_const_net__tcp_default_write_timeout = 30 * _const_time__second;
	// Calling fn init() for module net
	net__init();
	// Initializations of consts for module net.mbedtls
{
	_const_net__mbedtls__ctr_drbg = ((mbedtls_ctr_drbg_context){EMPTY_STRUCT_INITIALIZATION});
}
{
	_const_net__mbedtls__entropy = ((mbedtls_entropy_context){EMPTY_STRUCT_INITIALIZATION});
}
{
	_const_net__mbedtls__mbedtls_client_read_timeout_ms = 550;
}
{
	_const_net__mbedtls__mbedtls_server_read_timeout_ms = 41000;
}
	// Calling fn init() for module net.mbedtls
	net__mbedtls__init();
	// Initializations of consts for module net.http
{
	_const_net__http__common_header_map = new_map_init_noscan_value(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 102, sizeof(string), sizeof(net__http__CommonHeader),
	_MOV((string[102]){
		_SLIT("accept"),
		_SLIT("accept-ch"),
		_SLIT("accept-charset"),
		_SLIT("accept-ch-lifetime"),
		_SLIT("accept-encoding"),
		_SLIT("accept-language"),
		_SLIT("accept-patch"),
		_SLIT("accept-post"),
		_SLIT("accept-ranges"),
		_SLIT("access-control-allow-credentials"),
		_SLIT("access-control-allow-headers"),
		_SLIT("access-control-allow-methods"),
		_SLIT("access-control-allow-origin"),
		_SLIT("access-control-expose-headers"),
		_SLIT("access-control-max-age"),
		_SLIT("access-control-request-headers"),
		_SLIT("access-control-request-method"),
		_SLIT("age"),
		_SLIT("allow"),
		_SLIT("alt-svc"),
		_SLIT("authorization"),
		_SLIT("cache-control"),
		_SLIT("clear-site-data"),
		_SLIT("connection"),
		_SLIT("content-disposition"),
		_SLIT("content-encoding"),
		_SLIT("content-language"),
		_SLIT("content-length"),
		_SLIT("content-location"),
		_SLIT("content-range"),
		_SLIT("content-security-policy"),
		_SLIT("content-security-policy-report-only"),
		_SLIT("content-type"),
		_SLIT("cookie"),
		_SLIT("cross-origin-embedder-policy"),
		_SLIT("cross-origin-opener-policy"),
		_SLIT("cross-origin-resource-policy"),
		_SLIT("date"),
		_SLIT("device-memory"),
		_SLIT("digest"),
		_SLIT("dnt"),
		_SLIT("early-data"),
		_SLIT("etag"),
		_SLIT("expect"),
		_SLIT("expect-ct"),
		_SLIT("expires"),
		_SLIT("feature-policy"),
		_SLIT("forwarded"),
		_SLIT("from"),
		_SLIT("host"),
		_SLIT("if-match"),
		_SLIT("if-modified-since"),
		_SLIT("if-none-match"),
		_SLIT("if-range"),
		_SLIT("if-unmodified-since"),
		_SLIT("index"),
		_SLIT("keep-alive"),
		_SLIT("large-allocation"),
		_SLIT("last-modified"),
		_SLIT("link"),
		_SLIT("location"),
		_SLIT("nel"),
		_SLIT("origin"),
		_SLIT("pragma"),
		_SLIT("proxy-authenticate"),
		_SLIT("proxy-authorization"),
		_SLIT("range"),
		_SLIT("referer"),
		_SLIT("referrer-policy"),
		_SLIT("retry-after"),
		_SLIT("save-data"),
		_SLIT("sec-fetch-dest"),
		_SLIT("sec-fetch-mode"),
		_SLIT("sec-fetch-site"),
		_SLIT("sec-fetch-user"),
		_SLIT("sec-websocket-accept"),
		_SLIT("sec_websocket_key"),
		_SLIT("server"),
		_SLIT("server-timing"),
		_SLIT("set-cookie"),
		_SLIT("sourcemap"),
		_SLIT("strict-transport-security"),
		_SLIT("te"),
		_SLIT("timing-allow-origin"),
		_SLIT("tk"),
		_SLIT("trailer"),
		_SLIT("transfer-encoding"),
		_SLIT("upgrade"),
		_SLIT("upgrade-insecure-requests"),
		_SLIT("user-agent"),
		_SLIT("vary"),
		_SLIT("via"),
		_SLIT("want-digest"),
		_SLIT("warning"),
		_SLIT("www-authenticate"),
		_SLIT("x-content-type-options"),
		_SLIT("x-dns-prefetch-control"),
		_SLIT("x-forwarded-for"),
		_SLIT("x-forwarded-host"),
		_SLIT("x-forwarded-proto"),
		_SLIT("x-frame-options"),
		_SLIT("x-xss-protection"),
	}),
	_MOV((net__http__CommonHeader[102]){
		net__http__CommonHeader__accept, 
		net__http__CommonHeader__accept_ch, 
		net__http__CommonHeader__accept_charset, 
		net__http__CommonHeader__accept_ch_lifetime, 
		net__http__CommonHeader__accept_encoding, 
		net__http__CommonHeader__accept_language, 
		net__http__CommonHeader__accept_patch, 
		net__http__CommonHeader__accept_post, 
		net__http__CommonHeader__accept_ranges, 
		net__http__CommonHeader__access_control_allow_credentials, 
		net__http__CommonHeader__access_control_allow_headers, 
		net__http__CommonHeader__access_control_allow_methods, 
		net__http__CommonHeader__access_control_allow_origin, 
		net__http__CommonHeader__access_control_expose_headers, 
		net__http__CommonHeader__access_control_max_age, 
		net__http__CommonHeader__access_control_request_headers, 
		net__http__CommonHeader__access_control_request_method, 
		net__http__CommonHeader__age, 
		net__http__CommonHeader__allow, 
		net__http__CommonHeader__alt_svc, 
		net__http__CommonHeader__authorization, 
		net__http__CommonHeader__cache_control, 
		net__http__CommonHeader__clear_site_data, 
		net__http__CommonHeader__connection, 
		net__http__CommonHeader__content_disposition, 
		net__http__CommonHeader__content_encoding, 
		net__http__CommonHeader__content_language, 
		net__http__CommonHeader__content_length, 
		net__http__CommonHeader__content_location, 
		net__http__CommonHeader__content_range, 
		net__http__CommonHeader__content_security_policy, 
		net__http__CommonHeader__content_security_policy_report_only, 
		net__http__CommonHeader__content_type, 
		net__http__CommonHeader__cookie, 
		net__http__CommonHeader__cross_origin_embedder_policy, 
		net__http__CommonHeader__cross_origin_opener_policy, 
		net__http__CommonHeader__cross_origin_resource_policy, 
		net__http__CommonHeader__date, 
		net__http__CommonHeader__device_memory, 
		net__http__CommonHeader__digest, 
		net__http__CommonHeader__dnt, 
		net__http__CommonHeader__early_data, 
		net__http__CommonHeader__etag, 
		net__http__CommonHeader__expect, 
		net__http__CommonHeader__expect_ct, 
		net__http__CommonHeader__expires, 
		net__http__CommonHeader__feature_policy, 
		net__http__CommonHeader__forwarded, 
		net__http__CommonHeader__from, 
		net__http__CommonHeader__host, 
		net__http__CommonHeader__if_match, 
		net__http__CommonHeader__if_modified_since, 
		net__http__CommonHeader__if_none_match, 
		net__http__CommonHeader__if_range, 
		net__http__CommonHeader__if_unmodified_since, 
		net__http__CommonHeader__index, 
		net__http__CommonHeader__keep_alive, 
		net__http__CommonHeader__large_allocation, 
		net__http__CommonHeader__last_modified, 
		net__http__CommonHeader__link, 
		net__http__CommonHeader__location, 
		net__http__CommonHeader__nel, 
		net__http__CommonHeader__origin, 
		net__http__CommonHeader__pragma, 
		net__http__CommonHeader__proxy_authenticate, 
		net__http__CommonHeader__proxy_authorization, 
		net__http__CommonHeader__range, 
		net__http__CommonHeader__referer, 
		net__http__CommonHeader__referrer_policy, 
		net__http__CommonHeader__retry_after, 
		net__http__CommonHeader__save_data, 
		net__http__CommonHeader__sec_fetch_dest, 
		net__http__CommonHeader__sec_fetch_mode, 
		net__http__CommonHeader__sec_fetch_site, 
		net__http__CommonHeader__sec_fetch_user, 
		net__http__CommonHeader__sec_websocket_accept, 
		net__http__CommonHeader__sec_websocket_key, 
		net__http__CommonHeader__server, 
		net__http__CommonHeader__server_timing, 
		net__http__CommonHeader__set_cookie, 
		net__http__CommonHeader__sourcemap, 
		net__http__CommonHeader__strict_transport_security, 
		net__http__CommonHeader__te, 
		net__http__CommonHeader__timing_allow_origin, 
		net__http__CommonHeader__tk, 
		net__http__CommonHeader__trailer, 
		net__http__CommonHeader__transfer_encoding, 
		net__http__CommonHeader__upgrade, 
		net__http__CommonHeader__upgrade_insecure_requests, 
		net__http__CommonHeader__user_agent, 
		net__http__CommonHeader__vary, 
		net__http__CommonHeader__via, 
		net__http__CommonHeader__want_digest, 
		net__http__CommonHeader__warning, 
		net__http__CommonHeader__www_authenticate, 
		net__http__CommonHeader__x_content_type_options, 
		net__http__CommonHeader__x_dns_prefetch_control, 
		net__http__CommonHeader__x_forwarded_for, 
		net__http__CommonHeader__x_forwarded_host, 
		net__http__CommonHeader__x_forwarded_proto, 
		net__http__CommonHeader__x_frame_options, 
		net__http__CommonHeader__x_xss_protection, 
	})
)
;
}
	// Initializations of consts for module veb
	_const_veb__boundary_start = _SLIT("boundary=");
{
_result_net__http__Header _t1 = net__http__new_custom_header_from_map(new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(string),
	_MOV((string[1]){
		_SLIT("Server"),
	}),
	_MOV((string[1]){
		_SLIT("veb"), 
	})
)
);
if (_t1.is_error) {
	IError err = _t1.err;
	_v_panic(_SLIT("should never fail"));
	VUNREACHABLE();
;
}

	*(net__http__Header*)_t1.data = 	_const_veb__headers_close = (*(net__http__Header*)_t1.data);
}
{
	_const_veb__mime_types = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 81, sizeof(string), sizeof(string),
	_MOV((string[81]){
		_SLIT(".aac"),
		_SLIT(".abw"),
		_SLIT(".arc"),
		_SLIT(".avi"),
		_SLIT(".azw"),
		_SLIT(".bin"),
		_SLIT(".bmp"),
		_SLIT(".bz"),
		_SLIT(".bz2"),
		_SLIT(".cda"),
		_SLIT(".csh"),
		_SLIT(".css"),
		_SLIT(".csv"),
		_SLIT(".doc"),
		_SLIT(".docx"),
		_SLIT(".eot"),
		_SLIT(".epub"),
		_SLIT(".gz"),
		_SLIT(".gif"),
		_SLIT(".htm"),
		_SLIT(".html"),
		_SLIT(".ico"),
		_SLIT(".ics"),
		_SLIT(".jar"),
		_SLIT(".jpeg"),
		_SLIT(".jpg"),
		_SLIT(".js"),
		_SLIT(".json"),
		_SLIT(".jsonld"),
		_SLIT(".mid"),
		_SLIT(".midi"),
		_SLIT(".mjs"),
		_SLIT(".mp3"),
		_SLIT(".mp4"),
		_SLIT(".mpeg"),
		_SLIT(".mpkg"),
		_SLIT(".odp"),
		_SLIT(".ods"),
		_SLIT(".odt"),
		_SLIT(".oga"),
		_SLIT(".ogv"),
		_SLIT(".ogx"),
		_SLIT(".opus"),
		_SLIT(".otf"),
		_SLIT(".png"),
		_SLIT(".pdf"),
		_SLIT(".php"),
		_SLIT(".ppt"),
		_SLIT(".pptx"),
		_SLIT(".rar"),
		_SLIT(".rtf"),
		_SLIT(".scss"),
		_SLIT(".sh"),
		_SLIT(".svg"),
		_SLIT(".swf"),
		_SLIT(".tar"),
		_SLIT(".tif"),
		_SLIT(".tiff"),
		_SLIT(".ts"),
		_SLIT(".ttf"),
		_SLIT(".txt"),
		_SLIT(".vsd"),
		_SLIT(".wasm"),
		_SLIT(".wav"),
		_SLIT(".weba"),
		_SLIT(".webm"),
		_SLIT(".webp"),
		_SLIT(".woff"),
		_SLIT(".woff2"),
		_SLIT(".xhtml"),
		_SLIT(".xls"),
		_SLIT(".xlsx"),
		_SLIT(".xml"),
		_SLIT(".xul"),
		_SLIT(".zip"),
		_SLIT(".3gp"),
		_SLIT(".3g2"),
		_SLIT(".7z"),
		_SLIT(".m3u8"),
		_SLIT(".vsh"),
		_SLIT(".v"),
	}),
	_MOV((string[81]){
		_SLIT("audio/aac"), 
		_SLIT("application/x-abiword"), 
		_SLIT("application/x-freearc"), 
		_SLIT("video/x-msvideo"), 
		_SLIT("application/vnd.amazon.ebook"), 
		_SLIT("application/octet-stream"), 
		_SLIT("image/bmp"), 
		_SLIT("application/x-bzip"), 
		_SLIT("application/x-bzip2"), 
		_SLIT("application/x-cdf"), 
		_SLIT("application/x-csh"), 
		_SLIT("text/css"), 
		_SLIT("text/csv"), 
		_SLIT("application/msword"), 
		_SLIT("application/vnd.openxmlformats-officedocument.wordprocessingml.document"), 
		_SLIT("application/vnd.ms-fontobject"), 
		_SLIT("application/epub+zip"), 
		_SLIT("application/gzip"), 
		_SLIT("image/gif"), 
		_SLIT("text/html"), 
		_SLIT("text/html"), 
		_SLIT("image/vnd.microsoft.icon"), 
		_SLIT("text/calendar"), 
		_SLIT("application/java-archive"), 
		_SLIT("image/jpeg"), 
		_SLIT("image/jpeg"), 
		_SLIT("text/javascript"), 
		_SLIT("application/json"), 
		_SLIT("application/ld+json"), 
		_SLIT("audio/midi audio/x-midi"), 
		_SLIT("audio/midi audio/x-midi"), 
		_SLIT("text/javascript"), 
		_SLIT("audio/mpeg"), 
		_SLIT("video/mp4"), 
		_SLIT("video/mpeg"), 
		_SLIT("application/vnd.apple.installer+xml"), 
		_SLIT("application/vnd.oasis.opendocument.presentation"), 
		_SLIT("application/vnd.oasis.opendocument.spreadsheet"), 
		_SLIT("application/vnd.oasis.opendocument.text"), 
		_SLIT("audio/ogg"), 
		_SLIT("video/ogg"), 
		_SLIT("application/ogg"), 
		_SLIT("audio/opus"), 
		_SLIT("font/otf"), 
		_SLIT("image/png"), 
		_SLIT("application/pdf"), 
		_SLIT("application/x-httpd-php"), 
		_SLIT("application/vnd.ms-powerpoint"), 
		_SLIT("application/vnd.openxmlformats-officedocument.presentationml.presentation"), 
		_SLIT("application/vnd.rar"), 
		_SLIT("application/rtf"), 
		_SLIT("text/css"), 
		_SLIT("application/x-sh"), 
		_SLIT("image/svg+xml"), 
		_SLIT("application/x-shockwave-flash"), 
		_SLIT("application/x-tar"), 
		_SLIT("image/tiff"), 
		_SLIT("image/tiff"), 
		_SLIT("video/mp2t"), 
		_SLIT("font/ttf"), 
		_SLIT("text/plain"), 
		_SLIT("application/vnd.visio"), 
		_SLIT("application/wasm"), 
		_SLIT("audio/wav"), 
		_SLIT("audio/webm"), 
		_SLIT("video/webm"), 
		_SLIT("image/webp"), 
		_SLIT("font/woff"), 
		_SLIT("font/woff2"), 
		_SLIT("application/xhtml+xml"), 
		_SLIT("application/vnd.ms-excel"), 
		_SLIT("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"), 
		_SLIT("application/xml"), 
		_SLIT("application/vnd.mozilla.xul+xml"), 
		_SLIT("application/zip"), 
		_SLIT("video/3gpp"), 
		_SLIT("video/3gpp2"), 
		_SLIT("application/x-7z-compressed"), 
		_SLIT("application/vnd.apple.mpegurl"), 
		_SLIT("text/x-vlang"), 
		_SLIT("text/x-vlang"), 
	})
)
;
}
Array_string _t1 = {0};
Array_net__http__CommonHeader _t1_orig = new_array_from_c_array_noscan(7, 7, sizeof(net__http__CommonHeader), _MOV((net__http__CommonHeader[7]){net__http__CommonHeader__cache_control, net__http__CommonHeader__content_language, net__http__CommonHeader__content_length, net__http__CommonHeader__content_type, net__http__CommonHeader__expires, net__http__CommonHeader__last_modified, net__http__CommonHeader__pragma}));
int _t1_len = _t1_orig.len;
_t1 = __new_array(0, _t1_len, sizeof(string));

for (int _t3 = 0; _t3 < _t1_len; ++_t3) {
	net__http__CommonHeader it = ((net__http__CommonHeader*) _t1_orig.data)[_t3];
	string _t2 = net__http__CommonHeader_str(it);
	array_push((array*)&_t1, &_t2);
}
_const_veb__cors_safelisted_response_headers =_t1;
	_const_veb__veb_livereload_server_start = i64_str(time__ticks());
	_const_veb__http_400 = net__http__new_response(((net__http__ResponseConfig){.version = net__http__Version__v1_1,.status = net__http__Status__bad_request,.header = net__http__Header_join(net__http__new_header(new_array_from_c_array(1, 1, sizeof(net__http__HeaderConfig), _MOV((net__http__HeaderConfig[1]){((net__http__HeaderConfig){.key = net__http__CommonHeader__content_type,.value = _SLIT("text/plain"),})}))), _const_veb__headers_close),.body = _SLIT("400 Bad Request"),}));
	_const_veb__http_408 = net__http__new_response(((net__http__ResponseConfig){.version = net__http__Version__v1_1,.status = net__http__Status__request_timeout,.header = net__http__Header_join(net__http__new_header(new_array_from_c_array(1, 1, sizeof(net__http__HeaderConfig), _MOV((net__http__HeaderConfig[1]){((net__http__HeaderConfig){.key = net__http__CommonHeader__content_type,.value = _SLIT("text/plain"),})}))), _const_veb__headers_close),.body = _SLIT("408 Request Timeout"),}));
	_const_veb__http_413 = net__http__new_response(((net__http__ResponseConfig){.version = net__http__Version__v1_1,.status = net__http__Status__request_entity_too_large,.header = net__http__Header_join(net__http__new_header(new_array_from_c_array(1, 1, sizeof(net__http__HeaderConfig), _MOV((net__http__HeaderConfig[1]){((net__http__HeaderConfig){.key = net__http__CommonHeader__content_type,.value = _SLIT("text/plain"),})}))), _const_veb__headers_close),.body = _SLIT("413 Request entity is too large"),}));
	_const_veb__http_500 = net__http__new_response(((net__http__ResponseConfig){.version = net__http__Version__v1_1,.status = net__http__Status__internal_server_error,.header = net__http__Header_join(net__http__new_header(new_array_from_c_array(1, 1, sizeof(net__http__HeaderConfig), _MOV((net__http__HeaderConfig[1]){((net__http__HeaderConfig){.key = net__http__CommonHeader__content_type,.value = _SLIT("text/plain"),})}))), _const_veb__headers_close),.body = _SLIT("500 Internal Server Error"),}));
	// Initializations of consts for module main
	_const_main__version = _SLIT("v2.6.0");
}
void _vcleanup(void) {
}

int main(int ___argc, char** ___argv){
	g_main_argc = ___argc;
	g_main_argv = ___argv;
	__closure_init(); // main()
#if defined(_VGCBOEHM)
	GC_set_pages_executable(0);
	GC_INIT();
#endif
	_vinit(___argc, (voidptr)___argv);
	main__main();
	_vcleanup();
	return 0;
}
// THE END.
